<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Complete StrictPath Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive guide to strict-path: Type-safe path boundaries preventing directory traversal attacks">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Complete StrictPath Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DK26/strict-path-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started-with-strict-path"><a class="header" href="#getting-started-with-strict-path">Getting Started with strict-path</a></h1>
<h2 id="what-is-strict-path"><a class="header" href="#what-is-strict-path">What is strict-path?</a></h2>
<p>Have you ever worried about users trying to access files they shouldn't? Like when someone enters <code>../../../etc/passwd</code> to try to escape from a safe directory? That's called a "directory traversal" attack, and it's surprisingly common.</p>
<p><strong>strict-path</strong> solves this problem by creating path boundaries - safe boundaries that paths cannot escape from. It comes in two modes: StrictPath (via PathBoundary) which is a path proven to have passed a validation filter, and VirtualPath (via VirtualRoot) which you could think of it like a sandboxed file path.</p>
<h2 id="why-should-you-care"><a class="header" href="#why-should-you-care">Why Should You Care?</a></h2>
<p>Directory traversal vulnerabilities are everywhere:</p>
<ul>
<li>Web applications where users upload files</li>
<li>CLI tools that accept file paths as arguments</li>
<li>Any application that processes user-provided paths</li>
<li>Systems that extract archives (ZIP files, etc.)</li>
</ul>
<p>Getting path security wrong can expose your entire filesystem to attackers. With strict-path, the Rust compiler helps ensure you can't make these mistakes.</p>
<h2 id="your-first-pathboundary"><a class="header" href="#your-first-pathboundary">Your First PathBoundary</a></h2>
<p>Let's start with a simple example. Say you're building a web app where users can upload and download their files, but you want to keep them contained in a specific directory:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::PathBoundary;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a path boundary in the "user_files" directory
    // This creates the directory if it doesn't exist
    let user_files_dir = PathBoundary::try_new_create("user_files")?;

    // Now any path we validate through this path boundary will be contained
    // within the "user_files" directory

    // ✅ This is SAFE - creates "user_files/documents/report.txt"
    let report = user_files_dir.strict_join("documents/report.txt")?;
    report.create_parent_dir_all()?;
    report.write("Quarterly report contents")?;

    // ❌ This would FAIL - can't escape the path boundary!
    // let _bad = user_files_dir.strict_join("../../../etc/passwd")?; // Error!

    let display = report.strictpath_display();
    println!("Safe path: {display}");

    Ok(())
}</code></pre></pre>
<h2 id="what-just-happened"><a class="header" href="#what-just-happened">What Just Happened?</a></h2>
<ol>
<li><strong>Created a path boundary</strong>: <code>PathBoundary::try_new_create("user_files")</code> sets up a safe boundary</li>
<li><strong>Validated a path</strong>: <code>path_boundary.strict_join("documents/report.txt")</code> checks the path is safe</li>
<li><strong>Got protection</strong>: Any attempt to escape the path boundary (like <code>../../../etc/passwd</code>) fails immediately</li>
</ol>
<p>The magic is that once you have a <code>StrictPath</code>, you <em>know</em> it's safe. The type system guarantees it.</p>
<h2 id="working-with-strict-paths"><a class="header" href="#working-with-strict-paths">Working with Strict Paths</a></h2>
<p>Once you have a <code>StrictPath</code>, you can use it for file operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn save_user_file() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads_dir = PathBoundary::try_new_create("uploads")?;

    // User wants to save to "my-document.txt"
    let user_input = "my-document.txt"; // untrusted
    let safe_path = uploads_dir.strict_join(user_input)?;

    // Write some content safely using built-in helpers
    safe_path.write("Hello, world!")?;

    // Read it back
    let content = safe_path.read_to_string()?;
    println!("File contains: {content}");

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="type-safety-the-secret-sauce"><a class="header" href="#type-safety-the-secret-sauce">Type Safety: The Secret Sauce</a></h2>
<p>Here's where strict-path gets really clever. You can write functions that <em>only</em> accept safe paths:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath};

// This function can ONLY be called with safe paths
fn process_user_file(path: &amp;StrictPath) -&gt; std::io::Result&lt;String&gt; {
    // We know this path is safe - no need to validate again
    path.read_to_string()
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let data_dir = PathBoundary::try_new_create("safe_area")?;
    let user_data = data_dir.strict_join("user-data.txt")?;

    // ✅ This works - user_data is a StrictPath
    let _content = process_user_file(&amp;user_data)?;

    // ❌ This won't compile - can't pass an unsafe path!
    // let unsafe_path = std::path::Path::new("/etc/passwd");
    // let _content = process_user_file(unsafe_path); // Compilation error!

    Ok(())
}</code></pre></pre>
<p>This means once you set up your path boundaries correctly, the compiler prevents you from accidentally using unsafe paths.</p>
<h2 id="virtual-paths-user-friendly-sandboxes"><a class="header" href="#virtual-paths-user-friendly-sandboxes">Virtual Paths: User-Friendly Sandboxes</a></h2>
<p>Sometimes you want to give users the illusion that they have their own private filesystem, starting from <code>/</code>. That's what <code>VirtualPath</code> is for:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::VirtualRoot;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a virtual root that maps to "user_123_files" on disk
    let vroot = VirtualRoot::try_new_create("user_123_files")?;

    // User thinks they're working from "/"
    let vpath = vroot.virtual_join("/documents/my-file.txt")?;

    // But it actually maps to "user_123_files/documents/my-file.txt"
    let user_sees = vpath.virtualpath_display();
    let system_path = vpath.as_unvirtual().strictpath_display();
    println!("User sees: {user_sees}");
    println!("Actually stored at: {system_path}");

    Ok(())
}</code></pre></pre>
<p>This is perfect for multi-user applications where each user should feel like they have their own filesystem.</p>
<h2 id="api-summary"><a class="header" href="#api-summary">API Summary</a></h2>
<p>That's really all you need to know! The core API is simple:</p>
<h3 id="creating-safe-boundaries"><a class="header" href="#creating-safe-boundaries">Creating Safe Boundaries</a></h3>
<ul>
<li><code>PathBoundary::try_new(path)</code> - Use existing directory as path boundary (fails if not found)</li>
<li><code>PathBoundary::try_new_create(path)</code> - Create directory if needed (for setup/initialization)</li>
<li><code>VirtualRoot::try_new(path)</code> - Virtual filesystem root (expects existing directory)</li>
<li><code>VirtualRoot::try_new_create(path)</code> - Create virtual root if needed (for user storage)</li>
</ul>
<h3 id="validating-paths"><a class="header" href="#validating-paths">Validating Paths</a></h3>
<ul>
<li><code>path_boundary.strict_join(user_path)</code> - Returns <code>StrictPath</code> or error</li>
<li><code>vroot.virtual_join(user_path)</code> - Returns <code>VirtualPath</code> or error</li>
</ul>
<h3 id="using-safe-paths"><a class="header" href="#using-safe-paths">Using Safe Paths</a></h3>
<ul>
<li>Both <code>StrictPath</code> and <code>VirtualPath</code> work with standard file operations</li>
<li>They implement <code>.interop_os()</code> so you can pass them to <code>fs::read</code>, <code>fs::write</code>, etc.</li>
<li>The type system prevents using unvalidated paths</li>
</ul>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="web-file-upload"><a class="header" href="#web-file-upload">Web File Upload</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Public API: callers pass untrusted filename; we validate, then call an internal helper
fn handle_file_upload(filename: &amp;str, content: &amp;[u8]) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads_dir = PathBoundary::try_new_create("uploads")?;
    let dest = uploads_dir.strict_join(filename)?; // ✅ Validate external input
    save_uploaded(&amp;dest, content) // Internal API enforces &amp;StrictPath in signature
}

// Internal helper encodes guarantee in its signature
fn save_uploaded(path: &amp;StrictPath, content: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    path.create_parent_dir_all()?;
    path.write(content)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, VirtualRoot};

// Prefer signatures that encode guarantees explicitly: pass the boundary and the untrusted name
fn load_config(config_dir: &amp;PathBoundary, config_name: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    config_dir.strict_join(config_name)?.read_to_string() // ✅ Validated
}

fn setup_user_storage(user_id: u32) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a user-facing virtual root for UI flows
    let vroot = VirtualRoot::try_new_create(format!("users/{user_id}"))?;
    let docs = vroot.virtual_join("documents")?;
    docs.create_dir_all()?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<ul>
<li><strong>Real-World Examples</strong>: See complete applications using strict-path</li>
<li><strong>Understanding Type-History</strong>: Learn how the internal security works (for contributors)</li>
<li><strong>Choosing Canonicalized vs Lexical</strong>: See Ergonomics → Choosing Canonicalized vs Lexical for performance vs safety trade-offs</li>
</ul>
<p>The key rule: <strong>always validate external paths through a path boundary before using them</strong>. Whether it's user input, configuration files, or data from external sources - if you didn't create the path yourself, join it to a path boundary first!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unlocking-the-mathematical-security-of-strict-path"><a class="header" href="#unlocking-the-mathematical-security-of-strict-path">Unlocking the Mathematical Security of strict-path</a></h1>
<blockquote>
<p><strong>Welcome!</strong> You're about to learn how to make filesystem attacks <em>mathematically impossible</em> in your code. No CVE research required. No security expertise needed. Just types, the compiler, and some clever design patterns.</p>
</blockquote>
<p>This tutorial builds your understanding step-by-step, from basic path validation to compile-time authorization guarantees. Each section introduces <strong>one concept at a time</strong>, with runnable examples you can copy and paste.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h2>
<p><strong>Stage 1: <a href="tutorial/./stage1_basic_promise.html">The Basic Promise</a></strong><br />
Learn how <code>StrictPath</code> makes path escapes mathematically impossible, without any markers yet.</p>
<p><strong>Stage 2: <a href="tutorial/./stage2_mixup_problem.html">The Mix-Up Problem</a></strong><br />
Discover the confusing problem that emerges when you have multiple boundaries.</p>
<p><strong>Stage 3: <a href="tutorial/./stage3_markers.html">Markers to the Rescue</a></strong><br />
See how markers solve the mix-up problem with compile-time domain separation.</p>
<p><strong>Stage 4: <a href="tutorial/./stage4_authorization.html">Authorization with change_marker()</a></strong><br />
Learn to encode authorization requirements in the type system using <code>change_marker()</code>.</p>
<p><strong>Stage 5: <a href="tutorial/./stage5_virtual_paths.html">Virtual Paths</a></strong><br />
Understand how <code>VirtualPath</code> extends <code>StrictPath</code> with user-friendly sandboxing semantics.</p>
<p><strong>Stage 6: <a href="tutorial/./stage6_features.html">Feature Integration</a></strong><br />
Integrate with your ecosystem using feature-gated constructors (<code>dirs</code>, <code>tempfile</code>, <code>app-path</code>, <code>serde</code>).</p>
<h2 id="the-progressive-guarantee"><a class="header" href="#the-progressive-guarantee">The Progressive Guarantee</a></h2>
<p>As you progress through the stages, the compiler's guarantees grow stronger:</p>
<div class="table-wrapper"><table><thead><tr><th>Stage</th><th>What You Master</th><th>The Guarantee</th></tr></thead><tbody>
<tr><td><strong>1</strong></td><td>Basic boundaries</td><td>Path cannot escape</td></tr>
<tr><td><strong>2</strong></td><td>(Problem statement)</td><td>—</td></tr>
<tr><td><strong>3</strong></td><td>Domain separation</td><td>Path is in correct domain</td></tr>
<tr><td><strong>4</strong></td><td>Authorization encoding</td><td>Authorization proven by compiler</td></tr>
<tr><td><strong>5</strong></td><td>Virtual sandboxes</td><td>Clean UX + safe system paths</td></tr>
<tr><td><strong>6</strong></td><td>Ecosystem integration</td><td>External APIs + boundary enforcement</td></tr>
</tbody></table>
</div>
<h2 id="the-end-result"><a class="header" href="#the-end-result">The End Result</a></h2>
<blockquote>
<p><strong>By the end of this tutorial, you'll understand how the Rust compiler can mathematically prove that:</strong></p>
<ul>
<li>✅ Paths cannot escape their boundaries</li>
<li>✅ Paths are in the correct resource domain</li>
<li>✅ Authorization was granted for the specified operations</li>
<li>✅ All of this happens at <strong>compile time</strong> — no runtime overhead!</li>
</ul>
</blockquote>
<p>Ready? Let's unlock the security vault. 🔐</p>
<p><strong><a href="tutorial/./stage1_basic_promise.html">Start with Stage 1: The Basic Promise →</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-1-the-basic-promise--paths-that-cant-escape"><a class="header" href="#stage-1-the-basic-promise--paths-that-cant-escape">Stage 1: The Basic Promise — Paths That Can't Escape</a></h1>
<blockquote>
<p><em>"Give me one untrusted filename, and I'll show you a safe filesystem operation."</em></p>
</blockquote>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>You're building a web service. Users upload files. Simple, right? <strong>Wrong.</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ DISASTER WAITING TO HAPPEN
fn save_user_upload(filename: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    let path = format!("uploads/{}", filename);
    std::fs::write(path, data)?;  // filename could be "../../../etc/passwd"
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>What just happened?</strong> If <code>filename = "../../../etc/passwd"</code>, you just gave an attacker write access to your entire filesystem. Game over.</p>
<h2 id="the-solution-strictpath"><a class="header" href="#the-solution-strictpath">The Solution: StrictPath</a></h2>
<p><code>StrictPath</code> makes escapes <strong>mathematically impossible</strong>. Here's the same code, but safe:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn save_user_upload(filename: &amp;str, data: &amp;[u8]) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a boundary — the perimeter fence
    let uploads_boundary = StrictPath::with_boundary_create("uploads")?;

    // Validate the untrusted filename
    let safe_path = uploads_boundary.strict_join(filename)?;  // ✅ Attack = Error

    // Now we can safely write
    safe_path.write(data)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="what-changed"><a class="header" href="#what-changed">What Changed?</a></h2>
<ol>
<li><strong><code>with_boundary_create("uploads")</code></strong> — Sets up a security perimeter at <code>./uploads/</code></li>
<li><strong><code>strict_join(filename)</code></strong> — Validates that <code>filename</code> stays inside the boundary
<ul>
<li>Valid: <code>"report.txt"</code> → <code>./uploads/report.txt</code> ✅</li>
<li>Valid: <code>"docs/report.txt"</code> → <code>./uploads/docs/report.txt</code> ✅</li>
<li>Attack: <code>"../../../etc/passwd"</code> → <strong>Error</strong> ❌</li>
</ul>
</li>
<li><strong><code>safe_path.write(data)</code></strong> — Built-in I/O helpers that work directly on <code>StrictPath</code></li>
</ol>
<p><strong>The guarantee:</strong> If you have a <code>StrictPath</code>, it's <strong>impossible</strong> for it to reference anything outside its boundary. Not "we validated it" — <strong>impossible by construction</strong>.</p>
<h2 id="try-it-yourself"><a class="header" href="#try-it-yourself">Try It Yourself</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::StrictPath;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create the boundary
    let data_dir = StrictPath::with_boundary_create("user_data")?;

    // These all work fine
    let file1 = data_dir.strict_join("notes.txt")?;
    let file2 = data_dir.strict_join("projects/rust/main.rs")?;
    let file3 = data_dir.strict_join("deeply/nested/structure/file.json")?;

    println!("✅ Safe: {}", file1.strictpath_display());
    println!("✅ Safe: {}", file2.strictpath_display());
    println!("✅ Safe: {}", file3.strictpath_display());

    // This would fail at runtime with an error
    // let evil = data_dir.strict_join("../../../etc/passwd")?;  // ❌ PathEscapesBoundary

    Ok(())
}</code></pre></pre>
<h2 id="the-core-promise"><a class="header" href="#the-core-promise">The Core Promise</a></h2>
<blockquote>
<p><strong>If you have a <code>StrictPath</code>, it is impossible for it to escape its boundary.</strong></p>
</blockquote>
<p>This isn't validation — it's a <strong>type-level guarantee</strong>. The security is in the types, enforced by Rust's compiler.</p>
<h2 id="understanding-the-boundary"><a class="header" href="#understanding-the-boundary">Understanding the Boundary</a></h2>
<p>Think of a <code>StrictPath</code> like a <strong>smart pointer with memory</strong> of where it came from:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn demonstrate_boundary() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads = StrictPath::with_boundary_create("uploads")?;
    
    // Every path remembers its boundary
    let doc = uploads.strict_join("document.pdf")?;
    let img = uploads.strict_join("images/photo.jpg")?;
    
    // Both carry a mathematical proof: "I'm inside uploads/"
    // The compiler enforces this guarantee
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Head First Moment:</strong> Think of <code>StrictPath</code> like a smart pointer that remembers its boundary. Once created, it carries a mathematical proof: "I'm inside the fence." The compiler won't let you break that promise.</p>
<h2 id="what-about-edge-cases"><a class="header" href="#what-about-edge-cases">What About Edge Cases?</a></h2>
<p><strong>Q: What if the user provides <code>"../../etc/passwd"</code>?</strong><br />
A: <code>strict_join()</code> returns an error. The path is never created.</p>
<p><strong>Q: What about symlinks that escape?</strong><br />
A: <code>strict-path</code> resolves symlinks during validation. If a symlink points outside the boundary, you get an error.</p>
<p><strong>Q: What about Windows 8.3 short names (<code>PROGRA~1</code>)?</strong><br />
A: Caught and rejected. We validate against all known path aliasing attacks.</p>
<p><strong>Q: What about NTFS Alternate Data Streams (<code>file.txt:hidden</code>)?</strong><br />
A: Normalized and handled safely. No escapes possible.</p>
<p><strong>Q: Is this just string validation?</strong><br />
A: No! This is full canonicalization with filesystem resolution. We handle symlinks, junctions, mounts, and all platform quirks.</p>
<p>See <a href="tutorial/../security_methodology.html">Security Methodology</a> for the complete list of 19+ CVEs we've tested against.</p>
<h2 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h2>
<p>Once you have a <code>StrictPath</code>, you can perform filesystem operations directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn file_operations() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let storage = StrictPath::with_boundary_create("storage")?;
    let file = storage.strict_join("data.txt")?;

    // Write
    file.write(b"Hello, world!")?;

    // Read
    let content = file.read_to_string()?;
    println!("Content: {}", content);

    // Check metadata
    let metadata = file.metadata()?;
    println!("Size: {} bytes", metadata.len());

    // Create parent directories
    let nested = storage.strict_join("deep/nested/file.txt")?;
    nested.create_parent_dir_all()?;
    nested.write(b"Nested content")?;

    // Remove file
    file.remove_file()?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p>✅ <strong><code>StrictPath</code> = Mathematical boundary guarantee</strong><br />
✅ <strong>Attack paths fail explicitly at validation time</strong><br />
✅ <strong>Works with any untrusted input</strong> (user input, config files, LLM output, archive entries)<br />
✅ <strong>Built-in I/O helpers</strong> — no need to convert to <code>Path</code> for common operations<br />
✅ <strong>Handles edge cases</strong> — symlinks, Windows quirks, encoding tricks, etc.</p>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's Next?</a></h2>
<p>You now understand the <strong>basic promise</strong>: paths cannot escape their boundaries.</p>
<p>But what happens when your app grows and you need <strong>multiple</strong> safe directories? That's where things get confusing...</p>
<p><strong><a href="tutorial/./stage2_mixup_problem.html">Continue to Stage 2: The Mix-Up Problem →</a></strong></p>
<hr />
<p><strong>Quick Reference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create boundary
let boundary = StrictPath::with_boundary_create("safe_dir")?;

// Validate untrusted input
let safe_path = boundary.strict_join(untrusted_filename)?;

// Perform I/O
safe_path.write(data)?;
let content = safe_path.read_to_string()?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-2-the-mix-up-problem--when-you-have-multiple-boundaries"><a class="header" href="#stage-2-the-mix-up-problem--when-you-have-multiple-boundaries">Stage 2: The Mix-Up Problem — When You Have Multiple Boundaries</a></h1>
<blockquote>
<p><em>"Wait, which uploads folder is this again?"</em></p>
</blockquote>
<p>In Stage 1, you learned that <code>StrictPath</code> guarantees paths can't escape their boundaries. Perfect! But real applications need <strong>multiple</strong> safe directories. That's where a new problem emerges...</p>
<h2 id="real-world-complexity"><a class="header" href="#real-world-complexity">Real-World Complexity</a></h2>
<p>As your app grows, you need multiple safe directories:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn file_server() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // User uploads
    let uploads_dir = StrictPath::with_boundary_create("user_uploads")?;
    
    // Public web assets (CSS, JS, images)
    let assets_dir = StrictPath::with_boundary_create("public_assets")?;
    
    // System configuration files
    let config_dir = StrictPath::with_boundary_create("system_config")?;

    // Now we have paths from different domains...
    let user_file = uploads_dir.strict_join("document.pdf")?;
    let css_file = assets_dir.strict_join("style.css")?;
    let config_file = config_dir.strict_join("database.toml")?;

    // But they're all the same type!
    // let _: StrictPath = user_file;
    // let _: StrictPath = css_file;
    // let _: StrictPath = config_file;

    // 🚨 DANGER: Easy to mix them up!
    serve_public_asset(&amp;user_file)?;      // Oops! Serving user upload as public asset
    save_user_upload(&amp;config_file)?;      // Double oops! User overwrites config

    Ok(())
}

fn serve_public_asset(path: &amp;StrictPath) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    path.read()  // Should only serve public assets!
}

fn save_user_upload(path: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    path.write(b"user data")  // Should only write to user uploads!
}
<span class="boring">}</span></code></pre></pre>
<h2 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h2>
<p>All <code>StrictPath</code> values look the same to the compiler:</p>
<ul>
<li>User uploads → <code>StrictPath</code></li>
<li>Public assets → <code>StrictPath</code></li>
<li>System config → <code>StrictPath</code></li>
</ul>
<p><strong>The compiler can't help you</strong> catch domain mix-ups. Code review is your only defense. And humans make mistakes.</p>
<h2 id="what-could-go-wrong"><a class="header" href="#what-could-go-wrong">What Could Go Wrong?</a></h2>
<p>Let's see the concrete dangers:</p>
<h3 id="1-security-leak-private-files-exposed"><a class="header" href="#1-security-leak-private-files-exposed">1. Security Leak: Private Files Exposed</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn security_leak_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let private_uploads = StrictPath::with_boundary_create("private_uploads")?;
    let public_site = StrictPath::with_boundary_create("public_site")?;

    // User uploads a private document
    let tax_return = private_uploads.strict_join("tax_return_2024.pdf")?;
    tax_return.write(b"Sensitive financial data")?;

    // Oops! Developer accidentally serves it from the public site handler
    serve_to_internet(&amp;tax_return)?;  // 🚨 Private file now publicly accessible!

    Ok(())
}

fn serve_to_internet(path: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    // This function should only receive public site files
    // But the compiler can't enforce that!
    println!("Serving {} to the internet...", path.strictpath_display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-data-corruption-wrong-directory-modified"><a class="header" href="#2-data-corruption-wrong-directory-modified">2. Data Corruption: Wrong Directory Modified</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn data_corruption_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let user_data = StrictPath::with_boundary_create("user_data")?;
    let system_logs = StrictPath::with_boundary_create("system_logs")?;

    let user_note = user_data.strict_join("notes.txt")?;
    let system_log = system_logs.strict_join("audit.log")?;

    // Oops! Passed the wrong path to the wrong function
    append_user_content(&amp;system_log, "User's random thoughts")?;  // 🚨 Corrupting system log!
    append_audit_entry(&amp;user_note, "ADMIN LOGIN")?;              // 🚨 Audit data in user file!

    Ok(())
}

fn append_user_content(path: &amp;StrictPath, content: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    // Should only receive user_data paths
    let mut existing = path.read_to_string().unwrap_or_default();
    existing.push_str(content);
    path.write(existing.as_bytes())
}

fn append_audit_entry(path: &amp;StrictPath, entry: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    // Should only receive system_logs paths
    let mut log = path.read_to_string().unwrap_or_default();
    log.push_str(&amp;format!("[AUDIT] {}\n", entry));
    path.write(log.as_bytes())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-authorization-bypass-wrong-permissions-applied"><a class="header" href="#3-authorization-bypass-wrong-permissions-applied">3. Authorization Bypass: Wrong Permissions Applied</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn authorization_bypass_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let admin_files = StrictPath::with_boundary_create("admin_files")?;
    let guest_files = StrictPath::with_boundary_create("guest_files")?;

    let sensitive_config = admin_files.strict_join("secrets.toml")?;
    let public_readme = guest_files.strict_join("README.md")?;

    // Oops! Applied wrong permission check to wrong path
    allow_guest_access(&amp;sensitive_config)?;  // 🚨 Guest can access admin secrets!
    require_admin_access(&amp;public_readme)?;   // 🚨 Admin required for public file!

    Ok(())
}

fn allow_guest_access(path: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    println!("Guest can access: {}", path.strictpath_display());
    Ok(())
}

fn require_admin_access(path: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    println!("Admin required for: {}", path.strictpath_display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="why-this-happens"><a class="header" href="#why-this-happens">Why This Happens</a></h2>
<p>The problem is <strong>type erasure</strong>. Once you create paths from different boundaries, they all collapse to the same type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn demonstrate_type_erasure() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads = StrictPath::with_boundary_create("uploads")?;
    let config = StrictPath::with_boundary_create("config")?;
    let cache = StrictPath::with_boundary_create("cache")?;

    let file1 = uploads.strict_join("a.txt")?;  // Type: StrictPath
    let file2 = config.strict_join("b.txt")?;   // Type: StrictPath
    let file3 = cache.strict_join("c.txt")?;    // Type: StrictPath

    // The compiler sees them all as identical
    // You can accidentally swap them and nothing will complain
    let paths = vec![file1, file2, file3];
    
    // Which path is which? The compiler doesn't know!
    for path in paths {
        // Is this uploads, config, or cache? 🤷
        println!("{}", path.strictpath_display());
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="the-defense-human-code-review-fragile"><a class="header" href="#the-defense-human-code-review-fragile">The Defense: Human Code Review (Fragile!)</a></h2>
<p>Without compiler help, you rely on:</p>
<ul>
<li>✍️ <strong>Careful naming</strong> — Hope developers use descriptive variable names</li>
<li>👀 <strong>Code review</strong> — Hope reviewers catch the mix-ups</li>
<li>📝 <strong>Documentation</strong> — Hope everyone reads and remembers it</li>
<li>🧪 <strong>Testing</strong> — Hope tests cover the edge cases</li>
</ul>
<p><strong>Problem:</strong> Humans are fallible. Mistakes slip through. Security bugs ship to production.</p>
<h2 id="head-first-moment"><a class="header" href="#head-first-moment">Head First Moment</a></h2>
<p>Imagine a hospital where <strong>every door key looks identical</strong>. The keys work — they're genuine hospital keys — but there's no way to know which key opens which door.</p>
<ul>
<li>🔑 Operating room key? Looks like every other key.</li>
<li>🔑 Medicine cabinet key? Looks like every other key.</li>
<li>🔑 Patient records room key? Looks like every other key.</li>
</ul>
<p>Sure, you <em>intend</em> to use the right key for the right door. But mistakes happen:</p>
<ul>
<li>Tired nurse grabs the wrong key ❌</li>
<li>New employee doesn't know the system ❌</li>
<li>Emergency situation, grab the nearest key ❌</li>
</ul>
<p><strong>We need keys that physically can't open the wrong doors.</strong></p>
<h2 id="the-real-world-impact"><a class="header" href="#the-real-world-impact">The Real-World Impact</a></h2>
<p>These mix-ups cause real security incidents:</p>
<ul>
<li><strong>CVE-2021-XXXXX:</strong> Web framework served user uploads from static asset handler → RCE</li>
<li><strong>CVE-2020-XXXXX:</strong> Config parser wrote user data to system directory → Privilege escalation</li>
<li><strong>CVE-2019-XXXXX:</strong> Admin dashboard mixed up user ID directories → Data leak</li>
</ul>
<p>The pattern is always the same: <strong>Path from Domain A used in Domain B</strong>.</p>
<h2 id="what-we-need"><a class="header" href="#what-we-need">What We Need</a></h2>
<p>We need the <strong>compiler</strong> to distinguish between paths from different domains:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This should compile:
serve_public_asset(&amp;public_css_file)?;      // ✅ Correct domain

// This should NOT compile:
serve_public_asset(&amp;private_user_file)?;    // ❌ Wrong domain — should be compile error!
<span class="boring">}</span></code></pre></pre>
<p>But how? <code>StrictPath</code> already gives us boundary safety. We just need a way to teach the compiler <strong>which boundary</strong> a path came from...</p>
<h2 id="the-solution-preview"><a class="header" href="#the-solution-preview">The Solution Preview</a></h2>
<p>What if we could <strong>label</strong> each boundary? Give it a <strong>name</strong> the compiler understands?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pseudocode (not real syntax yet)
let uploads: StrictPath&lt;"UserUploads"&gt; = ...;
let assets: StrictPath&lt;"PublicAssets"&gt; = ...;
let config: StrictPath&lt;"SystemConfig"&gt; = ...;

// Now the compiler can see they're different!
fn serve_public_asset(path: &amp;StrictPath&lt;"PublicAssets"&gt;) { ... }

serve_public_asset(&amp;assets)?;   // ✅ Compiles
serve_public_asset(&amp;uploads)?;  // ❌ Compiler error: expected PublicAssets, found UserUploads
<span class="boring">}</span></code></pre></pre>
<p>This is exactly what <strong>markers</strong> do. And that's what you'll learn in the next stage.</p>
<h2 id="key-takeaways-1"><a class="header" href="#key-takeaways-1">Key Takeaways</a></h2>
<p>🚨 <strong>Multiple boundaries → same type → mix-ups possible</strong><br />
🚨 <strong>Mix-ups cause security bugs</strong> (data leaks, corruption, auth bypass)<br />
🚨 <strong>Code review is fragile</strong> — humans make mistakes<br />
🚨 <strong>We need compiler enforcement</strong> — catch errors at compile time</p>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What's Next?</a></h2>
<p>You've seen the problem: multiple boundaries create confusion and risk.</p>
<p>Now you're ready for the solution: <strong>markers</strong> that make the compiler your security guard.</p>
<p><strong><a href="tutorial/./stage3_markers.html">Continue to Stage 3: Markers to the Rescue →</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-3-markers-to-the-rescue--compile-time-domain-separation"><a class="header" href="#stage-3-markers-to-the-rescue--compile-time-domain-separation">Stage 3: Markers to the Rescue — Compile-Time Domain Separation</a></h1>
<blockquote>
<p><em>"Give each boundary a name the compiler understands."</em></p>
</blockquote>
<p>In Stage 2, you saw how multiple boundaries create confusion — all <code>StrictPath</code> values look identical to the compiler. Now you'll learn how <strong>markers</strong> solve this problem by encoding domain information in the type system.</p>
<h2 id="introducing-markers"><a class="header" href="#introducing-markers">Introducing Markers</a></h2>
<p>A <strong>marker</strong> is a zero-cost compile-time label. It's like writing "THIS IS USER UPLOADS" directly on the type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

// Define markers (zero runtime cost!)
struct UserUploads;
struct PublicAssets;
struct SystemConfig;
<span class="boring">}</span></code></pre></pre>
<p>That's it! Three simple structs. But now watch what happens when we use them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct UserUploads;
struct PublicAssets;
struct SystemConfig;

fn file_server_with_markers() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Now each boundary has a distinct type
    let uploads_dir: StrictPath&lt;UserUploads&gt; = 
        StrictPath::with_boundary_create("user_uploads")?;
    
    let assets_dir: StrictPath&lt;PublicAssets&gt; = 
        StrictPath::with_boundary_create("public_assets")?;
    
    let config_dir: StrictPath&lt;SystemConfig&gt; = 
        StrictPath::with_boundary_create("system_config")?;

    // Paths inherit their marker
    let user_file = uploads_dir.strict_join("document.pdf")?;  // StrictPath&lt;UserUploads&gt;
    let css_file = assets_dir.strict_join("style.css")?;      // StrictPath&lt;PublicAssets&gt;
    let config_file = config_dir.strict_join("database.toml")?; // StrictPath&lt;SystemConfig&gt;

    // ✅ Correct usage
    serve_public_asset(&amp;css_file)?;
    save_user_upload(&amp;user_file)?;

    // ❌ Compiler errors — wrong domain!
    // serve_public_asset(&amp;user_file)?;     // Won't compile!
    // save_user_upload(&amp;config_file)?;     // Won't compile!

    Ok(())
}

// Functions now express their requirements in the type system
fn serve_public_asset(path: &amp;StrictPath&lt;PublicAssets&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    path.read()  // Guaranteed: path is in public_assets/
}

fn save_user_upload(path: &amp;StrictPath&lt;UserUploads&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.write(b"user data")  // Guaranteed: path is in user_uploads/
}
<span class="boring">}</span></code></pre></pre>
<h2 id="what-just-happened-1"><a class="header" href="#what-just-happened-1">What Just Happened?</a></h2>
<ol>
<li><strong>Zero-cost labels:</strong> <code>struct UserUploads;</code> — empty struct, <strong>no fields</strong>, no runtime overhead</li>
<li><strong>Type-level tracking:</strong> <code>StrictPath&lt;UserUploads&gt;</code> vs <code>StrictPath&lt;PublicAssets&gt;</code> are <strong>different types</strong></li>
<li><strong>Compiler enforcement:</strong> Can't pass the wrong marker to a function — <strong>compile error</strong></li>
<li><strong>Self-documenting:</strong> Function signatures show exactly what paths they accept</li>
</ol>
<p><strong>The New Guarantee:</strong> Not only is the path safe (Stage 1), but the compiler <strong>proves it's in the correct domain</strong> (Stage 3).</p>
<h2 id="the-compiler-as-security-guard"><a class="header" href="#the-compiler-as-security-guard">The Compiler as Security Guard</a></h2>
<p>Let's see the compiler catch mistakes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct SensitiveData;
struct PublicWebsite;

fn demonstrate_compiler_enforcement() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let sensitive_dir: StrictPath&lt;SensitiveData&gt; = 
        StrictPath::with_boundary_create("sensitive")?;
    
    let public_dir: StrictPath&lt;PublicWebsite&gt; = 
        StrictPath::with_boundary_create("public")?;

    let secret_file = sensitive_dir.strict_join("passwords.txt")?;
    let css_file = public_dir.strict_join("styles.css")?;

    // ✅ This compiles — correct domain
    serve_public_file(&amp;css_file)?;

    // ❌ This fails at compile time — wrong domain!
    // serve_public_file(&amp;secret_file)?;
    //                   ^^^^^^^^^^^^ 
    // ERROR: expected `&amp;StrictPath&lt;PublicWebsite&gt;`, 
    //        found `&amp;StrictPath&lt;SensitiveData&gt;`

    Ok(())
}

fn serve_public_file(path: &amp;StrictPath&lt;PublicWebsite&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Serving public file: {}", path.strictpath_display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Before markers:</strong> Mistake ships to production → security incident.<br />
<strong>After markers:</strong> Mistake caught at compile time → fix before commit.</p>
<h2 id="try-it-yourself-1"><a class="header" href="#try-it-yourself-1">Try It Yourself</a></h2>
<p>Here's a realistic example you can run:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct Documents;
struct Photos;
struct Music;

fn organize_media() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create distinct boundaries
    let docs_dir: StrictPath&lt;Documents&gt; = StrictPath::with_boundary_create("docs")?;
    let photos_dir: StrictPath&lt;Photos&gt; = StrictPath::with_boundary_create("photos")?;
    let music_dir: StrictPath&lt;Music&gt; = StrictPath::with_boundary_create("music")?;

    // Create files in each domain
    let report = docs_dir.strict_join("quarterly_report.pdf")?;
    let vacation = photos_dir.strict_join("beach_2024.jpg")?;
    let song = music_dir.strict_join("favorite_song.mp3")?;

    // Correct domain usage
    archive_document(&amp;report)?;           // ✅ Works
    backup_photo(&amp;vacation)?;             // ✅ Works
    transcode_audio(&amp;song)?;              // ✅ Works

    // Wrong domain usage — won't compile!
    // archive_document(&amp;vacation)?;      // ❌ Compile error
    // backup_photo(&amp;song)?;              // ❌ Compile error
    // transcode_audio(&amp;report)?;         // ❌ Compile error

    Ok(())
}

fn archive_document(doc: &amp;StrictPath&lt;Documents&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Archiving document: {}", doc.strictpath_display());
    Ok(())
}

fn backup_photo(photo: &amp;StrictPath&lt;Photos&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Backing up photo: {}", photo.strictpath_display());
    Ok(())
}

fn transcode_audio(audio: &amp;StrictPath&lt;Music&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Transcoding audio: {}", audio.strictpath_display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="markers-are-zero-cost"><a class="header" href="#markers-are-zero-cost">Markers Are Zero-Cost</a></h2>
<p>Let's verify that markers have <strong>zero runtime overhead</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;
use std::mem;

struct MyMarker;

fn demonstrate_zero_cost() {
    // Size of StrictPath with and without marker
    let size_without = mem::size_of::&lt;StrictPath&lt;()&gt;&gt;();
    let size_with = mem::size_of::&lt;StrictPath&lt;MyMarker&gt;&gt;();

    println!("StrictPath&lt;()&gt;: {} bytes", size_without);
    println!("StrictPath&lt;MyMarker&gt;: {} bytes", size_with);
    
    // They're identical! The marker is compile-time only.
    assert_eq!(size_without, size_with);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>The marker is erased at compile time.</strong> It exists only in the type system. No runtime memory, no runtime checks, no performance cost.</p>
<h2 id="naming-markers-best-practices"><a class="header" href="#naming-markers-best-practices">Naming Markers: Best Practices</a></h2>
<p>Markers should describe <strong>what resource is stored under the boundary</strong>, not who accesses it:</p>
<h3 id="-good-marker-names-what-is-stored"><a class="header" href="#-good-marker-names-what-is-stored">✅ Good Marker Names (What is stored)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserUploads;        // Stores: user-uploaded files
struct ProductImages;      // Stores: product catalog images
struct SystemLogs;         // Stores: application log files
struct ConfigFiles;        // Stores: configuration files
struct TempWorkspace;      // Stores: temporary processing files
<span class="boring">}</span></code></pre></pre>
<h3 id="-bad-marker-names-who-accesses-it"><a class="header" href="#-bad-marker-names-who-accesses-it">❌ Bad Marker Names (Who accesses it)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AdminMarker;        // ❌ Describes user role, not storage
struct GuestAccess;        // ❌ Describes permission, not content
struct AuthorizedPath;     // ❌ Describes state, not resource
<span class="boring">}</span></code></pre></pre>
<p><strong>Why?</strong> Markers describe <strong>boundaries</strong> (physical storage locations), not <strong>permissions</strong> (authorization levels). We'll add permissions in Stage 4.</p>
<h2 id="real-world-example-web-server"><a class="header" href="#real-world-example-web-server">Real-World Example: Web Server</a></h2>
<p>Here's how you'd structure a real web server with markers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

// Define domains
struct StaticAssets;     // CSS, JS, images served to browsers
struct UserUploads;      // Files uploaded by users
struct TemplateFiles;    // HTML templates for rendering
struct AppLogs;          // Application logs

struct WebServer {
    static_dir: StrictPath&lt;StaticAssets&gt;,
    uploads_dir: StrictPath&lt;UserUploads&gt;,
    templates_dir: StrictPath&lt;TemplateFiles&gt;,
    logs_dir: StrictPath&lt;AppLogs&gt;,
}

impl WebServer {
    fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        Ok(Self {
            static_dir: StrictPath::with_boundary_create("public/static")?,
            uploads_dir: StrictPath::with_boundary_create("data/uploads")?,
            templates_dir: StrictPath::with_boundary_create("templates")?,
            logs_dir: StrictPath::with_boundary_create("logs")?,
        })
    }

    fn serve_static(&amp;self, filename: &amp;str) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
        let asset_path = self.static_dir.strict_join(filename)?;
        serve_to_client(&amp;asset_path)  // Type-safe: only StaticAssets
    }

    fn save_upload(&amp;self, filename: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
        let upload_path = self.uploads_dir.strict_join(filename)?;
        store_user_file(&amp;upload_path, data)  // Type-safe: only UserUploads
    }

    fn render_template(&amp;self, template: &amp;str) -&gt; std::io::Result&lt;String&gt; {
        let tmpl_path = self.templates_dir.strict_join(template)?;
        load_template(&amp;tmpl_path)  // Type-safe: only TemplateFiles
    }

    fn write_log(&amp;self, entry: &amp;str) -&gt; std::io::Result&lt;()&gt; {
        let log_path = self.logs_dir.strict_join("app.log")?;
        append_log_entry(&amp;log_path, entry)  // Type-safe: only AppLogs
    }
}

// Type-safe helper functions
fn serve_to_client(asset: &amp;StrictPath&lt;StaticAssets&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    asset.read()
}

fn store_user_file(upload: &amp;StrictPath&lt;UserUploads&gt;, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    upload.write(data)
}

fn load_template(tmpl: &amp;StrictPath&lt;TemplateFiles&gt;) -&gt; std::io::Result&lt;String&gt; {
    tmpl.read_to_string()
}

fn append_log_entry(log: &amp;StrictPath&lt;AppLogs&gt;, entry: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    let mut content = log.read_to_string().unwrap_or_default();
    content.push_str(entry);
    content.push('\n');
    log.write(content.as_bytes())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="head-first-moment-1"><a class="header" href="#head-first-moment-1">Head First Moment</a></h2>
<p>Markers are like <strong>colored wristbands at a conference</strong>:</p>
<ul>
<li>🔵 Blue wristband → Speaker (can access speaker lounge)</li>
<li>🟢 Green wristband → Attendee (can access general sessions)</li>
<li>🔴 Red wristband → Staff (can access backstage)</li>
</ul>
<p><strong>The compiler checks your wristband at every function door:</strong></p>
<ul>
<li>Function requires 🔵 blue? You need <code>StrictPath&lt;Speaker&gt;</code>.</li>
<li>Try to enter with 🟢 green? Compile error: "Sorry, speakers only."</li>
<li>Wrong color? <strong>Access denied at compile time.</strong></li>
</ul>
<p>You can't fake a wristband, and you can't sneak into the wrong area. The type system physically prevents it.</p>
<h2 id="comparison-before-and-after"><a class="header" href="#comparison-before-and-after">Comparison: Before and After</a></h2>
<h3 id="before-markers-stage-2"><a class="header" href="#before-markers-stage-2">Before Markers (Stage 2)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ All paths look the same
let user_file: StrictPath = ...;
let config_file: StrictPath = ...;
let log_file: StrictPath = ...;

// ❌ Functions can't distinguish
fn process(path: &amp;StrictPath) { ... }

// ❌ Easy to mix up — compiler can't help
process(&amp;config_file);  // Oops, wrong file!
<span class="boring">}</span></code></pre></pre>
<h3 id="after-markers-stage-3"><a class="header" href="#after-markers-stage-3">After Markers (Stage 3)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Each path has its domain encoded
let user_file: StrictPath&lt;UserUploads&gt; = ...;
let config_file: StrictPath&lt;ConfigFiles&gt; = ...;
let log_file: StrictPath&lt;AppLogs&gt; = ...;

// ✅ Functions express requirements
fn process_user_file(path: &amp;StrictPath&lt;UserUploads&gt;) { ... }

// ✅ Compiler catches mistakes
process_user_file(&amp;user_file);     // ✅ Correct
process_user_file(&amp;config_file);   // ❌ Compile error!
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways-2"><a class="header" href="#key-takeaways-2">Key Takeaways</a></h2>
<p>✅ <strong>Markers = Zero-cost compile-time labels</strong><br />
✅ <strong><code>StrictPath&lt;Marker&gt;</code> = Path + domain information</strong><br />
✅ <strong>Compiler enforces domain separation</strong> — wrong marker = compile error<br />
✅ <strong>Self-documenting code</strong> — function signatures show requirements<br />
✅ <strong>No runtime overhead</strong> — markers are erased after compilation</p>
<h2 id="the-updated-guarantee"><a class="header" href="#the-updated-guarantee">The Updated Guarantee</a></h2>
<blockquote>
<p><strong>If you have a <code>StrictPath&lt;Marker&gt;</code>, the compiler guarantees:</strong></p>
<ol>
<li>✅ The path cannot escape its boundary (Stage 1)</li>
<li>✅ The path is in the correct domain (Stage 3)</li>
</ol>
</blockquote>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What's Next?</a></h2>
<p>You now know how to prevent domain mix-ups with markers. But what about <strong>authorization</strong>? How do you encode "this user is authorized to access this path" in the type system?</p>
<p>That's where things get really powerful...</p>
<p><strong><a href="tutorial/./stage4_authorization.html">Continue to Stage 4: Authorization with change_marker() →</a></strong></p>
<hr />
<p><strong>Quick Reference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define markers
struct MyDomain;

// Create typed boundary
let boundary: StrictPath&lt;MyDomain&gt; = 
    StrictPath::with_boundary_create("path")?;

// Paths inherit marker
let file = boundary.strict_join("file.txt")?;  // StrictPath&lt;MyDomain&gt;

// Functions enforce domain
fn process(path: &amp;StrictPath&lt;MyDomain&gt;) { ... }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-4-authorization-with-change_marker--compile-time-authorization-proofs"><a class="header" href="#stage-4-authorization-with-change_marker--compile-time-authorization-proofs">Stage 4: Authorization with <code>change_marker()</code> — Compile-Time Authorization Proofs</a></h1>
<blockquote>
<p><em>"The compiler can mathematically prove that authorization happened first."</em></p>
</blockquote>
<p>In Stage 3, you learned how markers prevent domain mix-ups. Now you'll learn how to <strong>encode authorization</strong> in markers using <code>change_marker()</code>, so the compiler can mathematically prove that authorization checks weren't forgotten.</p>
<h2 id="the-authorization-problem"><a class="header" href="#the-authorization-problem">The Authorization Problem</a></h2>
<p>Markers prevent domain confusion. But what about <strong>permissions</strong>? How do we encode "this user is authorized to write to this directory"?</p>
<h3 id="traditional-approach-runtime-checks-everywhere"><a class="header" href="#traditional-approach-runtime-checks-everywhere">Traditional Approach: Runtime Checks Everywhere</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct UserFiles;

// ❌ Problem: Authorization check inside every operation
fn write_user_file(path: &amp;StrictPath&lt;UserFiles&gt;, user_id: &amp;str, data: &amp;[u8]) 
    -&gt; std::io::Result&lt;()&gt; 
{
    if !is_authorized(user_id) {  // Runtime check (can forget!)
        return Err(std::io::Error::new(
            std::io::ErrorKind::PermissionDenied, 
            "Unauthorized"
        ));
    }
    path.write(data)
}

fn delete_user_file(path: &amp;StrictPath&lt;UserFiles&gt;, user_id: &amp;str) 
    -&gt; std::io::Result&lt;()&gt; 
{
    if !is_authorized(user_id) {  // Repeated check (can forget!)
        return Err(std::io::Error::new(
            std::io::ErrorKind::PermissionDenied, 
            "Unauthorized"
        ));
    }
    path.remove_file()
}

fn read_user_file(path: &amp;StrictPath&lt;UserFiles&gt;, user_id: &amp;str) 
    -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; 
{
    // Oops! Forgot the authorization check here! 🚨
    path.read()
}

fn is_authorized(user_id: &amp;str) -&gt; bool {
    user_id == "alice"
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Problems:</strong></p>
<ul>
<li>❌ Authorization checks scattered everywhere</li>
<li>❌ Easy to forget a check (see <code>read_user_file</code>)</li>
<li>❌ No compile-time guarantee that authorization happened</li>
<li>❌ Code review has to catch missing checks (humans are fallible)</li>
</ul>
<h3 id="better-approach-encode-authorization-in-the-type"><a class="header" href="#better-approach-encode-authorization-in-the-type">Better Approach: Encode Authorization in the Type</a></h3>
<p>Instead of <strong>checking</strong> authorization repeatedly, we <strong>encode</strong> it in the type once:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

// Resource marker: describes WHAT directory
struct UserFiles;

// Permission markers: describe LEVEL of access
struct ReadOnly;
struct ReadWrite;

// Authorization gate: validates token → returns authorized marker
fn authenticate_user_access(
    token: &amp;str,
    path: StrictPath&lt;(UserFiles, ReadOnly)&gt;
) -&gt; Option&lt;StrictPath&lt;(UserFiles, ReadWrite)&gt;&gt; {
    // ✅ Authorization: Token validated (checked once here!)
    if validate_token(token) {
        // Transform marker to encode proven authorization
        Some(path.change_marker::&lt;(UserFiles, ReadWrite)&gt;())
    } else {
        None
    }
}

fn validate_token(token: &amp;str) -&gt; bool {
    token == "valid-token-12345"  // Real apps: JWT validation, database lookup, etc.
}

// Functions accept paths that already prove authorization
fn write_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;, data: &amp;[u8]) 
    -&gt; std::io::Result&lt;()&gt; 
{
    // No authorization check needed! Type proves it already happened.
    path.write(data)
}

fn delete_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;) 
    -&gt; std::io::Result&lt;()&gt; 
{
    // No authorization check needed! Type proves it already happened.
    path.remove_file()
}

fn read_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadOnly)&gt;) 
    -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; 
{
    // ReadOnly access is sufficient for reading
    path.read()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="understanding-change_marker"><a class="header" href="#understanding-change_marker">Understanding <code>change_marker()</code></a></h2>
<h3 id="what-change_marker-is-not"><a class="header" href="#what-change_marker-is-not">What <code>change_marker()</code> Is NOT</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ WRONG way to think about it:
// "change_marker() grants permissions"
// "change_marker() does authorization"
<span class="boring">}</span></code></pre></pre>
<h3 id="what-change_marker-actually-does"><a class="header" href="#what-change_marker-actually-does">What <code>change_marker()</code> Actually Does</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ RIGHT way to think about it:
// "change_marker() ENCODES proven authorization in the type"
// "change_marker() transforms the marker AFTER authorization passed"
<span class="boring">}</span></code></pre></pre>
<p><strong>The pattern:</strong></p>
<ol>
<li>✅ <strong>Check authorization</strong> (token validation, capability check, etc.)</li>
<li>✅ <strong>If authorized:</strong> call <code>change_marker()</code> to encode that fact in the type</li>
<li>✅ <strong>Pass the new type</strong> to functions that require authorization</li>
<li>✅ <strong>The compiler proves</strong> authorization happened (can't get the marker any other way!)</li>
</ol>
<h2 id="using-it-complete-example"><a class="header" href="#using-it-complete-example">Using It: Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::StrictPath;

struct UserFiles;
struct ReadOnly;
struct ReadWrite;

fn handle_request(token: &amp;str, filename: &amp;str, data: Option&lt;&amp;[u8]&gt;) 
    -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; 
{
    // Start with read-only access (no authorization yet)
    let user_files_dir: StrictPath&lt;(UserFiles, ReadOnly)&gt; = 
        StrictPath::with_boundary_create("user_files")?;
    
    let file_path = user_files_dir.strict_join(filename)?;

    // Anyone can read with ReadOnly marker
    let _content = read_user_file(&amp;file_path)?;
    println!("✅ Read succeeded (no authorization needed)");

    // Try to upgrade to ReadWrite by authenticating
    if let Some(writable_path) = authenticate_user_access(token, file_path) {
        // ✅ Token validated! Now we have ReadWrite access
        println!("✅ Authorization succeeded");
        
        if let Some(data) = data {
            write_user_file(&amp;writable_path, data)?;
            println!("✅ Write succeeded (authorization proven by type)");
        }
        
        delete_user_file(&amp;writable_path)?;
        println!("✅ Delete succeeded (authorization proven by type)");
    } else {
        println!("❌ Authorization failed — cannot write or delete");
    }

    Ok(())
}

fn authenticate_user_access(
    token: &amp;str,
    path: StrictPath&lt;(UserFiles, ReadOnly)&gt;
) -&gt; Option&lt;StrictPath&lt;(UserFiles, ReadWrite)&gt;&gt; {
    if validate_token(token) {
        Some(path.change_marker())
    } else {
        None
    }
}

fn validate_token(token: &amp;str) -&gt; bool {
    token == "valid-token-12345"
}

fn read_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadOnly)&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    path.read()
}

fn write_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    path.write(data)
}

fn delete_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.remove_file()
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Valid token — authorization succeeds
    handle_request("valid-token-12345", "notes.txt", Some(b"New content"))?;
    
    // Invalid token — authorization fails
    handle_request("invalid-token", "notes.txt", Some(b"Hack attempt"))?;
    
    Ok(())
}</code></pre></pre>
<h2 id="tuple-markers-composing-resources-and-permissions"><a class="header" href="#tuple-markers-composing-resources-and-permissions">Tuple Markers: Composing Resources and Permissions</a></h2>
<p>Notice we're using <strong>tuple markers</strong>: <code>(UserFiles, ReadOnly)</code> and <code>(UserFiles, ReadWrite)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserFiles;      // First element: WHAT resource
struct ReadOnly;       // Second element: WHAT permission level
struct ReadWrite;

// Composed together:
// StrictPath&lt;(UserFiles, ReadOnly)&gt;   = User files with read-only access
// StrictPath&lt;(UserFiles, ReadWrite)&gt;  = User files with read-write access
<span class="boring">}</span></code></pre></pre>
<p><strong>Why tuples?</strong></p>
<ul>
<li>✅ <strong>Flexible composition:</strong> Mix and match resources with permissions</li>
<li>✅ <strong>Easy to transform:</strong> <code>change_marker()</code> can swap out permission levels</li>
<li>✅ <strong>Standard Rust idiom:</strong> No need to learn special syntax</li>
</ul>
<h2 id="try-it-yourself-capability-based-authorization"><a class="header" href="#try-it-yourself-capability-based-authorization">Try It Yourself: Capability-Based Authorization</a></h2>
<p>Here's a more sophisticated example with multiple capability levels:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::StrictPath;

struct ProjectFiles;
struct CanRead;
struct CanWrite;
struct CanDelete;

// Check user role and return appropriate marker
fn grant_project_access(
    user_role: &amp;str,
    path: StrictPath&lt;ProjectFiles&gt;
) -&gt; Option&lt;StrictPath&lt;(ProjectFiles, CanRead, CanWrite, CanDelete)&gt;&gt; {
    // ✅ Authorization: Role checked
    if user_role == "admin" {
        // Admin gets full access (read + write + delete)
        Some(path.change_marker::&lt;(ProjectFiles, CanRead, CanWrite, CanDelete)&gt;())
    } else {
        None
    }
}

fn grant_editor_access(
    user_role: &amp;str,
    path: StrictPath&lt;ProjectFiles&gt;
) -&gt; Option&lt;StrictPath&lt;(ProjectFiles, CanRead, CanWrite)&gt;&gt; {
    // ✅ Authorization: Role checked
    if user_role == "editor" || user_role == "admin" {
        // Editors can read and write (but not delete)
        Some(path.change_marker::&lt;(ProjectFiles, CanRead, CanWrite)&gt;())
    } else {
        None
    }
}

fn grant_readonly_access(
    user_role: &amp;str,
    path: StrictPath&lt;ProjectFiles&gt;
) -&gt; Option&lt;StrictPath&lt;(ProjectFiles, CanRead)&gt;&gt; {
    // ✅ Authorization: Role checked
    if user_role == "viewer" || user_role == "editor" || user_role == "admin" {
        Some(path.change_marker::&lt;(ProjectFiles, CanRead)&gt;())
    } else {
        None
    }
}

// Functions require specific capabilities in their signature
fn read_project(path: &amp;StrictPath&lt;(ProjectFiles, CanRead)&gt;) -&gt; std::io::Result&lt;String&gt; {
    path.read_to_string()
}

fn update_project(path: &amp;StrictPath&lt;(ProjectFiles, CanRead, CanWrite)&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.write(b"Updated project data")
}

fn delete_project(path: &amp;StrictPath&lt;(ProjectFiles, CanRead, CanWrite, CanDelete)&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.remove_file()
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let projects_dir: StrictPath&lt;ProjectFiles&gt; = 
        StrictPath::with_boundary_create("projects")?;
    
    let project = projects_dir.strict_join("proposal.md")?;

    // Viewer can only read
    if let Some(readonly_path) = grant_readonly_access("viewer", project.clone()) {
        read_project(&amp;readonly_path)?;
        println!("✅ Viewer: read succeeded");
        // update_project(&amp;readonly_path)?;  // ❌ Won't compile: missing CanWrite
    }

    // Editor can read and write
    if let Some(editor_path) = grant_editor_access("editor", project.clone()) {
        read_project(&amp;editor_path)?;      // ✅ Has CanRead
        update_project(&amp;editor_path)?;    // ✅ Has CanRead + CanWrite
        println!("✅ Editor: read and write succeeded");
        // delete_project(&amp;editor_path)?; // ❌ Won't compile: missing CanDelete
    }

    // Admin can do everything
    if let Some(admin_path) = grant_project_access("admin", project) {
        read_project(&amp;admin_path)?;      // ✅ Has CanRead
        update_project(&amp;admin_path)?;    // ✅ Has CanRead + CanWrite
        delete_project(&amp;admin_path)?;    // ✅ Has CanRead + CanWrite + CanDelete
        println!("✅ Admin: full access succeeded");
    }

    Ok(())
}</code></pre></pre>
<h2 id="head-first-moment-passport-stamps"><a class="header" href="#head-first-moment-passport-stamps">Head First Moment: Passport Stamps</a></h2>
<p>Think of <code>change_marker()</code> like <strong>stamping a passport</strong>:</p>
<ol>
<li><strong>You apply for a visa</strong> (submit token for validation)</li>
<li><strong>Visa office checks credentials</strong> (authorization function validates token)</li>
<li><strong>If approved, they stamp your passport</strong> (call <code>change_marker()</code>)</li>
<li><strong>Guards at checkpoints check your stamp</strong> (functions check marker type)</li>
</ol>
<p>The stamp doesn't grant permission — <strong>the visa office did that</strong>. The stamp just <strong>proves</strong> permission was granted.</p>
<p><strong>Functions check your stamp (marker), not your visa application (token).</strong></p>
<p>This means:</p>
<ul>
<li>✅ Authorization happens <strong>once</strong> (at the visa office)</li>
<li>✅ Every checkpoint trusts the stamp (no re-checking)</li>
<li>✅ Can't forge a stamp (only way to get marker is through auth function)</li>
<li>✅ Compiler ensures you have the right stamp for each checkpoint</li>
</ul>
<h2 id="the-authorization-pattern-summary"><a class="header" href="#the-authorization-pattern-summary">The Authorization Pattern Summary</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1️⃣ Define resource and permission markers
struct Resource;
struct ReadOnly;
struct ReadWrite;

// 2️⃣ Create authorization gate
fn authorize(token: &amp;str, path: StrictPath&lt;(Resource, ReadOnly)&gt;) 
    -&gt; Option&lt;StrictPath&lt;(Resource, ReadWrite)&gt;&gt; 
{
    if validate(token) {                        // ✅ Check authorization
        Some(path.change_marker())              // ✅ Encode in type
    } else {
        None                                    // ❌ Authorization failed
    }
}

// 3️⃣ Functions require authorized marker
fn protected_operation(path: &amp;StrictPath&lt;(Resource, ReadWrite)&gt;) {
    // No authorization check needed!
    // Type proves authorization already happened.
}
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-web-api"><a class="header" href="#real-world-example-web-api">Real-World Example: Web API</a></h2>
<p>Here's how you'd use this in a web server:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct ApiUploads;
struct AuthToken(String);
struct ReadAccess;
struct WriteAccess;

// Authorization: Validate JWT token
fn authorize_write_access(
    token: &amp;AuthToken,
    path: StrictPath&lt;(ApiUploads, ReadAccess)&gt;
) -&gt; Result&lt;StrictPath&lt;(ApiUploads, ReadAccess, WriteAccess)&gt;, AuthError&gt; {
    // ✅ Authorization: Validate JWT token
    if verify_jwt(&amp;token.0)? {
        Ok(path.change_marker())
    } else {
        Err(AuthError::InvalidToken)
    }
}

fn verify_jwt(token: &amp;str) -&gt; Result&lt;bool, AuthError&gt; {
    // Real implementation would:
    // - Verify signature
    // - Check expiration
    // - Validate claims
    Ok(token.starts_with("Bearer "))
}

// API handlers
fn handle_read(uploads: &amp;StrictPath&lt;(ApiUploads, ReadAccess)&gt;, filename: &amp;str) 
    -&gt; Result&lt;Vec&lt;u8&gt;, ApiError&gt; 
{
    let file = uploads.strict_join(filename)?;
    Ok(file.read()?)
}

fn handle_write(
    uploads: &amp;StrictPath&lt;(ApiUploads, ReadAccess, WriteAccess)&gt;, 
    filename: &amp;str,
    data: &amp;[u8]
) -&gt; Result&lt;(), ApiError&gt; 
{
    let file = uploads.strict_join(filename)?;
    Ok(file.write(data)?)
}

#[derive(Debug)]
enum AuthError {
    InvalidToken,
}

#[derive(Debug)]
enum ApiError {
    PathError(strict_path::StrictPathError),
    IoError(std::io::Error),
}

impl From&lt;strict_path::StrictPathError&gt; for ApiError {
    fn from(e: strict_path::StrictPathError) -&gt; Self {
        ApiError::PathError(e)
    }
}

impl From&lt;std::io::Error&gt; for ApiError {
    fn from(e: std::io::Error) -&gt; Self {
        ApiError::IoError(e)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways-3"><a class="header" href="#key-takeaways-3">Key Takeaways</a></h2>
<p>✅ <strong><code>change_marker()</code> encodes proven authorization</strong> (doesn't grant it)<br />
✅ <strong>Tuple markers compose resources and permissions</strong><br />
✅ <strong>Authorization happens once</strong> — type system enforces it everywhere<br />
✅ <strong>Impossible to bypass</strong> — only way to get the marker is through auth gate<br />
✅ <strong>Compiler catches missing authorization</strong> — won't compile without proper marker</p>
<h2 id="the-complete-guarantee-so-far"><a class="header" href="#the-complete-guarantee-so-far">The Complete Guarantee So Far</a></h2>
<blockquote>
<p><strong>If a function accepts <code>StrictPath&lt;(Resource, Permission)&gt;</code>, the compiler mathematically proves that:</strong></p>
<ol>
<li>✅ The path cannot escape its boundary (Stage 1)</li>
<li>✅ The path is in the correct domain (Stage 3)</li>
<li>✅ Authorization was granted for that permission level (Stage 4)</li>
</ol>
</blockquote>
<p><strong>This is compile-time authorization.</strong> Forget a check? Won't compile. Use the wrong permission level? Won't compile. Bypass authorization? Impossible.</p>
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What's Next?</a></h2>
<p>You've mastered authorization with markers. But what about <strong>user-facing applications</strong> where you want to show clean paths like <code>/documents/file.txt</code> instead of ugly system paths?</p>
<p>That's where <code>VirtualPath</code> comes in...</p>
<p><strong><a href="tutorial/./stage5_virtual_paths.html">Continue to Stage 5: Virtual Paths →</a></strong></p>
<hr />
<p><strong>Quick Reference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define markers
struct Resource;
struct ReadOnly;
struct ReadWrite;

// Authorization gate
fn authorize(token: &amp;str, path: StrictPath&lt;(Resource, ReadOnly)&gt;) 
    -&gt; Option&lt;StrictPath&lt;(Resource, ReadWrite)&gt;&gt; 
{
    if validate(token) {
        Some(path.change_marker())  // Encode authorization
    } else {
        None
    }
}

// Protected function
fn protected(path: &amp;StrictPath&lt;(Resource, ReadWrite)&gt;) {
    // No auth check needed — type proves it!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-5-virtual-paths--user-friendly-sandboxes"><a class="header" href="#stage-5-virtual-paths--user-friendly-sandboxes">Stage 5: Virtual Paths — User-Friendly Sandboxes</a></h1>
<blockquote>
<p><em>"Give users a clean '/' view, hide the messy system paths."</em></p>
</blockquote>
<p>In Stage 4, you learned how to encode authorization in markers. Now you'll learn how <code>VirtualPath</code> extends <code>StrictPath</code> with <strong>user-friendly virtual roots</strong> — perfect for sandboxing users and showing clean paths.</p>
<h2 id="the-problem-with-strictpath-for-user-ux"><a class="header" href="#the-problem-with-strictpath-for-user-ux">The Problem with StrictPath for User UX</a></h2>
<p><code>StrictPath</code> is perfect for system operations, but it exposes real filesystem paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn show_user_files() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads_dir = StrictPath::with_boundary_create("/var/app/users/alice/uploads")?;
    let file = uploads_dir.strict_join("documents/report.pdf")?;

    // User sees ugly system path
    println!("Your file: {}", file.strictpath_display());
    // Output: /var/app/users/alice/uploads/documents/report.pdf
    
    // User thinks: "Why do I need to know about /var/app/users/alice?"
    // "I just want to see: /documents/report.pdf"

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Problems:</strong></p>
<ul>
<li>❌ Users see internal directory structure</li>
<li>❌ Paths are long and confusing</li>
<li>❌ Exposes system architecture details</li>
<li>❌ Not user-friendly for file browsers, cloud storage UI, etc.</li>
</ul>
<h2 id="the-solution-virtualpath"><a class="header" href="#the-solution-virtualpath">The Solution: VirtualPath</a></h2>
<p><code>VirtualPath</code> provides a <strong>virtual root</strong> — users see paths starting from <code>/</code>, but the system enforces the real boundary:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

fn show_user_files_virtually() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a virtual root (system boundary: /var/app/users/alice/uploads)
    let user_vroot = VirtualPath::with_root("/var/app/users/alice/uploads")?;
    
    let file = user_vroot.virtual_join("documents/report.pdf")?;

    // User sees clean virtual path
    println!("Your file: {}", file.virtualpath_display());
    // Output: /documents/report.pdf
    
    // User thinks: "Perfect! That's my file."

    // System still operates on real path
    file.write(b"File contents")?;  
    // Actually writes to: /var/app/users/alice/uploads/documents/report.pdf

    println!("System path: {}", file.as_unvirtual().strictpath_display());
    // Output: /var/app/users/alice/uploads/documents/report.pdf

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="clamping-vs-rejecting"><a class="header" href="#clamping-vs-rejecting">Clamping vs. Rejecting</a></h2>
<p>This is the <strong>key difference</strong> between <code>VirtualPath</code> and <code>StrictPath</code>:</p>
<h3 id="strictpath-rejects-escapes"><a class="header" href="#strictpath-rejects-escapes">StrictPath: Rejects Escapes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn strict_behavior() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let boundary = StrictPath::with_boundary_create("sandbox")?;

    // Normal path works
    let file1 = boundary.strict_join("data/file.txt")?;
    println!("✅ Valid: {}", file1.strictpath_display());

    // Attack attempt: FAILS with error
    let file2 = boundary.strict_join("../../../etc/passwd");
    match file2 {
        Ok(_) =&gt; println!("✅ Valid path"),
        Err(e) =&gt; println!("❌ Error: {}", e),  // PathEscapesBoundary
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="virtualpath-clamps-escapes"><a class="header" href="#virtualpath-clamps-escapes">VirtualPath: Clamps Escapes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

fn virtual_behavior() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let vroot = VirtualPath::with_root("sandbox")?;

    // Normal path works
    let file1 = vroot.virtual_join("data/file.txt")?;
    println!("Virtual: {}", file1.virtualpath_display());  // /data/file.txt

    // Attack attempt: CLAMPED safely
    let file2 = vroot.virtual_join("../../../etc/passwd")?;  // No error!
    println!("Virtual: {}", file2.virtualpath_display());    // /etc/passwd (clamped!)
    
    // But system path is still safe:
    println!("System: {}", file2.as_unvirtual().strictpath_display());
    // Output: sandbox/etc/passwd (still inside boundary!)

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key difference:</strong></p>
<ul>
<li><strong><code>StrictPath</code>:</strong> Escape attempt → <strong>Error</strong> (explicit rejection)</li>
<li><strong><code>VirtualPath</code>:</strong> Escape attempt → <strong>Clamped to boundary</strong> (graceful containment)</li>
</ul>
<h2 id="when-to-use-which"><a class="header" href="#when-to-use-which">When to Use Which</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use</th><th>Why</th></tr></thead><tbody>
<tr><td><strong>Web API validation</strong></td><td><code>StrictPath</code></td><td>Fail fast on invalid input</td></tr>
<tr><td><strong>System config files</strong></td><td><code>StrictPath</code></td><td>Reject malformed paths explicitly</td></tr>
<tr><td><strong>User file browser</strong></td><td><code>VirtualPath</code></td><td>Show clean <code>/</code> paths, clamp escapes gracefully</td></tr>
<tr><td><strong>Archive extraction</strong></td><td><code>VirtualPath</code></td><td>Hostile archive entries can't escape</td></tr>
<tr><td><strong>Cloud storage UI</strong></td><td><code>VirtualPath</code></td><td>Users see <code>/MyFiles/</code> instead of system paths</td></tr>
<tr><td><strong>LLM file operations</strong></td><td><code>StrictPath</code></td><td>LLM-generated paths validated strictly</td></tr>
</tbody></table>
</div>
<p><strong>Rule of thumb:</strong></p>
<ul>
<li><strong>System-facing?</strong> → <code>StrictPath</code> (explicit errors)</li>
<li><strong>User-facing?</strong> → <code>VirtualPath</code> (graceful clamping)</li>
</ul>
<h2 id="try-it-yourself-per-user-sandboxes"><a class="header" href="#try-it-yourself-per-user-sandboxes">Try It Yourself: Per-User Sandboxes</a></h2>
<p>Here's a realistic example of per-user isolation:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::{VirtualPath, VirtualRoot};

struct UserFiles;

fn create_user_workspace(user_id: u64) -&gt; Result&lt;VirtualRoot&lt;UserFiles&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    // Each user gets their own virtual root
    let user_dir = format!("users/user_{}", user_id);
    Ok(VirtualRoot::try_new_create(user_dir)?)
}

fn user_file_browser(user_id: u64) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let user_workspace = create_user_workspace(user_id)?;

    // User uploads files (they see clean paths)
    let doc = user_workspace.virtual_join("Documents/report.pdf")?;
    doc.create_parent_dir_all()?;
    doc.write(b"User document content")?;

    println!("User {} sees: {}", user_id, doc.virtualpath_display());
    // Output: /Documents/report.pdf

    println!("System stores at: {}", doc.as_unvirtual().strictpath_display());
    // Output: users/user_123/Documents/report.pdf

    // Even if user tries to escape, they stay in their sandbox
    let sneaky = user_workspace.virtual_join("../../../etc/passwd")?;
    println!("Attack clamped to: {}", sneaky.virtualpath_display());
    // Output: /etc/passwd (virtual)
    
    println!("Actually safe at: {}", sneaky.as_unvirtual().strictpath_display());
    // Output: users/user_123/etc/passwd (still in their sandbox!)

    Ok(())
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    user_file_browser(123)?;
    user_file_browser(456)?;
    Ok(())
}</code></pre></pre>
<h2 id="virtualpath--strictpath--virtual-view"><a class="header" href="#virtualpath--strictpath--virtual-view">VirtualPath = StrictPath + Virtual View</a></h2>
<p>Under the hood, <code>VirtualPath</code> <strong>wraps a <code>StrictPath</code></strong> and adds a virtual display layer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

fn demonstrate_duality() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let vpath = VirtualPath::with_root("data")?.virtual_join("file.txt")?;

    // Virtual view (user-facing)
    println!("Virtual: {}", vpath.virtualpath_display());
    // Output: /file.txt

    // System view (actual filesystem path)
    println!("System: {}", vpath.as_unvirtual().strictpath_display());
    // Output: data/file.txt

    // All StrictPath operations work
    vpath.write(b"Hello, virtual world!")?;
    let content = vpath.read_to_string()?;
    println!("Content: {}", content);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>The relationship:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>VirtualPath&lt;Marker&gt; = StrictPath&lt;Marker&gt; + virtual display semantics
<span class="boring">}</span></code></pre></pre>
<h2 id="symlinks-and-virtual-paths"><a class="header" href="#symlinks-and-virtual-paths">Symlinks and Virtual Paths</a></h2>
<p><strong>Important:</strong> While <code>VirtualPath</code> <strong>clamps</strong> relative path escapes (<code>../../../</code>), it still <strong>validates symlinks</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

fn symlink_behavior() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let vroot = VirtualPath::with_root("sandbox")?;

    // Relative escape: CLAMPED (no error)
    let relative_escape = vroot.virtual_join("../../../../etc/passwd")?;
    println!("✅ Clamped: {}", relative_escape.virtualpath_display());

    // Symlink escape: ERROR (same as StrictPath)
    // If "sandbox/evil_link" -&gt; "/etc/passwd" exists:
    let symlink_escape = vroot.virtual_join("evil_link");
    match symlink_escape {
        Ok(_) =&gt; println!("Path is safe"),
        Err(e) =&gt; println!("❌ Symlink escape rejected: {}", e),
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key point:</strong> <code>VirtualPath</code> is <strong>not</strong> a "just accept anything" mode. It's a "clamp relative paths, but still enforce boundary through symlink resolution" mode.</p>
<h2 id="real-world-example-cloud-file-storage"><a class="header" href="#real-world-example-cloud-file-storage">Real-World Example: Cloud File Storage</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{VirtualPath, VirtualRoot};

struct CloudStorage;

struct UserCloudStorage {
    user_id: u64,
    vroot: VirtualRoot&lt;CloudStorage&gt;,
}

impl UserCloudStorage {
    fn new(user_id: u64) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        let storage_path = format!("cloud_storage/user_{}", user_id);
        let vroot = VirtualRoot::try_new_create(storage_path)?;
        Ok(Self { user_id, vroot })
    }

    fn upload_file(&amp;self, virtual_path: &amp;str, data: &amp;[u8]) 
        -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; 
    {
        let file = self.vroot.virtual_join(virtual_path)?;
        file.create_parent_dir_all()?;
        file.write(data)?;
        
        // Return clean virtual path for UI display
        Ok(file.virtualpath_display().to_string())
    }

    fn download_file(&amp;self, virtual_path: &amp;str) 
        -&gt; Result&lt;Vec&lt;u8&gt;, Box&lt;dyn std::error::Error&gt;&gt; 
    {
        let file = self.vroot.virtual_join(virtual_path)?;
        Ok(file.read()?)
    }

    fn list_files(&amp;self, virtual_dir: &amp;str) 
        -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; 
    {
        let dir = self.vroot.virtual_join(virtual_dir)?;
        let mut files = Vec::new();
        
        for entry in dir.read_dir()? {
            let entry = entry?;
            let vpath = self.vroot.virtual_join(entry.file_name().to_string_lossy().as_ref())?;
            files.push(vpath.virtualpath_display().to_string());
        }
        
        Ok(files)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let alice_storage = UserCloudStorage::new(1001)?;

    // Upload files (user sees clean paths)
    let path1 = alice_storage.upload_file("Photos/vacation.jpg", b"photo data")?;
    let path2 = alice_storage.upload_file("Documents/report.pdf", b"document data")?;
    
    println!("Uploaded: {}", path1);  // /Photos/vacation.jpg
    println!("Uploaded: {}", path2);  // /Documents/report.pdf

    // Download files
    let data = alice_storage.download_file("/Documents/report.pdf")?;
    println!("Downloaded {} bytes", data.len());

    // User tries to escape — safely clamped
    let evil_path = alice_storage.upload_file("../../../etc/passwd", b"attack")?;
    println!("Attack clamped to: {}", evil_path);  // /etc/passwd (in user's sandbox!)

    Ok(())
}</code></pre></pre>
<h2 id="markers-work-with-virtualpath-too"><a class="header" href="#markers-work-with-virtualpath-too">Markers Work with VirtualPath Too</a></h2>
<p>Just like <code>StrictPath</code>, you can use markers with <code>VirtualPath</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{VirtualPath, VirtualRoot};

struct UserPhotos;
struct UserDocuments;

fn organize_virtual_storage(user_id: u64) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Each domain gets its own virtual root
    let photos_vroot: VirtualRoot&lt;UserPhotos&gt; = 
        VirtualRoot::try_new_create(format!("users/user_{}/photos", user_id))?;
    
    let docs_vroot: VirtualRoot&lt;UserDocuments&gt; = 
        VirtualRoot::try_new_create(format!("users/user_{}/documents", user_id))?;

    let photo = photos_vroot.virtual_join("vacation.jpg")?;  // VirtualPath&lt;UserPhotos&gt;
    let doc = docs_vroot.virtual_join("report.pdf")?;        // VirtualPath&lt;UserDocuments&gt;

    process_photo(&amp;photo)?;              // ✅ Correct type
    process_document(&amp;doc)?;             // ✅ Correct type
    // process_photo(&amp;doc)?;             // ❌ Compile error!

    Ok(())
}

fn process_photo(photo: &amp;VirtualPath&lt;UserPhotos&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Processing photo: {}", photo.virtualpath_display());
    Ok(())
}

fn process_document(doc: &amp;VirtualPath&lt;UserDocuments&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Processing document: {}", doc.virtualpath_display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="head-first-moment-storefront-facade"><a class="header" href="#head-first-moment-storefront-facade">Head First Moment: Storefront Facade</a></h2>
<p><code>VirtualPath</code> is like a <strong>storefront with a clean facade</strong>:</p>
<ul>
<li><strong>Customers see:</strong> Beautiful <code>/Products/Item</code> URLs</li>
<li><strong>Behind the scenes:</strong> Files stored at <code>/var/www/store/inventory/category-5/sku-12345/item.jpg</code></li>
</ul>
<p>The facade (virtual path) makes for better UX. The real structure (strict path) handles the actual filesystem operations.</p>
<p><strong>Best of both worlds:</strong></p>
<ul>
<li>Users see clean, understandable paths</li>
<li>System operates on real, validated paths</li>
<li>Security boundary enforced throughout</li>
</ul>
<h2 id="key-takeaways-4"><a class="header" href="#key-takeaways-4">Key Takeaways</a></h2>
<p>✅ <strong><code>VirtualPath</code> = <code>StrictPath</code> + virtual <code>/</code> view</strong><br />
✅ <strong>Clamping behavior</strong> — escapes are contained, not rejected<br />
✅ <strong>User-friendly display</strong> — show clean paths in UIs<br />
✅ <strong>Per-user sandboxes</strong> — each user gets their own virtual root<br />
✅ <strong>Markers work</strong> — domain separation applies to virtual paths too<br />
✅ <strong>Symlinks still validated</strong> — not a "trust everything" mode</p>
<h2 id="the-complete-guarantee"><a class="header" href="#the-complete-guarantee">The Complete Guarantee</a></h2>
<blockquote>
<p><strong>If you have a <code>VirtualPath&lt;Marker&gt;</code>, the compiler guarantees:</strong></p>
<ol>
<li>✅ The path cannot escape its boundary (Stage 1)</li>
<li>✅ The path is in the correct domain (Stage 3)</li>
<li>✅ Virtual display is always rooted at <code>/</code> (Stage 5)</li>
<li>✅ System operations use the validated real path (Stage 5)</li>
</ol>
</blockquote>
<h2 id="whats-next-5"><a class="header" href="#whats-next-5">What's Next?</a></h2>
<p>You now understand both <code>StrictPath</code> and <code>VirtualPath</code>. But how do you integrate with <strong>external ecosystem crates</strong> like OS directories, temp files, and app-specific paths?</p>
<p>That's where <strong>feature-gated constructors</strong> come in...</p>
<p><strong><a href="tutorial/./stage6_features.html">Continue to Stage 6: Feature Integration →</a></strong></p>
<hr />
<p><strong>Quick Reference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create virtual root
let vroot = VirtualPath::with_root("path")?;

// Validate and clamp
let vpath = vroot.virtual_join(untrusted_input)?;

// Display
println!("Virtual: {}", vpath.virtualpath_display());      // /file.txt
println!("System: {}", vpath.as_unvirtual().strictpath_display());  // path/file.txt

// I/O operations
vpath.write(data)?;
let content = vpath.read_to_string()?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-6-feature-integration--ecosystem-integration-with-safe-boundaries"><a class="header" href="#stage-6-feature-integration--ecosystem-integration-with-safe-boundaries">Stage 6: Feature Integration — Ecosystem Integration with Safe Boundaries</a></h1>
<blockquote>
<p><em>"Integrate with OS directories, temp files, and app-specific paths — safely."</em></p>
</blockquote>
<p>You've mastered the core concepts: boundaries, markers, authorization, and virtual paths. Now you'll learn how to integrate strict-path with your ecosystem using <strong>feature-gated constructors</strong> that work seamlessly with popular Rust crates.</p>
<h2 id="the-problem-external-directory-apis"><a class="header" href="#the-problem-external-directory-apis">The Problem: External Directory APIs</a></h2>
<p>Your app needs to work with standard directories:</p>
<ul>
<li><strong>User config:</strong> <code>~/.config/myapp/</code> (Linux) or <code>C:\Users\Alice\AppData\Roaming\myapp\</code> (Windows)</li>
<li><strong>Temp files:</strong> System temp directory with automatic cleanup</li>
<li><strong>Downloads:</strong> User's Downloads folder</li>
<li><strong>App directories:</strong> Portable app-specific paths</li>
</ul>
<p>But you still need <strong>boundary enforcement</strong>! Otherwise, untrusted input can escape these directories too.</p>
<h2 id="the-solution-feature-gated-constructors"><a class="header" href="#the-solution-feature-gated-constructors">The Solution: Feature-Gated Constructors</a></h2>
<p>Enable features in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
strict-path = { version = "0.1.0-beta.1", features = ["dirs", "tempfile", "app-path", "serde"] }
</code></pre>
<p>Now you get special constructors that combine external crate APIs with strict-path's boundary enforcement.</p>
<h2 id="feature-dirs--os-standard-directories"><a class="header" href="#feature-dirs--os-standard-directories">Feature: <code>dirs</code> — OS Standard Directories</a></h2>
<p>The <code>dirs</code> feature adds constructors for platform-specific user directories:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

struct AppConfig;
struct UserDownloads;
struct UserDocuments;

fn use_os_directories() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Get user's config directory (platform-specific)
    let config_dir: PathBoundary&lt;AppConfig&gt; = PathBoundary::try_new_os_config("myapp")?;
    // Linux: ~/.config/myapp/
    // Windows: C:\Users\Alice\AppData\Roaming\myapp\
    // macOS: ~/Library/Application Support/myapp/

    let config_file = config_dir.strict_join("settings.toml")?;
    config_file.write(b"theme = dark\nlanguage = en")?;
    println!("Config: {}", config_file.strictpath_display());

    // Get user's downloads directory
    let downloads_dir: PathBoundary&lt;UserDownloads&gt; = PathBoundary::try_new_os_downloads()?;
    let export_file = downloads_dir.strict_join("export.csv")?;
    export_file.write(b"col1,col2\nval1,val2")?;
    println!("Export: {}", export_file.strictpath_display());

    // Get user's documents directory
    let docs_dir: PathBoundary&lt;UserDocuments&gt; = PathBoundary::try_new_os_documents()?;
    let report = docs_dir.strict_join("report.pdf")?;
    report.write(b"PDF content")?;
    println!("Report: {}", report.strictpath_display());

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="available-os-directory-constructors"><a class="header" href="#available-os-directory-constructors">Available OS Directory Constructors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Constructor</th><th>Linux</th><th>Windows</th><th>macOS</th></tr></thead><tbody>
<tr><td><code>try_new_os_config("app")</code></td><td><code>~/.config/app/</code></td><td><code>C:\Users\...\AppData\Roaming\app\</code></td><td><code>~/Library/Application Support/app/</code></td></tr>
<tr><td><code>try_new_os_data("app")</code></td><td><code>~/.local/share/app/</code></td><td><code>C:\Users\...\AppData\Roaming\app\</code></td><td><code>~/Library/Application Support/app/</code></td></tr>
<tr><td><code>try_new_os_cache("app")</code></td><td><code>~/.cache/app/</code></td><td><code>C:\Users\...\AppData\Local\app\</code></td><td><code>~/Library/Caches/app/</code></td></tr>
<tr><td><code>try_new_os_downloads()</code></td><td><code>~/Downloads/</code></td><td><code>C:\Users\...\Downloads\</code></td><td><code>~/Downloads/</code></td></tr>
<tr><td><code>try_new_os_documents()</code></td><td><code>~/Documents/</code></td><td><code>C:\Users\...\Documents\</code></td><td><code>~/Documents/</code></td></tr>
<tr><td><code>try_new_os_pictures()</code></td><td><code>~/Pictures/</code></td><td><code>C:\Users\...\Pictures\</code></td><td><code>~/Pictures/</code></td></tr>
<tr><td><code>try_new_os_videos()</code></td><td><code>~/Videos/</code></td><td><code>C:\Users\...\Videos\</code></td><td><code>~/Videos/</code></td></tr>
<tr><td><code>try_new_os_music()</code></td><td><code>~/Music/</code></td><td><code>C:\Users\...\Music\</code></td><td><code>~/Music/</code></td></tr>
</tbody></table>
</div>
<p>See the <a href="tutorial/../os_directories.html">OS Directories chapter</a> for the complete list and details.</p>
<h3 id="try-it-cross-platform-config-manager"><a class="header" href="#try-it-cross-platform-config-manager">Try It: Cross-Platform Config Manager</a></h3>
<pre><pre class="playground"><code class="language-rust">use strict_path::PathBoundary;

struct AppSettings;

fn save_user_settings(theme: &amp;str, language: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Works on Linux, Windows, and macOS automatically!
    let config_dir: PathBoundary&lt;AppSettings&gt; = 
        PathBoundary::try_new_os_config("myapp")?;

    let settings_file = config_dir.strict_join("settings.toml")?;
    let content = format!("theme = {}\nlanguage = {}\n", theme, language);
    settings_file.write(content.as_bytes())?;

    println!("Settings saved to: {}", settings_file.strictpath_display());
    Ok(())
}

fn load_user_settings() -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    let config_dir: PathBoundary&lt;AppSettings&gt; = 
        PathBoundary::try_new_os_config("myapp")?;

    let settings_file = config_dir.strict_join("settings.toml")?;
    Ok(settings_file.read_to_string()?)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    save_user_settings("dark", "en")?;
    let settings = load_user_settings()?;
    println!("Loaded settings:\n{}", settings);
    Ok(())
}</code></pre></pre>
<h2 id="feature-tempfile--automatic-cleanup-with-raii"><a class="header" href="#feature-tempfile--automatic-cleanup-with-raii">Feature: <code>tempfile</code> — Automatic Cleanup with RAII</a></h2>
<p>The <code>tempfile</code> feature works with the <code>tempfile</code> crate for automatic cleanup:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::PathBoundary;
use tempfile::TempDir;

struct WorkDir;

fn process_with_temp() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create temporary directory (cleaned up automatically when dropped)
    let temp = TempDir::new()?;
    
    println!("Created temp directory: {:?}", temp.path());

    // Wrap in PathBoundary for safe operations
    let work_dir: PathBoundary&lt;WorkDir&gt; = PathBoundary::try_new(temp.path())?;

    // Do work inside temp directory — all paths validated!
    let intermediate = work_dir.strict_join("intermediate.json")?;
    intermediate.write(b"{\"status\": \"processing\"}")?;

    let output = work_dir.strict_join("output.txt")?;
    output.write(b"Final result")?;

    // Try to escape — fails!
    match work_dir.strict_join("../../../etc/passwd") {
        Ok(_) =&gt; println!("❌ Escape succeeded (should not happen!)"),
        Err(e) =&gt; println!("✅ Escape blocked: {}", e),
    }

    println!("Work directory: {}", work_dir.strictpath_display());
    println!("Output file: {}", output.strictpath_display());

    // When this function returns, `temp` is dropped → directory deleted automatically
    Ok(())
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    process_with_temp()?;
    println!("Temp directory has been automatically cleaned up!");
    Ok(())
}</code></pre></pre>
<p><strong>Key benefits:</strong></p>
<ul>
<li>✅ <strong>RAII cleanup</strong> — temp directory deleted when <code>TempDir</code> drops</li>
<li>✅ <strong>Boundary enforcement</strong> — even in temp directories, paths can't escape</li>
<li>✅ <strong>No manual cleanup</strong> — Rust handles it for you</li>
</ul>
<h3 id="try-it-safe-archive-processing"><a class="header" href="#try-it-safe-archive-processing">Try It: Safe Archive Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;
use tempfile::TempDir;

struct ArchiveExtract;

fn extract_and_process_archive(archive_data: &amp;[u8]) 
    -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; 
{
    // Create temp directory for extraction
    let temp = TempDir::new()?;
    let extract_dir: PathBoundary&lt;ArchiveExtract&gt; = 
        PathBoundary::try_new(temp.path())?;

    // Simulate extracting files (in reality, use zip crate)
    let file1 = extract_dir.strict_join("readme.txt")?;
    file1.write(b"Archive contents...")?;

    let file2 = extract_dir.strict_join("data/values.csv")?;
    file2.create_parent_dir_all()?;
    file2.write(b"col1,col2\n1,2")?;

    // Even if archive contains hostile paths, they're validated
    match extract_dir.strict_join("../../../evil.sh") {
        Ok(_) =&gt; println!("❌ Hostile path accepted!"),
        Err(e) =&gt; println!("✅ Hostile path blocked: {}", e),
    }

    // Collect extracted files
    let mut files = Vec::new();
    files.push(file1.strictpath_display().to_string());
    files.push(file2.strictpath_display().to_string());

    // Temp directory deleted automatically when function returns
    Ok(files)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="feature-app-path--portable-application-directories"><a class="header" href="#feature-app-path--portable-application-directories">Feature: <code>app-path</code> — Portable Application Directories</a></h2>
<p>The <code>app-path</code> feature provides portable app-specific paths with environment variable overrides:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

struct AppLogs;
struct AppData;

fn setup_app_directories() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Get app-specific log directory with environment override support
    // If MYAPP_LOGS_DIR is set, uses that path
    // Otherwise, uses platform-specific app directory + "logs" subdirectory
    let logs_dir: PathBoundary&lt;AppLogs&gt; = 
        PathBoundary::try_new_app_path("logs", Some("MYAPP_LOGS_DIR"))?;
    
    let error_log = logs_dir.strict_join("errors.log")?;
    error_log.write(b"[ERROR] Example error message\n")?;

    let access_log = logs_dir.strict_join("access.log")?;
    access_log.write(b"[INFO] User accessed /api/data\n")?;

    println!("Logs directory: {}", logs_dir.strictpath_display());

    // Get app-specific data directory with environment override support
    let data_dir: PathBoundary&lt;AppData&gt; = 
        PathBoundary::try_new_app_path("data", Some("MYAPP_DATA_DIR"))?;

    let database = data_dir.strict_join("app.db")?;
    database.write(b"SQLite database content")?;

    println!("Data directory: {}", data_dir.strictpath_display());

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="environment-variable-overrides"><a class="header" href="#environment-variable-overrides">Environment Variable Overrides</a></h3>
<p>You can override the default locations using environment variables:</p>
<pre><code class="language-bash"># Override logs directory
export MYAPP_LOGS_DIR=/custom/log/path

# Override data directory
export MYAPP_DATA_DIR=/custom/data/path
</code></pre>
<p><strong>When the environment variable is set, the path is resolved to the final directory — no subdirectory append happens.</strong></p>
<p>This is useful for:</p>
<ul>
<li>✅ Testing with custom paths</li>
<li>✅ Deployment-specific configurations</li>
<li>✅ Docker container mounts</li>
<li>✅ CI/CD pipelines</li>
</ul>
<h2 id="feature-serde--safe-deserialization-with-validation"><a class="header" href="#feature-serde--safe-deserialization-with-validation">Feature: <code>serde</code> — Safe Deserialization with Validation</a></h2>
<p>The <code>serde</code> feature adds safe serialization/deserialization with automatic validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, serde_ext::WithBoundary};
use serde::{Deserialize, Serialize};

struct ConfigFiles;
struct DataFiles;

#[derive(Deserialize, Serialize)]
struct AppConfig {
    app_name: String,
    
    // Deserialize with validation through boundary
    #[serde(deserialize_with = "deserialize_log_file")]
    log_file: StrictPath&lt;ConfigFiles&gt;,
    
    #[serde(deserialize_with = "deserialize_data_file")]
    data_file: StrictPath&lt;DataFiles&gt;,
}

fn deserialize_log_file&lt;'de, D&gt;(deserializer: D) 
    -&gt; Result&lt;StrictPath&lt;ConfigFiles&gt;, D::Error&gt;
where
    D: serde::Deserializer&lt;'de&gt;,
{
    let config_dir: PathBoundary&lt;ConfigFiles&gt; = 
        PathBoundary::try_new("config").map_err(serde::de::Error::custom)?;
    
    // Use WithBoundary seed to validate during deserialization
    let seed = WithBoundary(&amp;config_dir);
    seed.deserialize(deserializer)
}

fn deserialize_data_file&lt;'de, D&gt;(deserializer: D) 
    -&gt; Result&lt;StrictPath&lt;DataFiles&gt;, D::Error&gt;
where
    D: serde::Deserializer&lt;'de&gt;,
{
    let data_dir: PathBoundary&lt;DataFiles&gt; = 
        PathBoundary::try_new("data").map_err(serde::de::Error::custom)?;
    
    let seed = WithBoundary(&amp;data_dir);
    seed.deserialize(deserializer)
}

fn load_config() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let json = r#"{
        "app_name": "MyApp",
        "log_file": "logs/app.log",
        "data_file": "db/app.db"
    }"#;

    let config: AppConfig = serde_json::from_str(json)?;
    
    println!("App: {}", config.app_name);
    println!("Log file: {}", config.log_file.strictpath_display());
    println!("Data file: {}", config.data_file.strictpath_display());

    // Try loading config with hostile paths
    let evil_json = r#"{
        "app_name": "EvilApp",
        "log_file": "../../../etc/passwd",
        "data_file": "db/app.db"
    }"#;

    match serde_json::from_str::&lt;AppConfig&gt;(evil_json) {
        Ok(_) =&gt; println!("❌ Hostile config accepted!"),
        Err(e) =&gt; println!("✅ Hostile config rejected: {}", e),
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key point:</strong> Deserialization validates paths through boundaries — <strong>untrusted config files can't escape!</strong></p>
<h2 id="combining-features-real-world-application"><a class="header" href="#combining-features-real-world-application">Combining Features: Real-World Application</a></h2>
<p>Here's how you'd combine multiple features in a real application:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, VirtualRoot};
use tempfile::TempDir;

struct AppConfig;
struct AppLogs;
struct UserFiles;
struct TempProcessing;

struct Application {
    config_dir: PathBoundary&lt;AppConfig&gt;,
    logs_dir: PathBoundary&lt;AppLogs&gt;,
    user_files_root: VirtualRoot&lt;UserFiles&gt;,
}

impl Application {
    fn new(user_id: u64) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // OS-specific config directory
        let config_dir = PathBoundary::try_new_os_config("myapp")?;
        
        // App-specific log directory (with env override support)
        let logs_dir = PathBoundary::try_new_app_path("logs", None)?;
        
        // Per-user virtual root for file isolation
        let user_storage = format!("users/user_{}", user_id);
        let user_files_root = VirtualRoot::try_new_create(user_storage)?;

        Ok(Self {
            config_dir,
            logs_dir,
            user_files_root,
        })
    }

    fn load_config(&amp;self, config_name: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let config_file = self.config_dir.strict_join(config_name)?;
        Ok(config_file.read_to_string()?)
    }

    fn log_event(&amp;self, message: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        let log_file = self.logs_dir.strict_join("app.log")?;
        let mut log = log_file.read_to_string().unwrap_or_default();
        log.push_str(message);
        log.push('\n');
        log_file.write(log.as_bytes())?;
        Ok(())
    }

    fn process_user_file(&amp;self, filename: &amp;str) 
        -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; 
    {
        // Use temp directory for processing
        let temp = TempDir::new()?;
        let temp_dir: PathBoundary&lt;TempProcessing&gt; = 
            PathBoundary::try_new(temp.path())?;

        // Get user file (virtual path)
        let user_file = self.user_files_root.virtual_join(filename)?;
        let data = user_file.read()?;

        // Process in temp directory
        let temp_file = temp_dir.strict_join("processing.tmp")?;
        temp_file.write(&amp;data)?;

        // Log the operation
        self.log_event(&amp;format!("Processed file: {}", filename))?;

        // Return result
        Ok(format!("Processed {} bytes", data.len()))
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new(123)?;
    
    // Load config from OS-specific directory
    let config = app.load_config("settings.toml").unwrap_or_default();
    println!("Config: {}", config);

    // Process user file using temp directory
    let result = app.process_user_file("documents/report.pdf")?;
    println!("Result: {}", result);

    Ok(())
}</code></pre></pre>
<h2 id="key-takeaways-5"><a class="header" href="#key-takeaways-5">Key Takeaways</a></h2>
<p>✅ <strong><code>dirs</code> feature</strong> — OS-specific user directories (config, downloads, documents, etc.)<br />
✅ <strong><code>tempfile</code> feature</strong> — RAII temp directories with boundary enforcement<br />
✅ <strong><code>app-path</code> feature</strong> — Portable app paths with env override support<br />
✅ <strong><code>serde</code> feature</strong> — Safe deserialization with automatic validation<br />
✅ <strong>Combine features</strong> — Build real-world apps with ecosystem integration<br />
✅ <strong>Boundaries everywhere</strong> — Even external directories enforce security</p>
<h2 id="the-final-complete-guarantee"><a class="header" href="#the-final-complete-guarantee">The Final Complete Guarantee</a></h2>
<blockquote>
<p><strong>By combining all stages, you achieve:</strong></p>
<ol>
<li>✅ Paths cannot escape boundaries (Stage 1)</li>
<li>✅ Paths are in the correct domain (Stage 3)</li>
<li>✅ Authorization proven by compiler (Stage 4)</li>
<li>✅ Clean virtual UX for users (Stage 5)</li>
<li>✅ Ecosystem integration with safety (Stage 6)</li>
</ol>
<p><strong>All enforced at compile time with zero runtime overhead.</strong></p>
</blockquote>
<h2 id="congratulations-"><a class="header" href="#congratulations-">Congratulations! 🎉</a></h2>
<p>You've completed the full tutorial! You now understand:</p>
<ul>
<li>✅ How <code>StrictPath</code> prevents path escapes</li>
<li>✅ How markers prevent domain mix-ups</li>
<li>✅ How <code>change_marker()</code> encodes authorization</li>
<li>✅ How <code>VirtualPath</code> provides user-friendly sandboxing</li>
<li>✅ How features integrate with the Rust ecosystem</li>
</ul>
<h2 id="whats-next-6"><a class="header" href="#whats-next-6">What's Next?</a></h2>
<p>Explore these resources to deepen your knowledge:</p>
<ul>
<li><strong><a href="tutorial/../examples.html">Real-World Examples</a></strong> — Copy-pasteable patterns for web servers, CLI tools, archives</li>
<li><strong><a href="tutorial/../authorization_security.html">Authorization Security</a></strong> — Deep dive into RBAC, JWT, and capability-based auth</li>
<li><strong><a href="tutorial/../best_practices.html">Best Practices</a></strong> — Decision matrices, design patterns, and guidelines</li>
<li><strong><a href="tutorial/../anti_patterns.html">Anti-Patterns</a></strong> — Common mistakes and how to fix them</li>
<li><strong><a href="tutorial/../os_directories.html">OS Directories</a></strong> — Complete list of OS directory constructors</li>
<li><strong><a href="tutorial/../features.html">Features</a></strong> — Full feature documentation</li>
</ul>
<p><strong>You're ready to build secure systems!</strong> 🚀</p>
<hr />
<p><strong>Quick Reference Card:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// OS directories
let config = PathBoundary::&lt;MyConfig&gt;::try_new_os_config("app")?;
let downloads = PathBoundary::&lt;Downloads&gt;::try_new_os_downloads()?;

// Temp directories
let temp = TempDir::new()?;
let work = PathBoundary::&lt;Work&gt;::try_new(temp.path())?;

// App paths (with env override)
let logs = PathBoundary::&lt;Logs&gt;::try_new_app_path("logs", None)?;

// Serde validation
#[serde(deserialize_with = "deserialize_with_boundary")]
log_file: StrictPath&lt;ConfigFiles&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong><a href="tutorial/./overview.html">← Back to Tutorial Overview</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system-guarantees-in-signatures"><a class="header" href="#type-system-guarantees-in-signatures">Type-System Guarantees in Signatures</a></h1>
<p>One of strict-path's most powerful features is its <strong>marker type system</strong> that lets you encode domain-specific path guarantees in function signatures. This makes incorrect path usage a compile-time error rather than a runtime vulnerability.</p>
<h2 id="what-are-markers"><a class="header" href="#what-are-markers">What Are Markers?</a></h2>
<p>A marker is a zero-cost type parameter that describes what a path contains or how it should be used. Markers have no runtime representation - they exist purely to help the type system prevent mistakes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Define markers for different content domains
struct PublicAssets;   // CSS, JS, images for website
struct UserUploads;    // Documents uploaded by users  
struct TempFiles;      // Temporary processing files
struct ConfigFiles;    // Application configuration

// Use markers to create domain-specific boundaries
let public_assets_dir: PathBoundary&lt;PublicAssets&gt; = PathBoundary::try_new("static")?;
let user_uploads_dir: PathBoundary&lt;UserUploads&gt; = PathBoundary::try_new("uploads")?;
let temp_files_dir: PathBoundary&lt;TempFiles&gt; = PathBoundary::try_new("temp")?;
let app_config_dir: PathBoundary&lt;ConfigFiles&gt; = PathBoundary::try_new("config")?;

// Join paths with their appropriate markers
let css_file: StrictPath&lt;PublicAssets&gt; = public_assets_dir.strict_join("style.css")?;
let user_doc: StrictPath&lt;UserUploads&gt; = user_uploads_dir.strict_join("report.pdf")?;
let temp_file: StrictPath&lt;TempFiles&gt; = temp_files_dir.strict_join("processing.tmp")?;
let app_config: StrictPath&lt;ConfigFiles&gt; = app_config_dir.strict_join("settings.json")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="why-markers-matter"><a class="header" href="#why-markers-matter">Why Markers Matter</a></h2>
<p>Without markers, it's easy to accidentally mix up different types of paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Without markers - dangerous mix-ups are possible
fn process_user_upload(file_path: &amp;StrictPath) -&gt; io::Result&lt;()&gt; {
    // Is this a user file? Config file? Temp file? 
    // No way to know from the type!
    file_path.read_to_string()
}

// With markers - impossible to mix up domains  
fn process_user_upload(user_file: &amp;StrictPath&lt;UserUploads&gt;) -&gt; io::Result&lt;String&gt; {
    // Clear: this function ONLY processes user uploads
    user_file.read_to_string() 
}

fn load_app_config(config_file: &amp;StrictPath&lt;ConfigFiles&gt;) -&gt; io::Result&lt;AppConfig&gt; {
    // Clear: this function ONLY loads config files
    let content = config_file.read_to_string()?;
    serde_json::from_str(&amp;content)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="compile-time-safety"><a class="header" href="#compile-time-safety">Compile-Time Safety</a></h2>
<p>With markers, the compiler prevents domain mix-ups:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user_doc: StrictPath&lt;UserUploads&gt; = user_uploads_dir.strict_join("report.pdf")?;
let app_config: StrictPath&lt;ConfigFiles&gt; = app_config_dir.strict_join("settings.json")?;

// ✅ These work - correct marker types
process_user_upload(&amp;user_doc)?;
load_app_config(&amp;app_config)?;

// ❌ These are compile errors - marker type mismatch!
// process_user_upload(&amp;app_config)?;  // Can't pass ConfigFiles to UserUploads function
// load_app_config(&amp;user_doc)?;        // Can't pass UserUploads to ConfigFiles function
<span class="boring">}</span></code></pre></pre>
<p><strong>The power</strong>: If your code compiles, you know you're not accidentally processing config files as user uploads, or serving user uploads as public assets!</p>
<h2 id="function-signature-patterns"><a class="header" href="#function-signature-patterns">Function Signature Patterns</a></h2>
<h3 id="pattern-1-accept-validated-paths"><a class="header" href="#pattern-1-accept-validated-paths">Pattern 1: Accept Validated Paths</a></h3>
<p>When the caller has already validated the path, accept the typed path directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serve_public_asset(asset: &amp;StrictPath&lt;PublicAssets&gt;) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    // Caller proved this is a public asset - we can serve it safely
    asset.read()
}

fn delete_user_file(user_file: &amp;StrictPath&lt;UserUploads&gt;) -&gt; io::Result&lt;()&gt; {
    // Caller proved this is a user upload - safe to delete
    user_file.remove_file()
}

fn backup_config(config_file: &amp;StrictPath&lt;ConfigFiles&gt;, backup_dir: &amp;StrictPath&lt;BackupStorage&gt;) -&gt; io::Result&lt;()&gt; {
    let content = config_file.read()?;
    let backup_name = format!("config-{}.json", chrono::Utc::now().format("%Y%m%d"));
    let backup_path = backup_dir.strict_join(&amp;backup_name)?;
    backup_path.write(content)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-validate-inside-helper"><a class="header" href="#pattern-2-validate-inside-helper">Pattern 2: Validate Inside Helper</a></h3>
<p>When the helper needs to validate user input, accept the boundary plus untrusted segment:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_user_upload(
    uploads_dir: &amp;PathBoundary&lt;UserUploads&gt;, 
    filename: &amp;str,  // untrusted input
    content: &amp;[u8]
) -&gt; io::Result&lt;()&gt; {
    // Validate the untrusted filename
    let user_file = uploads_dir.strict_join(filename)?;
    user_file.create_parent_dir_all()?;
    user_file.write(content)
}

fn load_config_by_name(
    config_dir: &amp;PathBoundary&lt;ConfigFiles&gt;, 
    config_name: &amp;str  // untrusted input
) -&gt; io::Result&lt;serde_json::Value&gt; {
    // Validate the untrusted config name
    let config_file = config_dir.strict_join(config_name)?; 
    let content = config_file.read_to_string()?;
    serde_json::from_str(&amp;content).map_err(Into::into)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-multiple-domain-access"><a class="header" href="#pattern-3-multiple-domain-access">Pattern 3: Multiple Domain Access</a></h3>
<p>Some functions need to work with multiple domains - use multiple parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_report(
    user_data: &amp;StrictPath&lt;UserUploads&gt;,
    template: &amp;StrictPath&lt;PublicAssets&gt;, 
    temp_reports_dir: &amp;PathBoundary&lt;TempFiles&gt;
) -&gt; io::Result&lt;StrictPath&lt;TempFiles&gt;&gt; {
    let data = user_data.read_to_string()?;
    let template_content = template.read_to_string()?;
    
    // Process data with template...
    let report = process_template(&amp;template_content, &amp;data);
    
    let report_file = temp_reports_dir.strict_join("report.html")?;
    report_file.write(report)?;
    Ok(report_file)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="marker-best-practices"><a class="header" href="#marker-best-practices">Marker Best Practices</a></h2>
<h3 id="use-descriptive-domain-names"><a class="header" href="#use-descriptive-domain-names">Use Descriptive Domain Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good - describes what the paths contain
struct UserHomes;
struct ProductImages; 
struct DatabaseBackups;
struct AuditLogs;

// ❌ Avoid - generic or implementation-focused names
struct Files;
struct Directory;
struct Database;
struct Secure;
<span class="boring">}</span></code></pre></pre>
<h3 id="create-markers-for-business-domains"><a class="header" href="#create-markers-for-business-domains">Create Markers for Business Domains</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good - matches your application's business logic
struct CustomerDocuments;
struct FinancialReports;
struct ProductCatalog; 
struct EmployeeRecords;
struct MarketingAssets;

// ❌ Avoid - technical implementation details as primary markers
struct JsonFiles;
struct ReadOnlyData;
struct EncryptedStorage;
<span class="boring">}</span></code></pre></pre>
<h3 id="use-meaningful-function-names"><a class="header" href="#use-meaningful-function-names">Use Meaningful Function Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good - function names explain business intent
fn archive_customer_document(doc: &amp;StrictPath&lt;CustomerDocuments&gt;) -&gt; io::Result&lt;()&gt; { ... }
fn publish_marketing_asset(asset: &amp;StrictPath&lt;MarketingAssets&gt;) -&gt; io::Result&lt;()&gt; { ... }
fn audit_financial_report(report: &amp;StrictPath&lt;FinancialReports&gt;) -&gt; io::Result&lt;()&gt; { ... }

// ❌ Avoid - generic names that don't explain purpose  
fn process_file(path: &amp;StrictPath&lt;SomeMarker&gt;) -&gt; io::Result&lt;()&gt; { ... }
fn handle_data(path: &amp;StrictPath&lt;SomeMarker&gt;) -&gt; io::Result&lt;()&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-marker-patterns"><a class="header" href="#advanced-marker-patterns">Advanced Marker Patterns</a></h2>
<h3 id="hierarchical-markers"><a class="header" href="#hierarchical-markers">Hierarchical Markers</a></h3>
<p>You can create marker hierarchies for more sophisticated type safety:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MediaFiles;
struct Images;
struct Videos;
struct Documents;

// Use PhantomData for hierarchical relationships
struct MediaFile&lt;T&gt;(std::marker::PhantomData&lt;T&gt;);

type ImageFile = MediaFile&lt;Images&gt;;
type VideoFile = MediaFile&lt;Videos&gt;;
type DocumentFile = MediaFile&lt;Documents&gt;;

fn process_image(img: &amp;StrictPath&lt;ImageFile&gt;) -&gt; io::Result&lt;()&gt; { ... }
fn process_video(vid: &amp;StrictPath&lt;VideoFile&gt;) -&gt; io::Result&lt;()&gt; { ... }
fn process_document(doc: &amp;StrictPath&lt;DocumentFile&gt;) -&gt; io::Result&lt;()&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<h3 id="environment-specific-markers"><a class="header" href="#environment-specific-markers">Environment-Specific Markers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Production;
struct Staging;  
struct Development;

struct ConfigFile&lt;Env&gt;(std::marker::PhantomData&lt;Env&gt;);

type ProdConfig = ConfigFile&lt;Production&gt;;
type StagingConfig = ConfigFile&lt;Staging&gt;;
type DevConfig = ConfigFile&lt;Development&gt;;

fn deploy_to_production(config: &amp;StrictPath&lt;ProdConfig&gt;) -&gt; io::Result&lt;()&gt; {
    // Only production configs can be deployed to production
    apply_production_config(config)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-serde"><a class="header" href="#integration-with-serde">Integration with Serde</a></h2>
<p>When deserializing paths from configuration, you still need runtime validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Deserialize;

#[derive(Deserialize)]
struct AppConfig {
    upload_directory: String,  // Raw path from config
    static_directory: String,  // Raw path from config
}

fn load_app_config() -&gt; Result&lt;(PathBoundary&lt;UserUploads&gt;, PathBoundary&lt;PublicAssets&gt;), ConfigError&gt; {
    let config: AppConfig = serde_json::from_str(&amp;config_json)?;
    
    // Validate raw config paths into typed boundaries
    let user_uploads_dir = PathBoundary::&lt;UserUploads&gt;::try_new_create(&amp;config.upload_directory)?;
    let public_assets_dir = PathBoundary::&lt;PublicAssets&gt;::try_new_create(&amp;config.static_directory)?;
    
    Ok((user_uploads_dir, public_assets_dir))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="zero-runtime-cost"><a class="header" href="#zero-runtime-cost">Zero Runtime Cost</a></h2>
<p>It's important to understand that markers are zero-cost abstractions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These have identical runtime performance
let generic_path: StrictPath = some_root.strict_join("file.txt")?;
let typed_path: StrictPath&lt;UserUploads&gt; = user_uploads_dir.strict_join("file.txt")?;

// The marker information is erased at compile time
assert_eq!(
    std::mem::size_of::&lt;StrictPath&gt;(), 
    std::mem::size_of::&lt;StrictPath&lt;UserUploads&gt;&gt;()
);
<span class="boring">}</span></code></pre></pre>
<p>All the type safety benefits come at compile time with no runtime overhead!</p>
<h2 id="common-patterns-summary"><a class="header" href="#common-patterns-summary">Common Patterns Summary</a></h2>
<ol>
<li><strong>Validate once, use everywhere</strong>: Create typed paths at boundaries, pass typed paths to functions</li>
<li><strong>Encode intent in signatures</strong>: Function parameters should clearly show what domains they work with</li>
<li><strong>Separate validation from business logic</strong>: Keep path validation separate from file processing</li>
<li><strong>Use meaningful marker names</strong>: Markers should describe business domains, not technical implementation</li>
<li><strong>Fail at compile time</strong>: Structure your code so domain mix-ups become type errors</li>
</ol>
<p>The type system becomes your ally in preventing path-related security bugs and logic errors!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-we-achieve-security"><a class="header" href="#how-we-achieve-security">How We Achieve Security</a></h1>
<p>This chapter provides a detailed look at the multi-layered security methodology behind <code>strict-path</code>. Rather than relying on simple string validation or ad-hoc checks, we've built a comprehensive defense-in-depth approach that addresses path security from the ground up.</p>
<h2 id="1-battle-tested-foundation-soft-canonicalize"><a class="header" href="#1-battle-tested-foundation-soft-canonicalize">1. Battle-Tested Foundation: <code>soft-canonicalize</code></a></h2>
<p>Our security starts with <code>soft-canonicalize</code>—a purpose-built path resolution library that has been validated against 19+ globally known path-related CVEs. These CVEs represent years of accumulated attack patterns and edge cases discovered across the software ecosystem.</p>
<p><strong>What it handles:</strong></p>
<ul>
<li><strong>Symlink cycles and complex link chains</strong>: Prevents infinite loops and traversal through symbolic links</li>
<li><strong>Path resolution consistency</strong>: Ensures paths are resolved consistently during validation, reducing some timing-related inconsistencies in path interpretation</li>
<li><strong>Platform-specific quirks</strong>: Windows 8.3 short names (<code>PROGRA~1</code>), UNC paths, NTFS Alternate Data Streams</li>
<li><strong>Encoding tricks</strong>: Unicode normalization attacks, case sensitivity issues, and filesystem encoding edge cases</li>
<li><strong>Canonicalization edge cases</strong>: Proper handling of <code>.</code>, <code>..</code>, multiple slashes, and malformed path components</li>
</ul>
<p><strong>Why this matters:</strong> Most directory traversal vulnerabilities stem from incomplete path resolution. By building on <code>soft-canonicalize</code>, we benefit from systematic validation against years of documented attack vectors that simple string validation would miss.</p>
<h2 id="2-secure-api-design"><a class="header" href="#2-secure-api-design">2. Secure API Design</a></h2>
<p>Our API design is built around the principle that <strong>security should be the easiest path forward</strong>. Every design decision prioritizes preventing misuse over convenience.</p>
<h3 id="21-llm-agent-aware-design"><a class="header" href="#21-llm-agent-aware-design">2.1 LLM Agent-Aware Design</a></h3>
<p>Modern threats include AI agents processing untrusted paths from various sources. Our API is designed specifically for this threat model:</p>
<ul>
<li><strong>Clear validation points</strong>: <code>strict_join()</code> and <code>virtual_join()</code> make validation explicit and visible</li>
<li><strong>LLM-friendly documentation</strong>: Complete parameter documentation and usage examples specifically for AI consumption</li>
<li><strong>Fail-safe defaults</strong>: Operations fail closed rather than permitting potentially dangerous paths</li>
<li><strong>Explicit interop boundaries</strong>: <code>.interop_path()</code> makes filesystem handoffs to third-party code obvious</li>
</ul>
<h3 id="22-minimal-api-surface-for-minimal-error-margin"><a class="header" href="#22-minimal-api-surface-for-minimal-error-margin">2.2 Minimal API Surface for Minimal Error Margin</a></h3>
<p>We deliberately limit our public API surface to reduce the possibility of misuse:</p>
<ul>
<li><strong>No leaky trait implementations</strong>: No <code>AsRef&lt;Path&gt;</code>, <code>Deref&lt;Target = Path&gt;</code>, or implicit conversions that bypass validation</li>
<li><strong>Controlled constructors</strong>: Only specific, well-audited entry points for creating secure path types</li>
<li><strong>Helper API restrictions</strong>: New public functions require explicit maintainer approval to prevent API drift</li>
<li><strong>Dimension separation</strong>: Strict and virtual paths have separate, non-interchangeable operations</li>
</ul>
<h3 id="23-explicit-methods-that-make-logic-errors-visible"><a class="header" href="#23-explicit-methods-that-make-logic-errors-visible">2.3 Explicit Methods That Make Logic Errors Visible</a></h3>
<p>Our method names are designed to make security-relevant operations obvious during code review:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Unclear security implications
path.join(user_input)

// ✅ Security implications clear at a glance
boundary.strict_join(user_input)?
vroot.virtual_join(user_input)?
<span class="boring">}</span></code></pre></pre>
<p><strong>Key principles:</strong></p>
<ul>
<li><strong>Verbose over clever</strong>: <code>strict_join()</code> instead of <code>join()</code> makes the security operation explicit</li>
<li><strong>Dimension-specific operations</strong>: <code>strictpath_display()</code> vs <code>virtualpath_display()</code> prevent confusion</li>
<li><strong>No hidden validation</strong>: Every path that enters the system must go through an explicit validation step</li>
</ul>
<h3 id="24-rust-type-system-for-mathematical-correctness"><a class="header" href="#24-rust-type-system-for-mathematical-correctness">2.4 Rust Type System for Mathematical Correctness</a></h3>
<p>We leverage Rust's type system to provide <strong>compile-time guarantees</strong> about path security:</p>
<ul>
<li><strong>Marker types prevent confusion</strong>: <code>StrictPath&lt;UserUploads&gt;</code> vs <code>StrictPath&lt;SystemConfig&gt;</code> prevent accidentally mixing boundaries</li>
<li><strong>Borrowing prevents mutation</strong>: Once validated, paths cannot be secretly modified</li>
<li><strong>Ownership tracking</strong>: The type system ensures validated paths aren't leaked or corrupted</li>
<li><strong>Zero-cost abstractions</strong>: Security guarantees come at compile time, not runtime</li>
</ul>
<h3 id="25-distinct-types-for-hard-to-get-wrong-approach"><a class="header" href="#25-distinct-types-for-hard-to-get-wrong-approach">2.5 Distinct Types for "Hard to Get Wrong" Approach</a></h3>
<p>Different use cases get different types with appropriate guarantees:</p>
<ul>
<li><strong><code>PathBoundary&lt;Marker&gt;</code></strong>: For creating and managing restriction policies</li>
<li><strong><code>StrictPath&lt;Marker&gt;</code></strong>: For paths that must stay within boundaries (fails on violations)</li>
<li><strong><code>VirtualRoot&lt;Marker&gt;</code></strong>: For creating virtual filesystem views</li>
<li><strong><code>VirtualPath&lt;Marker&gt;</code></strong>: For virtual paths that clamp to safe boundaries</li>
<li><strong><code>StrictPathError</code></strong>: Comprehensive error handling for all failure modes</li>
<li><strong>Safe builtin I/O operations</strong>: Direct filesystem operations that bypass the need for <code>.interop_path()</code> calls</li>
</ul>
<h3 id="26-type-system-enforced-authorization"><a class="header" href="#26-type-system-enforced-authorization">2.6 Type System-Enforced Authorization</a></h3>
<p>The marker system enables compile-time authorization guarantees:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Authorization proof required to construct the marker
struct SecureDocuments;
impl SecureDocuments {
    fn new(auth_token: ValidatedAdminToken) -&gt; Self { Self }
}

// Type system ensures authorization happened
fn access_secure_file(path: &amp;StrictPath&lt;SecureDocuments&gt;) -&gt; Result&lt;String&gt; {
    path.read_to_string() // Compiler guarantees authorization
}
<span class="boring">}</span></code></pre></pre>
<h3 id="27-safe-builtin-io-operations"><a class="header" href="#27-safe-builtin-io-operations">2.7 Safe Builtin I/O Operations</a></h3>
<p>A critical security feature is our comprehensive suite of safe I/O operations that eliminate the need to escape to unsafe <code>std::fs</code> calls for routine work. The APIs mirror the semantics and return values of the standard library while preserving boundary guarantees.</p>
<p><strong>File operations:</strong></p>
<ul>
<li><code>read_to_string()</code>, <code>read()</code> — Read file contents</li>
<li><code>write&lt;C: AsRef&lt;[u8]&gt;&gt;()</code> — Write bytes (e.g., <code>&amp;str</code>, <code>&amp;[u8]</code>)</li>
<li><code>create_file()</code>, <code>open_file()</code> — Obtain file handles</li>
<li><code>remove_file()</code> — Delete files</li>
</ul>
<p><strong>Directory operations:</strong></p>
<ul>
<li><code>create_dir()</code>, <code>create_dir_all()</code> — Create directories</li>
<li><code>read_dir()</code> — Iterate directory entries (discover names; re-join through strict/virtual APIs)</li>
<li><code>metadata()</code> — Access filesystem metadata</li>
<li><code>remove_dir()</code>, <code>remove_dir_all()</code> — Delete directories</li>
</ul>
<p><strong>Move/Copy operations (dimension-specific):</strong></p>
<ul>
<li><code>StrictPath::strict_rename(..)</code> / <code>VirtualPath::virtual_rename(..)</code> — Rename/move within the restriction</li>
<li><code>StrictPath::strict_copy(..)</code> / <code>VirtualPath::virtual_copy(..)</code> — Copy within the restriction (returns bytes copied)</li>
</ul>
<p><strong>Links (creation):</strong></p>
<ul>
<li><code>StrictPath::strict_symlink(..)</code> / <code>VirtualPath::virtual_symlink(..)</code> — Create symlinks within the same restriction</li>
<li><code>StrictPath::strict_hard_link(..)</code> / <code>VirtualPath::virtual_hard_link(..)</code> — Create hard links (subject to platform constraints)</li>
</ul>
<p>Note: We intentionally do not expose separate helpers for "symlink metadata" or standalone canonicalization. When you must interoperate with APIs that require <code>AsRef&lt;Path&gt;</code> or specific OS semantics, use <code>.interop_path()</code> to get the validated path as <code>&amp;OsStr</code> and keep such calls isolated to interop boundaries.</p>
<p><strong>Why this matters:</strong> By providing safe alternatives to common <code>std::fs</code> operations, we eliminate the need for <code>.interop_path()</code> in routine file work, keeping the API surface focused on validated operations while still enabling necessary third‑party integrations.</p>
<h2 id="3-active-cve-research-and-validation"><a class="header" href="#3-active-cve-research-and-validation">3. Active CVE Research and Validation</a></h2>
<p>We maintain a systematic approach to understanding and defending against path-related vulnerabilities:</p>
<p><strong>Research activities:</strong></p>
<ul>
<li><strong>CVE database analysis</strong>: Study of documented path-related vulnerabilities across software ecosystems</li>
<li><strong>Security advisory analysis</strong>: Analysis of how attacks work and why existing solutions failed</li>
<li><strong>Historical attack validation</strong>: Testing our defenses against known attack patterns</li>
<li><strong>Comparative analysis</strong>: Study of similar libraries and their security approaches</li>
</ul>
<p><strong>Validation process:</strong></p>
<ul>
<li>Attack patterns are tested against our validation logic during development</li>
<li>Gaps identified in research inform security improvements</li>
<li>Security enhancements are implemented with careful consideration of compatibility</li>
<li>Relevant findings contribute to the broader security community understanding</li>
</ul>
<h2 id="4-open-source-transparency-for-rapid-issue-detection"><a class="header" href="#4-open-source-transparency-for-rapid-issue-detection">4. Open-Source Transparency for Rapid Issue Detection</a></h2>
<p>Security through obscurity is not security at all. Our open-source approach enables:</p>
<p><strong>Community validation:</strong></p>
<ul>
<li><strong>Expert review</strong>: Security researchers can audit our implementation</li>
<li><strong>Diverse testing</strong>: Community members test on platforms and use cases we haven't considered</li>
<li><strong>Collaborative bug reporting</strong>: Issues are tracked and addressed openly through GitHub</li>
<li><strong>Collaborative improvement</strong>: Security enhancements come from the community as well as maintainers</li>
</ul>
<p><strong>Transparency benefits:</strong></p>
<ul>
<li><strong>No hidden vulnerabilities</strong>: All code paths are visible for audit</li>
<li><strong>Public issue tracking</strong>: Security concerns are discussed openly</li>
<li><strong>Reproducible security</strong>: Anyone can verify our claims by reading the code</li>
<li><strong>Trust through verification</strong>: Don't trust our claims—verify them yourself</li>
</ul>
<h2 id="5-pseudo-projects-for-api-effectiveness-testing"><a class="header" href="#5-pseudo-projects-for-api-effectiveness-testing">5. Pseudo Projects for API Effectiveness Testing</a></h2>
<p>We maintain a suite of realistic demo projects that test our API in real-world scenarios:</p>
<p><strong>Demo categories:</strong></p>
<ul>
<li><strong>Web servers</strong>: File upload handlers, static asset serving, user content management</li>
<li><strong>CLI tools</strong>: File processors, archive extractors, configuration managers</li>
<li><strong>LLM agents</strong>: AI-driven file operations, automated code generation</li>
<li><strong>Archive handling</strong>: ZIP extraction, tar processing, backup restoration</li>
<li><strong>Configuration systems</strong>: Multi-environment config loading, user preference handling</li>
</ul>
<p><strong>Testing methodology:</strong></p>
<ul>
<li><strong>Production authenticity</strong>: Demos use real protocols and official ecosystem crates</li>
<li><strong>Security integration patterns</strong>: Each demo shows correct validation flow</li>
<li><strong>Failure mode testing</strong>: Demos include examples of rejected hostile inputs</li>
<li><strong>Performance validation</strong>: Real-world load testing of validation logic</li>
</ul>
<p><strong>Why this matters:</strong> APIs that work perfectly in isolation often fail when integrated into real systems. Our demos catch integration issues, performance problems, and usability gaps that unit tests miss.</p>
<h2 id="6-security-testing-and-validation"><a class="header" href="#6-security-testing-and-validation">6. Security Testing and Validation</a></h2>
<p>We employ comprehensive testing methodologies to validate our security approach:</p>
<h3 id="61-black-box-testing"><a class="header" href="#61-black-box-testing">6.1 Black-Box Testing</a></h3>
<p><strong>Automated fuzzing:</strong></p>
<ul>
<li>Random path generation across all Unicode ranges</li>
<li>Platform-specific attack vectors (Windows short names, Unix special files)</li>
<li>Encoding attack patterns (mixed encodings, normalization attacks)</li>
<li>Length-based attacks (extremely long paths, empty components)</li>
</ul>
<p><strong>LLM-assisted testing:</strong></p>
<ul>
<li><strong>AI-generated attack patterns</strong>: Using advanced LLMs to generate potential bypass attempts</li>
<li><strong>Reasoning model validation</strong>: Employing reasoning models to explore attack vectors</li>
<li><strong>Multi-model consensus</strong>: Cross-validating security assumptions across different AI models</li>
<li><strong>Systematic attack exploration</strong>: Multi-step validation approaches that build complexity</li>
</ul>
<h3 id="62-white-box-testing"><a class="header" href="#62-white-box-testing">6.2 White-Box Testing</a></h3>
<p><strong>Code analysis:</strong></p>
<ul>
<li><strong>Control flow analysis</strong>: Mapping all possible execution paths through validation logic</li>
<li><strong>State space exploration</strong>: Testing all combinations of internal validation states</li>
<li><strong>Boundary condition testing</strong>: Edge cases in canonicalization, length limits, character handling</li>
<li><strong>Race condition simulation</strong>: Concurrent access patterns and filesystem state changes</li>
</ul>
<p><strong>Architecture review:</strong></p>
<ul>
<li><strong>Trust boundary analysis</strong>: Verifying that security boundaries are correctly enforced</li>
<li><strong>Assumption validation</strong>: Testing that our security assumptions hold under all conditions</li>
<li><strong>Integration point review</strong>: Ensuring third-party integrations don't introduce vulnerabilities</li>
</ul>
<h3 id="63-security-validation-process"><a class="header" href="#63-security-validation-process">6.3 Security Validation Process</a></h3>
<p>Testing results inform our ongoing development:</p>
<ul>
<li><strong>Successful attacks</strong> become test cases and drive security improvements</li>
<li><strong>Failed attacks</strong> validate our defenses and expand our test coverage</li>
<li><strong>Novel attack vectors</strong> contribute to the security community's understanding</li>
<li><strong>Performance characteristics</strong> of attacks inform our optimization decisions</li>
</ul>
<h2 id="7-comprehensive-test-suite"><a class="header" href="#7-comprehensive-test-suite">7. Comprehensive Test Suite</a></h2>
<p>Our testing strategy covers multiple layers of validation:</p>
<h3 id="71-unit-testing"><a class="header" href="#71-unit-testing">7.1 Unit Testing</a></h3>
<p><strong>Core logic validation:</strong></p>
<ul>
<li>Every public function has comprehensive test coverage</li>
<li>Edge cases and boundary conditions are explicitly tested</li>
<li>Platform-specific behavior is validated on all supported systems</li>
<li>Error conditions are tested to ensure proper failure modes</li>
</ul>
<h3 id="72-integration-testing"><a class="header" href="#72-integration-testing">7.2 Integration Testing</a></h3>
<p><strong>Real-world scenario testing:</strong></p>
<ul>
<li>Full end-to-end flows from untrusted input to filesystem operations</li>
<li>Cross-platform compatibility validation</li>
<li>Third-party integration testing with common ecosystem crates</li>
<li>Performance testing under realistic load conditions</li>
</ul>
<h3 id="73-property-based-testing"><a class="header" href="#73-property-based-testing">7.3 Property-Based Testing</a></h3>
<p><strong>Automated verification:</strong></p>
<ul>
<li>QuickCheck-style property validation for core invariants</li>
<li>Fuzzing with structured inputs to explore edge cases</li>
<li>Shrinking of failing test cases to minimal reproduction examples</li>
<li>Statistical validation of security properties across large input spaces</li>
</ul>
<h3 id="74-security-focused-testing"><a class="header" href="#74-security-focused-testing">7.4 Security-Focused Testing</a></h3>
<p><strong>Attack simulation:</strong></p>
<ul>
<li>Known CVE reproduction tests to ensure we block historical attacks</li>
<li>Platform-specific security tests (Windows short names, Unix symlinks)</li>
<li>Encoding and normalization attack tests</li>
<li>Filesystem race condition simulations</li>
</ul>
<h3 id="75-continuous-testing"><a class="header" href="#75-continuous-testing">7.5 Continuous Testing</a></h3>
<p><strong>Automated validation:</strong></p>
<ul>
<li>CI/CD pipeline runs full test suite on every change</li>
<li>Multiple platform testing (Windows, Linux, macOS)</li>
<li>MSRV (Minimum Supported Rust Version) compatibility validation</li>
<li>Performance regression detection</li>
</ul>
<h2 id="security-is-a-process-not-a-product"><a class="header" href="#security-is-a-process-not-a-product">Security Is a Process, Not a Product</a></h2>
<p>Our security methodology recognizes that security is an ongoing commitment rather than a one-time achievement. We are committed to:</p>
<ul>
<li><strong>Monitor</strong> for new attack vectors and vulnerability patterns</li>
<li><strong>Adapt</strong> our defenses as the threat landscape evolves</li>
<li><strong>Learn</strong> from security incidents in the broader ecosystem</li>
<li><strong>Improve</strong> our methods based on real-world feedback and usage</li>
<li><strong>Contribute</strong> our knowledge to the security community</li>
</ul>
<p>The result is a library designed not only to address known path security issues but to evolve and adapt as new threats emerge. By building security into every layer—from the foundational libraries through the API design to the testing methodology—we provide comprehensive protection against the entire class of path traversal vulnerabilities.</p>
<p><strong>Remember:</strong> Path security isn't just about blocking <code>../../../etc/passwd</code>. It's about creating a robust defense against all the ways that untrusted paths can be crafted to bypass your security controls. That's what <code>strict-path</code> delivers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h1>
<p>This section shows practical, real-world scenarios where strict-path helps secure your applications. Each example includes complete, runnable code that you can adapt to your own projects.</p>
<h2 id="-example-categories"><a class="header" href="#-example-categories">📚 Example Categories</a></h2>
<h3 id="web-applications"><a class="header" href="#web-applications">Web Applications</a></h3>
<ul>
<li><strong><a href="examples/./web_upload_service.html">Web File Upload Service</a></strong> - Build a secure file upload service with per-user isolation</li>
<li><strong><a href="examples/./multi_user_storage.html">Multi-User Document Storage</a></strong> - Implement user sandboxing where each user feels they have their own filesystem</li>
</ul>
<h3 id="application-development"><a class="header" href="#application-development">Application Development</a></h3>
<ul>
<li><strong><a href="examples/./config_manager.html">Configuration File Manager</a></strong> - Safely handle user configuration files with automatic validation</li>
<li><strong><a href="examples/./cli_tool.html">CLI Tool with Safe Paths</a></strong> - Process user-provided file paths in command-line tools</li>
</ul>
<h3 id="security-critical-operations"><a class="header" href="#security-critical-operations">Security-Critical Operations</a></h3>
<ul>
<li><strong><a href="examples/./archive_extraction.html">Archive Extraction</a></strong> - Extract ZIP files safely without zip-slip vulnerabilities</li>
<li><strong><a href="examples/./type_safe_contexts.html">Type-Safe Context Separation</a></strong> - Use marker types to prevent mixing storage contexts at compile time</li>
</ul>
<h2 id="-common-patterns"><a class="header" href="#-common-patterns">🎯 Common Patterns</a></h2>
<p>All examples follow the same security pattern:</p>
<ol>
<li><strong>Create a boundary</strong> - Define your safe area with <code>PathBoundary</code> or <code>VirtualRoot</code></li>
<li><strong>Validate external input</strong> - Always use <code>strict_join()</code> or <code>virtual_join()</code> for untrusted paths</li>
<li><strong>Use safe types</strong> - Operate through <code>StrictPath</code> or <code>VirtualPath</code> for all file operations</li>
<li><strong>Let the compiler help</strong> - Type signatures encode security guarantees</li>
</ol>
<h2 id="-what-makes-these-secure"><a class="header" href="#-what-makes-these-secure">🔐 What Makes These Secure?</a></h2>
<ul>
<li><strong>No path escapes</strong> - Users can't use <code>../</code> or absolute paths to escape boundaries</li>
<li><strong>Compile-time safety</strong> - Wrong marker types won't compile</li>
<li><strong>Clear interfaces</strong> - Function signatures document what paths they accept</li>
<li><strong>Maintainable</strong> - Security isn't something to remember, it's in the type system</li>
</ul>
<h2 id="-using-these-examples"><a class="header" href="#-using-these-examples">💡 Using These Examples</a></h2>
<p>Each example is:</p>
<ul>
<li>✅ <strong>Complete</strong> - Includes all necessary imports and error handling</li>
<li>✅ <strong>Runnable</strong> - Copy-paste and adapt to your needs</li>
<li>✅ <strong>Explained</strong> - Comments highlight security patterns and key concepts</li>
<li>✅ <strong>Battle-tested</strong> - Shows real attack vectors that are automatically blocked</li>
</ul>
<p>Choose an example that matches your use case and start building secure applications!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-file-upload-service"><a class="header" href="#web-file-upload-service">Web File Upload Service</a></h1>
<p>Let's build a simple file upload service that allows users to upload files safely. This example demonstrates per-user isolation using <code>VirtualRoot</code>.</p>
<h2 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h2>
<p>Web applications need to accept file uploads from users, but must prevent:</p>
<ul>
<li>❌ Path traversal attacks (<code>../../../etc/passwd</code>)</li>
<li>❌ Users accessing other users' files</li>
<li>❌ Absolute path injections (<code>/var/www/html/shell.php</code>)</li>
</ul>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>Use <code>VirtualRoot</code> to create isolated storage for each user. Each user operates in their own sandboxed environment.</p>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{StrictPath, VirtualPath, VirtualRoot};
use std::io;

struct FileUploadService;

impl FileUploadService {
    // Multi-user: each user operates under their own VirtualRoot
    fn upload_file(
        &amp;self,
        user_uploads_root: &amp;VirtualRoot,
        upload_file_name: &amp;str,
        upload_file_content: &amp;[u8],
    ) -&gt; Result&lt;VirtualPath, Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate the untrusted filename at the user's virtual root
        let uploaded_file: VirtualPath = user_uploads_root.virtual_join(upload_file_name)?;
        // Reuse strict-typed helper when needed
        self.save_uploaded(uploaded_file.as_unvirtual(), upload_file_content)?;
        println!("✅ File uploaded safely to: {}", uploaded_file.virtualpath_display());
        Ok(uploaded_file)
    }

    // Internal helper: signature encodes guarantee (accepts only &amp;StrictPath)
    fn save_uploaded(&amp;self, file: &amp;StrictPath, content: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        file.create_parent_dir_all()?;
        file.write(content)
    }

    fn list_files(
        &amp;self,
        user_uploads_root: &amp;VirtualRoot,
    ) -&gt; Result&lt;Vec&lt;VirtualPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut files = Vec::new();
        for entry in user_uploads_root.read_dir()? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                let file: VirtualPath = user_uploads_root.virtual_join(entry.file_name())?;
                files.push(file);
            }
        }
        Ok(files)
    }

    fn download_file(&amp;self, file: &amp;VirtualPath) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
        // Read and return the file content — type ensures safety
        file.read()
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let service = FileUploadService;

    // Per-user virtual roots
    let alice_uploads_root: VirtualRoot = VirtualRoot::try_new_create("user_uploads/alice")?;
    let bob_uploads_root: VirtualRoot = VirtualRoot::try_new_create("user_uploads/bob")?;

    // Simulate user uploads - these are all SAFE and isolated
    service.upload_file(&amp;alice_uploads_root, "document.txt", b"Hello, world!")?;
    service.upload_file(&amp;alice_uploads_root, "reports/january.pdf", b"PDF content here")?;
    service.upload_file(&amp;bob_uploads_root, "images/photo.jpg", b"JPEG data")?;

    // These would be clamped/blocked by validation:
    // service.upload_file(&amp;alice_uploads_root, "../../../etc/passwd", b"attack")?;  // ❌ Blocked!
    // service.upload_file(&amp;alice_uploads_root, "..\\windows\\system32\\evil.exe", b"malware")?;  // ❌ Blocked!

    // List Alice's uploaded files (virtual paths)
    println!("📁 Alice's files:");
    for file in service.list_files(&amp;alice_uploads_root)? {
        println!("  - {}", file.virtualpath_display());
    }

    // Download a file using VirtualPath
    let document_file = alice_uploads_root.virtual_join("document.txt")?;
    let content = service.download_file(&amp;document_file)?;
    println!("📄 Downloaded: {}", String::from_utf8_lossy(&amp;content));

    Ok(())
}</code></pre></pre>
<h2 id="key-security-features"><a class="header" href="#key-security-features">Key Security Features</a></h2>
<h3 id="1-per-user-isolation"><a class="header" href="#1-per-user-isolation">1. Per-User Isolation</a></h3>
<p>Each user gets their own <code>VirtualRoot</code>. Alice can't access Bob's files and vice versa.</p>
<h3 id="2-automatic-path-validation"><a class="header" href="#2-automatic-path-validation">2. Automatic Path Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uploaded_file = user_uploads_root.virtual_join(upload_file_name)?;
<span class="boring">}</span></code></pre></pre>
<p>This validates the filename and ensures it stays within the user's boundary. Attacks are automatically blocked.</p>
<h3 id="3-type-safe-helpers"><a class="header" href="#3-type-safe-helpers">3. Type-Safe Helpers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_uploaded(&amp;self, file: &amp;StrictPath, content: &amp;[u8]) -&gt; io::Result&lt;()&gt;
<span class="boring">}</span></code></pre></pre>
<p>By accepting <code>&amp;StrictPath</code>, the function signature guarantees the path has been validated.</p>
<h3 id="4-virtual-path-display"><a class="header" href="#4-virtual-path-display">4. Virtual Path Display</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>uploaded_file.virtualpath_display()  // Shows "/document.txt" to the user
uploaded_file.strictpath_display()   // Shows "user_uploads/alice/document.txt" (system path)
<span class="boring">}</span></code></pre></pre>
<p>Users see clean paths starting from <code>/</code>, while the system knows the real location.</p>
<h2 id="attack-scenarios-prevented"><a class="header" href="#attack-scenarios-prevented">Attack Scenarios Prevented</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attack</th><th>Result</th></tr></thead><tbody>
<tr><td><code>../../../etc/passwd</code></td><td>❌ Clamped to user's root</td></tr>
<tr><td><code>..\\windows\\system32\\evil.exe</code></td><td>❌ Clamped to user's root</td></tr>
<tr><td><code>/var/www/html/shell.php</code></td><td>❌ Treated as relative, stays in boundary</td></tr>
<tr><td><code>alice/../bob/secret.txt</code></td><td>❌ Normalized and clamped</td></tr>
</tbody></table>
</div>
<h2 id="sharing-common-logic"><a class="header" href="#sharing-common-logic">Sharing Common Logic</a></h2>
<p>If you need to share logic between strict and virtual paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, VirtualPath, VirtualRoot};
use std::io;

// One helper that works with any marker
fn process_common&lt;M&gt;(file: &amp;StrictPath&lt;M&gt;) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    file.read()
}

// Prepare one strict file and one virtual file
let public_assets_root = PathBoundary::try_new("./assets")?;
let css_file: StrictPath = public_assets_root.strict_join("style.css")?;

let alice_uploads_root = VirtualRoot::try_new("./uploads/alice")?;
let avatar_file: VirtualPath = alice_uploads_root.virtual_join("avatar.jpg")?;

// Call with either type
let _ = process_common(&amp;css_file)?;                   // StrictPath
let _ = process_common(avatar_file.as_unvirtual())?; // Borrow strict view from VirtualPath
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-tips"><a class="header" href="#integration-tips">Integration Tips</a></h2>
<h3 id="with-web-frameworks"><a class="header" href="#with-web-frameworks">With Web Frameworks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example with axum/actix-web
async fn upload_handler(
    user_id: String,
    filename: String,
    content: Vec&lt;u8&gt;,
) -&gt; Result&lt;String, AppError&gt; {
    let user_root = get_user_root(&amp;user_id)?;
    let file = user_root.virtual_join(&amp;filename)?;
    file.write(&amp;content)?;
    Ok(file.virtualpath_display().to_string())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-async-runtimes"><a class="header" href="#with-async-runtimes">With Async Runtimes</a></h3>
<p>All file operations work with <code>tokio::fs</code> or <code>async-std</code> - just use <code>.interop_path()</code> when needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tokio::fs::write(file.interop_path(), content).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li>See <a href="examples/./multi_user_storage.html">Multi-User Document Storage</a> for a more complex user isolation example</li>
<li>See <a href="examples/./type_safe_contexts.html">Type-Safe Context Separation</a> to learn about using markers to prevent context mixing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-file-manager"><a class="header" href="#configuration-file-manager">Configuration File Manager</a></h1>
<p>Learn how to safely handle user configuration files with automatic path validation and type-safe file operations.</p>
<h2 id="the-problem-3"><a class="header" href="#the-problem-3">The Problem</a></h2>
<p>Applications need to load and save configuration files, but must prevent:</p>
<ul>
<li>❌ Users reading system configuration files (<code>../../../etc/shadow</code>)</li>
<li>❌ Writing config files outside the app's config directory</li>
<li>❌ Accidental path injections from corrupted config data</li>
</ul>
<h2 id="the-solution-1"><a class="header" href="#the-solution-1">The Solution</a></h2>
<p>Use <code>PathBoundary</code> to create a jail for configuration files. All config operations stay within the boundary.</p>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
struct AppConfig {
    theme: String,
    language: String,
    auto_save: bool,
}

impl Default for AppConfig {
    fn default() -&gt; Self {
        Self {
            theme: "dark".to_string(),
            language: "en".to_string(),
            auto_save: true,
        }
    }
}

struct ConfigManager {
    config_dir: PathBoundary,
}

impl ConfigManager {
    fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Create a jail for configuration files
        let config_dir = PathBoundary::try_new_create("app_config")?;
        Ok(Self { config_dir })
    }
    
    fn load_config(&amp;self, config_name: &amp;str) -&gt; Result&lt;AppConfig, Box&lt;dyn std::error::Error&gt;&gt; {
        // Ensure the config file name is safe
        let config_path = self.config_dir.strict_join(config_name)?;
        
        // Load config or create default
        if config_path.exists() {
            let content = config_path.read_to_string()?;
            let config: AppConfig = serde_json::from_str(&amp;content)?;
            println!("📖 Loaded config from: {}", config_path.strictpath_display());
            Ok(config)
        } else {
            println!("🆕 Creating default config at: {}", config_path.strictpath_display());
            let default_config = AppConfig::default();
            self.save_config(config_name, &amp;default_config)?;
            Ok(default_config)
        }
    }
    
    fn save_config(&amp;self, config_name: &amp;str, config: &amp;AppConfig) -&gt; Result&lt;StrictPath, Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate the config file path
        let config_path = self.config_dir.strict_join(config_name)?;
        
        // Serialize and save
        let content = serde_json::to_string_pretty(config)?;
        config_path.write(&amp;content)?;

        println!("💾 Saved config to: {}", config_path.strictpath_display());
        Ok(config_path)
    }
    
    fn list_configs(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut configs = Vec::new();
        
        for entry in self.config_dir.read_dir()? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                if let Some(name) = entry.file_name().to_str() {
                    if name.ends_with(".json") {
                        configs.push(name.to_string());
                    }
                }
            }
        }
        
        Ok(configs)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let config_manager = ConfigManager::new()?;
    
    // Load or create user config
    let mut user_config = config_manager.load_config("user.json")?;
    println!("Current config: {:#?}", user_config);
    
    // Modify and save
    user_config.theme = "light".to_string();
    user_config.auto_save = false;
    config_manager.save_config("user.json", &amp;user_config)?;
    
    // Create a different profile
    let admin_config = AppConfig {
        theme: "admin".to_string(),
        language: "en".to_string(),
        auto_save: true,
    };
    config_manager.save_config("admin.json", &amp;admin_config)?;
    
    // List all configs
    println!("📋 Available configs: {:?}", config_manager.list_configs()?);
    
    // These attempts would be blocked:
    // config_manager.load_config("../../../etc/passwd")?;  // ❌ Blocked!
    // config_manager.save_config("..\\windows\\evil.json", &amp;user_config)?;  // ❌ Blocked!
    
    Ok(())
}</code></pre></pre>
<h2 id="key-security-features-1"><a class="header" href="#key-security-features-1">Key Security Features</a></h2>
<h3 id="1-bounded-configuration-directory"><a class="header" href="#1-bounded-configuration-directory">1. Bounded Configuration Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_dir = PathBoundary::try_new_create("app_config")?;
<span class="boring">}</span></code></pre></pre>
<p>All configuration operations are restricted to this directory.</p>
<h3 id="2-validated-file-names"><a class="header" href="#2-validated-file-names">2. Validated File Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_path = self.config_dir.strict_join(config_name)?;
<span class="boring">}</span></code></pre></pre>
<p>User-provided config names are validated before any file operation.</p>
<h3 id="3-safe-returns"><a class="header" href="#3-safe-returns">3. Safe Returns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_config(&amp;self, config_name: &amp;str, config: &amp;AppConfig) -&gt; Result&lt;StrictPath, ...&gt;
<span class="boring">}</span></code></pre></pre>
<p>Returning <code>StrictPath</code> ensures callers can only operate on validated paths.</p>
<h3 id="4-automatic-parent-directory-creation"><a class="header" href="#4-automatic-parent-directory-creation">4. Automatic Parent Directory Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>config_path.write(&amp;content)?;
<span class="boring">}</span></code></pre></pre>
<p>The safe file operations handle parent directory creation automatically.</p>
<h2 id="attack-scenarios-prevented-1"><a class="header" href="#attack-scenarios-prevented-1">Attack Scenarios Prevented</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attack</th><th>Result</th></tr></thead><tbody>
<tr><td><code>load_config("../../../etc/passwd")</code></td><td>❌ Path escape blocked</td></tr>
<tr><td><code>save_config("/tmp/evil.json", ...)</code></td><td>❌ Absolute path blocked</td></tr>
<tr><td><code>load_config("..\\windows\\system.ini")</code></td><td>❌ Path escape blocked</td></tr>
</tbody></table>
</div>
<h2 id="integration-with-serde-1"><a class="header" href="#integration-with-serde-1">Integration with Serde</a></h2>
<p>For more complex deserialization scenarios, use the <code>serde</code> feature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, serde_ext::WithBoundary};
use serde::Deserialize;

#[derive(Deserialize)]
struct AppConfig {
    name: String,
    
    // Deserialize with validation through boundary
    #[serde(deserialize_with = "deserialize_config_file")]
    config_file: StrictPath&lt;ConfigFiles&gt;,
}

fn deserialize_config_file&lt;'de, D&gt;(deserializer: D) -&gt; Result&lt;StrictPath&lt;ConfigFiles&gt;, D::Error&gt;
where
    D: serde::Deserializer&lt;'de&gt;,
{
    let boundary = PathBoundary::&lt;ConfigFiles&gt;::try_new("config")?;
    let path_str = String::deserialize(deserializer)?;
    boundary.strict_join(&amp;path_str).map_err(serde::de::Error::custom)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="os-specific-config-locations"><a class="header" href="#os-specific-config-locations">OS-Specific Config Locations</a></h2>
<p>For platform-specific config directories, use the <code>dirs</code> feature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn new_with_os_config() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
    // Uses XDG on Linux, AppData on Windows, etc.
    let config_dir = PathBoundary::try_new_os_config("myapp")?;
    Ok(Self { config_dir })
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="examples/../os_directories.html">OS Standard Directories</a> chapter for more details.</p>
<h2 id="environment-variable-overrides-1"><a class="header" href="#environment-variable-overrides-1">Environment Variable Overrides</a></h2>
<p>For deployment flexibility, use the <code>app-path</code> feature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn new_with_override() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
    // Checks MYAPP_CONFIG_DIR env var first, falls back to default
    let config_dir = PathBoundary::try_new_app_path("config", Some("MYAPP_CONFIG_DIR"))?;
    Ok(Self { config_dir })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Store the boundary</strong> - Keep <code>PathBoundary</code> as a field in your manager struct</li>
<li><strong>Validate early</strong> - Use <code>strict_join()</code> immediately when receiving config names</li>
<li><strong>Return safe types</strong> - Functions should return <code>StrictPath</code> instead of raw strings</li>
<li><strong>Handle missing configs</strong> - Provide sensible defaults when configs don't exist</li>
</ol>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li>See <a href="examples/./cli_tool.html">CLI Tool</a> for handling user-provided paths in command-line applications</li>
<li>See <a href="examples/./type_safe_contexts.html">Type-Safe Context Separation</a> to learn about using markers for different config types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-user-document-storage"><a class="header" href="#multi-user-document-storage">Multi-User Document Storage</a></h1>
<p>Build a document storage system where each user feels like they have their own filesystem, complete with directory traversal prevention and user isolation.</p>
<h2 id="the-problem-4"><a class="header" href="#the-problem-4">The Problem</a></h2>
<p>Multi-user applications need to provide isolated storage where:</p>
<ul>
<li>❌ Users can't access other users' files</li>
<li>❌ Path traversal attacks don't work</li>
<li>❌ Users see clean paths (like <code>/reports/january.pdf</code>) instead of system paths</li>
</ul>
<h2 id="the-solution-2"><a class="header" href="#the-solution-2">The Solution</a></h2>
<p>Use <code>VirtualRoot</code> per user. Each user operates in their own sandboxed environment with clean virtual paths.</p>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{VirtualRoot, VirtualPath};
use std::fs;
use std::collections::HashMap;

struct DocumentStore {
    user_roots: HashMap&lt;String, VirtualRoot&gt;,
}

impl DocumentStore {
    fn new() -&gt; Self {
        Self {
            user_roots: HashMap::new(),
        }
    }
    
    fn get_user_root(&amp;mut self, username: &amp;str) -&gt; Result&lt;&amp;VirtualRoot, Box&lt;dyn std::error::Error&gt;&gt; {
        if !self.user_roots.contains_key(username) {
            // Each user gets their own isolated storage
            let user_dir = format!("user_data_{}", username);
            let vroot = VirtualRoot::try_new_create(&amp;user_dir)?;
            self.user_roots.insert(username.to_string(), vroot);
            println!("🏠 Created virtual root for user: {}", username);
        }
        
        Ok(self.user_roots.get(username).unwrap())
    }
    
    fn save_document(&amp;mut self, username: &amp;str, virtual_path: &amp;str, content: &amp;str) -&gt; Result&lt;VirtualPath, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.get_user_root(username)?;
        
        // User thinks they're saving to their own filesystem starting from "/"
        let doc_path = user_root.virtual_join(virtual_path)?;
        
        // Create parent directories and save
        doc_path.create_parent_dir_all()?;
        doc_path.write(content)?;
        
        println!("📝 User {username} saved document to: {}", doc_path.virtualpath_display());
        println!("    (Actually stored at: {})", doc_path.as_unvirtual().strictpath_display());
        
        Ok(doc_path)
    }
    
    fn load_document(&amp;mut self, username: &amp;str, virtual_path: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.get_user_root(username)?;
        let doc_path = user_root.virtual_join(virtual_path)?;
        
        let content = doc_path.read_to_string()?;
        println!("📖 User {} loaded document from: {}", username, virtual_path);
        
        Ok(content)
    }
    
    fn list_user_documents(&amp;mut self, username: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.get_user_root(username)?;
        let mut docs = Vec::new();
        
        fn collect_files(dir: impl AsRef&lt;std::path::Path&gt;, base: impl AsRef&lt;std::path::Path&gt;, docs: &amp;mut Vec&lt;String&gt;) -&gt; std::io::Result&lt;()&gt; {
            let dir = dir.as_ref();
            let base = base.as_ref();
            for entry in fs::read_dir(dir)? {
                let entry = entry?;
                let path = entry.path();
                
                if path.is_file() {
                    if let Ok(relative) = path.strip_prefix(base) {
                        if let Some(path_str) = relative.to_str() {
                            docs.push(format!("/{}", path_str.replace("\\", "/")));
                        }
                    }
                } else if path.is_dir() {
                    collect_files(&amp;path, base, docs)?;
                }
            }
            Ok(())
        }
        
        collect_files(user_root.interop_path(), user_root.interop_path(), &amp;mut docs)?;
        Ok(docs)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut store = DocumentStore::new();
    
    // Alice saves some documents
    store.save_document("alice", "/reports/quarterly.txt", "Q1 revenue was strong")?;
    store.save_document("alice", "/notes/meeting.md", "# Meeting Notes\n- Discuss new features")?;
    store.save_document("alice", "/drafts/proposal.doc", "Project proposal draft")?;
    
    // Bob saves his documents (completely separate from Alice)
    store.save_document("bob", "/code/main.rs", "fn main() { println!(\"Hello!\"); }")?;
    store.save_document("bob", "/docs/readme.txt", "My awesome project")?;
    
    // Charlie tries to access Alice's files - this is blocked at the path level
    // store.save_document("charlie", "/../alice/reports/quarterly.txt", "hacked")?;  // ❌ Blocked!
    
    // Each user can access their own files
    println!("📄 Alice's quarterly report: {}", store.load_document("alice", "/reports/quarterly.txt")?);
    println!("💻 Bob's code: {}", store.load_document("bob", "/code/main.rs")?);
    
    // List each user's documents
    println!("📁 Alice's documents: {:?}", store.list_user_documents("alice")?);
    println!("📁 Bob's documents: {:?}", store.list_user_documents("bob")?);
    
    Ok(())
}</code></pre></pre>
<h2 id="key-security-features-2"><a class="header" href="#key-security-features-2">Key Security Features</a></h2>
<h3 id="1-lazy-user-root-creation"><a class="header" href="#1-lazy-user-root-creation">1. Lazy User Root Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_user_root(&amp;mut self, username: &amp;str) -&gt; Result&lt;&amp;VirtualRoot, ...&gt;
<span class="boring">}</span></code></pre></pre>
<p>Each user gets their own <code>VirtualRoot</code> created on first access. Users are completely isolated from each other.</p>
<h3 id="2-virtual-path-display"><a class="header" href="#2-virtual-path-display">2. Virtual Path Display</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>doc_path.virtualpath_display()    // Shows: "/reports/quarterly.txt"
doc_path.strictpath_display()     // Shows: "user_data_alice/reports/quarterly.txt"
<span class="boring">}</span></code></pre></pre>
<p>Users see clean paths starting from <code>/</code>, while the system maintains real paths.</p>
<h3 id="3-automatic-isolation"><a class="header" href="#3-automatic-isolation">3. Automatic Isolation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>store.save_document("charlie", "/../alice/reports/quarterly.txt", "hacked")?;
<span class="boring">}</span></code></pre></pre>
<p>This is automatically blocked because <code>/../alice/...</code> gets clamped to Charlie's root.</p>
<h3 id="4-cross-user-access-prevention"><a class="header" href="#4-cross-user-access-prevention">4. Cross-User Access Prevention</a></h3>
<p>Even if you try:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let alice_root = store.get_user_root("alice")?;
let bob_root = store.get_user_root("bob")?;

// These are completely separate - no way to cross boundaries
let alice_doc = alice_root.virtual_join("/secret.txt")?;
let bob_doc = bob_root.virtual_join("/secret.txt")?;

// alice_doc and bob_doc point to different physical files
<span class="boring">}</span></code></pre></pre>
<h2 id="attack-scenarios-prevented-2"><a class="header" href="#attack-scenarios-prevented-2">Attack Scenarios Prevented</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attack</th><th>Result</th></tr></thead><tbody>
<tr><td><code>save_document("alice", "/../bob/data.txt", ...)</code></td><td>❌ Clamped to alice's root</td></tr>
<tr><td><code>save_document("alice", "/../../etc/passwd", ...)</code></td><td>❌ Clamped to alice's root</td></tr>
<tr><td><code>load_document("bob", "/../alice/secret.txt")</code></td><td>❌ Clamped to bob's root</td></tr>
<tr><td>Symlink to another user's directory</td><td>❌ Resolved within boundary</td></tr>
</tbody></table>
</div>
<h2 id="system-path-vs-virtual-path"><a class="header" href="#system-path-vs-virtual-path">System Path vs Virtual Path</a></h2>
<p>Understanding the difference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let alice_root = VirtualRoot::try_new_create("user_data_alice")?;
let doc = alice_root.virtual_join("/reports/january.pdf")?;

// What the user sees:
println!("{}", doc.virtualpath_display());
// Output: /reports/january.pdf

// What the system uses:
println!("{}", doc.as_unvirtual().strictpath_display());
// Output: user_data_alice/reports/january.pdf

// Both point to the same file, just different representations
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-tips-1"><a class="header" href="#integration-tips-1">Integration Tips</a></h2>
<h3 id="with-databases"><a class="header" href="#with-databases">With Databases</a></h3>
<p>Store virtual paths in the database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Document {
    id: i64,
    user_id: i64,
    virtual_path: String,  // "/reports/january.pdf"
    created_at: DateTime,
}

// When retrieving:
let user_root = get_user_root(user_id)?;
let doc_path = user_root.virtual_join(&amp;doc.virtual_path)?;
let content = doc_path.read()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="with-web-frameworks-1"><a class="header" href="#with-web-frameworks-1">With Web Frameworks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn get_document(
    user_id: String,
    path: String,
) -&gt; Result&lt;Vec&lt;u8&gt;, AppError&gt; {
    let user_root = get_user_root(&amp;user_id)?;
    let doc = user_root.virtual_join(&amp;path)?;
    Ok(doc.read()?)
}

async fn save_document(
    user_id: String,
    path: String,
    content: Vec&lt;u8&gt;,
) -&gt; Result&lt;String, AppError&gt; {
    let user_root = get_user_root(&amp;user_id)?;
    let doc = user_root.virtual_join(&amp;path)?;
    doc.create_parent_dir_all()?;
    doc.write(&amp;content)?;
    Ok(doc.virtualpath_display().to_string())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-shared-helpers"><a class="header" href="#with-shared-helpers">With Shared Helpers</a></h3>
<p>Share logic between users by accepting <code>&amp;StrictPath</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn analyze_document&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; Result&lt;DocumentStats, Error&gt; {
    let content = path.read_to_string()?;
    Ok(DocumentStats {
        lines: content.lines().count(),
        words: content.split_whitespace().count(),
    })
}

// Works for any user:
let alice_doc = alice_root.virtual_join("/report.txt")?;
let bob_doc = bob_root.virtual_join("/notes.txt")?;

let alice_stats = analyze_document(alice_doc.as_unvirtual())?;
let bob_stats = analyze_document(bob_doc.as_unvirtual())?;
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-quota-management"><a class="header" href="#advanced-quota-management">Advanced: Quota Management</a></h2>
<p>Track storage per user:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl DocumentStore {
    fn get_user_storage_size(&amp;self, username: &amp;str) -&gt; Result&lt;u64, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.user_roots.get(username)
            .ok_or("User not found")?;
        
        let mut total_size = 0u64;
        for entry in walkdir::WalkDir::new(user_root.interop_path()) {
            let entry = entry?;
            if entry.file_type().is_file() {
                total_size += entry.metadata()?.len();
            }
        }
        
        Ok(total_size)
    }
    
    fn check_quota(&amp;self, username: &amp;str, quota: u64) -&gt; Result&lt;bool, Box&lt;dyn std::error::Error&gt;&gt; {
        let used = self.get_user_storage_size(username)?;
        Ok(used &lt; quota)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<ol>
<li><strong>Cache user roots</strong> - Store <code>VirtualRoot</code> instances to avoid repeated creation</li>
<li><strong>Lazy initialization</strong> - Only create directories when first accessed</li>
<li><strong>Batch operations</strong> - Group multiple file operations together</li>
<li><strong>Use async I/O</strong> - All paths work with <code>tokio::fs</code> via <code>.interop_path()</code></li>
</ol>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>One root per user</strong> - Never share <code>VirtualRoot</code> between users</li>
<li><strong>Store virtual paths</strong> - Save virtual paths in your database, not system paths</li>
<li><strong>Display virtual paths</strong> - Show users virtual paths (starting with <code>/</code>)</li>
<li><strong>Use system paths for I/O</strong> - Use <code>.as_unvirtual()</code> when calling file operations</li>
</ol>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li>See <a href="examples/./web_upload_service.html">Web Upload Service</a> for a simpler upload-only example</li>
<li>See <a href="examples/./type_safe_contexts.html">Type-Safe Context Separation</a> to learn about using markers for different document types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive-extraction-with-safety"><a class="header" href="#archive-extraction-with-safety">Archive Extraction with Safety</a></h1>
<p>Extract ZIP files and other archives safely without zip-slip vulnerabilities. This example shows how path validation automatically prevents malicious archive entries.</p>
<h2 id="the-problem-5"><a class="header" href="#the-problem-5">The Problem</a></h2>
<p>Archive extractors are vulnerable to <strong>zip-slip attacks</strong> where malicious archives contain entries like:</p>
<ul>
<li>❌ <code>../../../etc/passwd</code> - Escapes to system files</li>
<li>❌ <code>..\\..\\windows\\system32\\evil.exe</code> - Escapes on Windows</li>
<li>❌ Symlinks pointing outside the extraction directory</li>
</ul>
<h2 id="the-solution-3"><a class="header" href="#the-solution-3">The Solution</a></h2>
<p>Use <code>PathBoundary</code> to restrict extraction to a specific directory. Malicious paths are automatically blocked.</p>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath};
use std::fs;
use std::io::Write;

struct SafeArchiveExtractor {
    extraction_dir: PathBoundary,
}

impl SafeArchiveExtractor {
    fn new(extract_to: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        let extraction_dir = PathBoundary::try_new_create(extract_to)?;
        Ok(Self { extraction_dir })
    }
    
    fn extract_entry(&amp;self, entry_path: &amp;str, content: &amp;[u8]) -&gt; Result&lt;StrictPath, Box&lt;dyn std::error::Error&gt;&gt; {
        // This automatically prevents zip-slip attacks
        let safe_path = self.extraction_dir.strict_join(entry_path)?;

        // Create parent directories and write the file
        safe_path.create_parent_dir_all()?;
        safe_path.write(content)?;

        println!("📦 Extracted: {entry_path} -&gt; {}", safe_path.strictpath_display());
        Ok(safe_path)
    }
    
    fn extract_mock_zip(&amp;self) -&gt; Result&lt;Vec&lt;StrictPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        // Simulate extracting a ZIP file with various entries
        let entries = vec![
            ("readme.txt", b"Welcome to our software!" as &amp;[u8]),
            ("src/main.rs", b"fn main() { println!(\"Hello!\"); }"),
            ("docs/api.md", b"# API Documentation"),
            ("config/settings.json", b"{ \"debug\": true }"),
            
            // These malicious entries would be automatically blocked:
            // ("../../../etc/passwd", b"hacked"),           // ❌ Blocked!
            // ("..\\windows\\system32\\evil.exe", b"malware"), // ❌ Blocked!
            // ("/absolute/path/hack.txt", b"bad"),          // ❌ Blocked!
        ];
        
        let mut extracted_files = Vec::new();
        
        for (entry_path, content) in entries {
            match self.extract_entry(entry_path, content) {
                Ok(safe_path) =&gt; extracted_files.push(safe_path),
                Err(e) =&gt; println!("⚠️  Blocked malicious entry '{}': {}", entry_path, e),
            }
        }
        
        Ok(extracted_files)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let extractor = SafeArchiveExtractor::new("extracted_files")?;
    
    println!("🗃️  Extracting archive safely...");
    let extracted = extractor.extract_mock_zip()?;
    
    println!("\n✅ Successfully extracted {} files:", extracted.len());
    for file in &amp;extracted {
        println!("   📄 {}", file.strictpath_display());
    }
    
    // Verify we can read the extracted files
    for file in &amp;extracted {
        if file.strictpath_extension().and_then(|s| s.to_str()) == Some("txt") {
            let content = file.read_to_string()?;
            println!("📖 {}: {}", file.strictpath_display(), content.trim());
        }
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="key-security-features-3"><a class="header" href="#key-security-features-3">Key Security Features</a></h2>
<h3 id="1-bounded-extraction-directory"><a class="header" href="#1-bounded-extraction-directory">1. Bounded Extraction Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let extraction_dir = PathBoundary::try_new_create(extract_to)?;
<span class="boring">}</span></code></pre></pre>
<p>All extracted files must stay within this directory.</p>
<h3 id="2-automatic-malicious-path-detection"><a class="header" href="#2-automatic-malicious-path-detection">2. Automatic Malicious Path Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let safe_path = self.extraction_dir.strict_join(entry_path)?;
<span class="boring">}</span></code></pre></pre>
<p>This line does all the heavy lifting:</p>
<ul>
<li>Normalizes <code>../</code> sequences</li>
<li>Blocks absolute paths</li>
<li>Prevents symlink escapes</li>
<li>Returns an error for malicious paths</li>
</ul>
<h3 id="3-parent-directory-creation"><a class="header" href="#3-parent-directory-creation">3. Parent Directory Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>safe_path.create_parent_dir_all()?;
<span class="boring">}</span></code></pre></pre>
<p>Automatically creates any necessary parent directories within the boundary.</p>
<h3 id="4-type-safe-returns"><a class="header" href="#4-type-safe-returns">4. Type-Safe Returns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extract_entry(&amp;self, entry_path: &amp;str, content: &amp;[u8]) -&gt; Result&lt;StrictPath, ...&gt;
<span class="boring">}</span></code></pre></pre>
<p>Returning <code>StrictPath</code> ensures extracted paths are always validated.</p>
<h2 id="attack-scenarios-prevented-3"><a class="header" href="#attack-scenarios-prevented-3">Attack Scenarios Prevented</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Malicious Entry</th><th>Result</th></tr></thead><tbody>
<tr><td><code>../../../etc/passwd</code></td><td>❌ Error: path escapes boundary</td></tr>
<tr><td><code>..\\windows\\system32\\evil.exe</code></td><td>❌ Error: path escapes boundary</td></tr>
<tr><td><code>/var/www/html/shell.php</code></td><td>❌ Treated as relative, may still escape</td></tr>
<tr><td><code>legitimate/../../etc/passwd</code></td><td>❌ Normalized and blocked</td></tr>
<tr><td>Symlink to <code>/etc/passwd</code></td><td>❌ Resolved and validated</td></tr>
</tbody></table>
</div>
<h2 id="real-zip-integration"><a class="header" href="#real-zip-integration">Real ZIP Integration</a></h2>
<p>With the <code>zip</code> crate:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath};
use zip::ZipArchive;
use std::fs::File;
use std::io::Read;

struct RealArchiveExtractor {
    extraction_dir: PathBoundary,
}

impl RealArchiveExtractor {
    fn new(extract_to: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        let extraction_dir = PathBoundary::try_new_create(extract_to)?;
        Ok(Self { extraction_dir })
    }
    
    fn extract_zip(&amp;self, zip_path: &amp;str) -&gt; Result&lt;Vec&lt;StrictPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let file = File::open(zip_path)?;
        let mut archive = ZipArchive::new(file)?;
        let mut extracted_files = Vec::new();
        
        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            let entry_path = file.name();
            
            // Validate the entry path - blocks zip-slip automatically
            let safe_path = match self.extraction_dir.strict_join(entry_path) {
                Ok(path) =&gt; path,
                Err(e) =&gt; {
                    println!("⚠️  Skipping malicious entry '{}': {}", entry_path, e);
                    continue;
                }
            };
            
            if file.is_dir() {
                safe_path.create_dir_all()?;
            } else {
                safe_path.create_parent_dir_all()?;
                let mut content = Vec::new();
                file.read_to_end(&amp;mut content)?;
                safe_path.write(&amp;content)?;
                extracted_files.push(safe_path);
                println!("📦 Extracted: {}", entry_path);
            }
        }
        
        Ok(extracted_files)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let extractor = RealArchiveExtractor::new("extracted")?;
    
    // Extract a real ZIP file safely
    let files = extractor.extract_zip("archive.zip")?;
    println!("✅ Extracted {} files", files.len());
    
    Ok(())
}</code></pre></pre>
<h2 id="tar-archives"><a class="header" href="#tar-archives">TAR Archives</a></h2>
<p>With the <code>tar</code> crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};
use tar::Archive;
use std::fs::File;

fn extract_tar(tar_path: &amp;str, extract_to: &amp;str) -&gt; Result&lt;Vec&lt;StrictPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let boundary = PathBoundary::try_new_create(extract_to)?;
    let mut extracted = Vec::new();
    
    let file = File::open(tar_path)?;
    let mut archive = Archive::new(file);
    
    for entry in archive.entries()? {
        let mut entry = entry?;
        let entry_path = entry.path()?;
        let entry_path_str = entry_path.to_string_lossy();
        
        // Validate each entry path
        let safe_path = match boundary.strict_join(&amp;*entry_path_str) {
            Ok(path) =&gt; path,
            Err(e) =&gt; {
                println!("⚠️  Skipping malicious entry '{}': {}", entry_path_str, e);
                continue;
            }
        };
        
        // Extract using the validated path
        entry.unpack(safe_path.interop_path())?;
        extracted.push(safe_path);
        println!("📦 Extracted: {}", entry_path_str);
    }
    
    Ok(extracted)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-extraction-with-filters"><a class="header" href="#advanced-extraction-with-filters">Advanced: Extraction with Filters</a></h2>
<p>Skip certain files or enforce naming patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SafeArchiveExtractor {
    fn extract_with_filter&lt;F&gt;(
        &amp;self,
        entries: Vec&lt;(&amp;str, &amp;[u8])&gt;,
        filter: F,
    ) -&gt; Result&lt;Vec&lt;StrictPath&gt;, Box&lt;dyn std::error::Error&gt;&gt;
    where
        F: Fn(&amp;str) -&gt; bool,
    {
        let mut extracted = Vec::new();
        
        for (entry_path, content) in entries {
            // Apply custom filter
            if !filter(entry_path) {
                println!("⏭️  Skipped by filter: {}", entry_path);
                continue;
            }
            
            // Validate and extract
            match self.extract_entry(entry_path, content) {
                Ok(path) =&gt; extracted.push(path),
                Err(e) =&gt; println!("⚠️  Failed to extract '{}': {}", entry_path, e),
            }
        }
        
        Ok(extracted)
    }
}

// Usage:
let extracted = extractor.extract_with_filter(entries, |path| {
    // Only allow certain file types
    path.ends_with(".txt") || path.ends_with(".md") || path.ends_with(".rs")
})?;
<span class="boring">}</span></code></pre></pre>
<h2 id="temporary-extraction"><a class="header" href="#temporary-extraction">Temporary Extraction</a></h2>
<p>Extract to a temporary directory for processing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;
use tempfile::TempDir;

fn extract_to_temp(archive_path: &amp;str) -&gt; Result&lt;(TempDir, Vec&lt;StrictPath&gt;), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create temp directory
    let temp = TempDir::new()?;
    
    // Create boundary from temp path
    let boundary = PathBoundary::try_new(temp.path())?;
    
    // Extract archive
    let extracted = extract_archive_to_boundary(&amp;boundary, archive_path)?;
    
    // Return both TempDir (to keep it alive) and extracted paths
    Ok((temp, extracted))
}

// Temp directory is automatically cleaned up when TempDir is dropped
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Always validate</strong> - Never trust archive entry paths</li>
<li><strong>Log suspicious entries</strong> - Track and alert on blocked paths</li>
<li><strong>Limit extraction size</strong> - Check total extracted size to prevent zip bombs</li>
<li><strong>Filter file types</strong> - Only extract expected file types</li>
<li><strong>Use temporary storage</strong> - Extract to temp directory first, then move to final location</li>
</ol>
<h2 id="integration-tips-2"><a class="header" href="#integration-tips-2">Integration Tips</a></h2>
<h3 id="with-web-uploads"><a class="header" href="#with-web-uploads">With Web Uploads</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_upload(file: UploadedFile) -&gt; Result&lt;Vec&lt;String&gt;, AppError&gt; {
    // Save uploaded file
    let temp_zip = save_upload(file).await?;
    
    // Extract safely
    let extractor = SafeArchiveExtractor::new("uploads/extracted")?;
    let files = extractor.extract_zip(&amp;temp_zip)?;
    
    // Return list of extracted files
    Ok(files.iter()
        .map(|p| p.strictpath_display().to_string())
        .collect())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-background-jobs"><a class="header" href="#with-background-jobs">With Background Jobs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn extract_job(job_id: String, archive_path: String) -&gt; Result&lt;(), JobError&gt; {
    let extract_dir = format!("jobs/{}/extracted", job_id);
    let extractor = SafeArchiveExtractor::new(&amp;extract_dir)?;
    
    let files = extractor.extract_zip(&amp;archive_path)?;
    
    // Store results in database
    for file in files {
        db_store_file(&amp;job_id, file.strictpath_display())?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li>See <a href="examples/./cli_tool.html">CLI Tool</a> for handling user-provided file paths</li>
<li>See <a href="examples/./web_upload_service.html">Web Upload Service</a> for combining uploads with safe storage</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-tool-with-safe-path-handling"><a class="header" href="#cli-tool-with-safe-path-handling">CLI Tool with Safe Path Handling</a></h1>
<p>Build command-line tools that safely process user-provided file paths. This example shows how to handle untrusted path arguments securely.</p>
<h2 id="the-problem-6"><a class="header" href="#the-problem-6">The Problem</a></h2>
<p>CLI tools accept file paths from users, but must prevent:</p>
<ul>
<li>❌ Users accessing files outside the working directory</li>
<li>❌ Path traversal attacks via command-line arguments</li>
<li>❌ Accidental exposure of sensitive files</li>
</ul>
<h2 id="the-solution-4"><a class="header" href="#the-solution-4">The Solution</a></h2>
<p>Use <code>PathBoundary</code> to create a working directory jail. All file operations are restricted to this boundary.</p>
<h2 id="complete-example-4"><a class="header" href="#complete-example-4">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath};
use std::env;
use std::fs;

struct SafeFileProcessor {
    working_dir: PathBoundary,
}

impl SafeFileProcessor {
    fn new(working_directory: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Create or validate the working directory
        let working_dir = PathBoundary::try_new_create(working_directory)?;
        println!("🔒 Working directory jail: {}", working_dir.strictpath_display());
        Ok(Self { working_dir })
    }
    
    fn process_file(&amp;self, relative_path: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate the user-provided path
        let safe_path = self.working_dir.strict_join(relative_path)?;
        
        if !safe_path.exists() {
            return Err(format!("File not found: {}", relative_path).into());
        }
        
        // Process the file (example: count lines)
        let content = safe_path.read_to_string()?;
        let line_count = content.lines().count();
        let word_count = content.split_whitespace().count();
        let char_count = content.chars().count();
        
        println!("📊 Statistics for {}:", relative_path);
        println!("   Lines: {}", line_count);
        println!("   Words: {}", word_count);
        println!("   Characters: {}", char_count);
        
        Ok(())
    }
    
    fn create_sample_files(&amp;self) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Create some sample files for testing
        let samples = vec![
            ("sample1.txt", "Hello world!\nThis is a test file.\nWith multiple lines."),
            ("data/sample2.txt", "Another file\nwith some content\nfor processing."),
            ("docs/readme.md", "# Sample Project\n\nThis is a sample markdown file."),
        ];
        
        for (path, content) in samples {
            let safe_path = self.working_dir.strict_join(path)?;
            safe_path.create_parent_dir_all()?;
            safe_path.write(content)?;
            println!("📝 Created: {path}");
        }
        
        Ok(())
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let args: Vec&lt;String&gt; = env::args().collect();
    
    if args.len() &lt; 2 {
        println!("Usage: {} &lt;file-path&gt;", args[0]);
        println!("       {} --create-samples", args[0]);
        return Ok(());
    }
    
    // Set up our safe processor
    let processor = SafeFileProcessor::new("workspace")?;
    
    if args[1] == "--create-samples" {
        processor.create_sample_files()?;
        println!("✅ Sample files created in workspace/");
        return Ok(());
    }
    
    // Process the user-specified file
    let file_path = &amp;args[1];
    
    match processor.process_file(file_path) {
        Ok(()) =&gt; println!("✅ File processed successfully!"),
        Err(e) =&gt; {
            println!("❌ Error processing file: {}", e);
            
            if file_path.contains("..") || file_path.starts_with('/') || file_path.contains('\\') {
                println!("💡 Tip: Use relative paths within the workspace directory only.");
                println!("   Trying to escape the workspace? That's not allowed! 🔒");
            }
        }
    }
    
    Ok(())
}

// Example usage:
// cargo run -- --create-samples
// cargo run -- sample1.txt                    # ✅ Works
// cargo run -- data/sample2.txt              # ✅ Works  
// cargo run -- ../../../etc/passwd           # ❌ Blocked!
// cargo run -- /absolute/path/hack.txt       # ❌ Blocked!</code></pre></pre>
<h2 id="key-security-features-4"><a class="header" href="#key-security-features-4">Key Security Features</a></h2>
<h3 id="1-working-directory-jail"><a class="header" href="#1-working-directory-jail">1. Working Directory Jail</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let working_dir = PathBoundary::try_new_create(working_directory)?;
<span class="boring">}</span></code></pre></pre>
<p>All file operations are restricted to this directory and its subdirectories.</p>
<h3 id="2-user-input-validation"><a class="header" href="#2-user-input-validation">2. User Input Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let safe_path = self.working_dir.strict_join(relative_path)?;
<span class="boring">}</span></code></pre></pre>
<p>User-provided paths from command-line arguments are validated before any file access.</p>
<h3 id="3-helpful-error-messages"><a class="header" href="#3-helpful-error-messages">3. Helpful Error Messages</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if file_path.contains("..") || file_path.starts_with('/') {
    println!("💡 Tip: Use relative paths within the workspace directory only.");
}
<span class="boring">}</span></code></pre></pre>
<p>Guide users toward safe usage patterns.</p>
<h3 id="4-safe-file-operations"><a class="header" href="#4-safe-file-operations">4. Safe File Operations</a></h3>
<p>All operations use the validated <code>StrictPath</code>, so security is guaranteed by the type system.</p>
<h2 id="attack-scenarios-prevented-4"><a class="header" href="#attack-scenarios-prevented-4">Attack Scenarios Prevented</a></h2>
<div class="table-wrapper"><table><thead><tr><th>User Input</th><th>Result</th></tr></thead><tbody>
<tr><td><code>sample1.txt</code></td><td>✅ Processes workspace/sample1.txt</td></tr>
<tr><td><code>data/sample2.txt</code></td><td>✅ Processes workspace/data/sample2.txt</td></tr>
<tr><td><code>../../../etc/passwd</code></td><td>❌ Error: path escapes boundary</td></tr>
<tr><td><code>/var/log/system.log</code></td><td>❌ Error: absolute paths not allowed</td></tr>
<tr><td><code>..\\..\\windows\\system32</code></td><td>❌ Error: path escapes boundary</td></tr>
</tbody></table>
</div>
<h2 id="advanced-multiple-operations"><a class="header" href="#advanced-multiple-operations">Advanced: Multiple Operations</a></h2>
<p>Process multiple files from command-line arguments:</p>
<pre><pre class="playground"><code class="language-rust">impl SafeFileProcessor {
    fn process_multiple(&amp;self, paths: &amp;[String]) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        for path in paths {
            match self.process_file(path) {
                Ok(()) =&gt; println!("✅ Processed: {}", path),
                Err(e) =&gt; println!("❌ Failed to process '{}': {}", path, e),
            }
        }
        Ok(())
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let args: Vec&lt;String&gt; = env::args().collect();
    
    if args.len() &lt; 2 {
        println!("Usage: {} &lt;file1&gt; [file2] [file3] ...", args[0]);
        return Ok(());
    }
    
    let processor = SafeFileProcessor::new("workspace")?;
    let file_paths = &amp;args[1..];
    
    processor.process_multiple(file_paths)?;
    
    Ok(())
}</code></pre></pre>
<h2 id="pattern-matching-and-filtering"><a class="header" href="#pattern-matching-and-filtering">Pattern Matching and Filtering</a></h2>
<p>Process files matching a pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SafeFileProcessor {
    fn process_pattern(&amp;self, pattern: &amp;str) -&gt; Result&lt;Vec&lt;StrictPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut processed = Vec::new();
        
        for entry in self.working_dir.read_dir()? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                let filename = entry.file_name();
                let filename_str = filename.to_string_lossy();
                
                // Simple pattern matching (extend with regex if needed)
                if filename_str.ends_with(pattern) {
                    let file_path = self.working_dir.strict_join(&amp;filename)?;
                    self.process_file(&amp;filename_str)?;
                    processed.push(file_path);
                }
            }
        }
        
        Ok(processed)
    }
}

// Usage:
// cargo run -- "*.txt"  // Process all .txt files
// cargo run -- "*.md"   // Process all .md files
<span class="boring">}</span></code></pre></pre>
<h2 id="interactive-mode"><a class="header" href="#interactive-mode">Interactive Mode</a></h2>
<p>Build an interactive CLI with safe path handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, BufRead};

fn interactive_mode(processor: &amp;SafeFileProcessor) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    println!("📂 Interactive mode - enter file paths to process (type 'quit' to exit)");
    println!("🔒 Working in: {}", processor.working_dir.strictpath_display());
    
    let stdin = io::stdin();
    for line in stdin.lock().lines() {
        let line = line?;
        let trimmed = line.trim();
        
        if trimmed == "quit" || trimmed == "exit" {
            break;
        }
        
        if trimmed == "list" {
            list_files(&amp;processor.working_dir)?;
            continue;
        }
        
        if trimmed.is_empty() {
            continue;
        }
        
        match processor.process_file(trimmed) {
            Ok(()) =&gt; println!("✅ Done"),
            Err(e) =&gt; println!("❌ Error: {}", e),
        }
    }
    
    println!("👋 Goodbye!");
    Ok(())
}

fn list_files(boundary: &amp;PathBoundary) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    println!("📁 Available files:");
    for entry in boundary.read_dir()? {
        let entry = entry?;
        println!("  - {}", entry.file_name().to_string_lossy());
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="output-file-handling"><a class="header" href="#output-file-handling">Output File Handling</a></h2>
<p>Write results to output files safely:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SafeFileProcessor {
    fn process_to_output(
        &amp;self,
        input_path: &amp;str,
        output_path: &amp;str,
    ) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate both input and output paths
        let input = self.working_dir.strict_join(input_path)?;
        let output = self.working_dir.strict_join(output_path)?;
        
        // Process input
        let content = input.read_to_string()?;
        let processed = content.to_uppercase(); // Example transformation
        
        // Write to output
        output.create_parent_dir_all()?;
        output.write(&amp;processed)?;
        
        println!("✅ Processed {} -&gt; {}", input_path, output_path);
        
        Ok(())
    }
}

// Usage:
// cargo run -- input.txt output.txt
<span class="boring">}</span></code></pre></pre>
<h2 id="environment-variable-configuration"><a class="header" href="#environment-variable-configuration">Environment Variable Configuration</a></h2>
<p>Allow configuration via environment variables:</p>
<pre><pre class="playground"><code class="language-rust">fn get_working_directory() -&gt; String {
    env::var("WORKSPACE_DIR")
        .unwrap_or_else(|_| "workspace".to_string())
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let work_dir = get_working_directory();
    let processor = SafeFileProcessor::new(&amp;work_dir)?;
    
    // ... rest of implementation
    Ok(())
}

// Usage:
// WORKSPACE_DIR=/path/to/data cargo run -- file.txt</code></pre></pre>
<h2 id="progress-tracking"><a class="header" href="#progress-tracking">Progress Tracking</a></h2>
<p>For processing many files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SafeFileProcessor {
    fn process_directory(&amp;self) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        let mut total = 0;
        let mut processed = 0;
        let mut failed = 0;
        
        // Count total files
        for entry in self.working_dir.read_dir()? {
            if entry?.file_type()?.is_file() {
                total += 1;
            }
        }
        
        println!("📊 Processing {} files...", total);
        
        // Process each file
        for entry in self.working_dir.read_dir()? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                let filename = entry.file_name();
                let path_str = filename.to_string_lossy();
                
                match self.process_file(&amp;path_str) {
                    Ok(()) =&gt; {
                        processed += 1;
                        println!("[{}/{}] ✅ {}", processed + failed, total, path_str);
                    }
                    Err(e) =&gt; {
                        failed += 1;
                        println!("[{}/{}] ❌ {}: {}", processed + failed, total, path_str, e);
                    }
                }
            }
        }
        
        println!("\n📈 Summary:");
        println!("   Total: {}", total);
        println!("   Processed: {}", processed);
        println!("   Failed: {}", failed);
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li><strong>Clear boundaries</strong> - Clearly communicate the working directory to users</li>
<li><strong>Helpful errors</strong> - Explain why paths are rejected and suggest alternatives</li>
<li><strong>Relative paths only</strong> - Guide users toward using relative paths</li>
<li><strong>Validate early</strong> - Check paths before performing expensive operations</li>
<li><strong>Log rejections</strong> - Track attempted path escapes for security monitoring</li>
</ol>
<h2 id="integration-tips-3"><a class="header" href="#integration-tips-3">Integration Tips</a></h2>
<h3 id="with-clap-for-argument-parsing"><a class="header" href="#with-clap-for-argument-parsing">With <code>clap</code> for Argument Parsing</a></h3>
<pre><pre class="playground"><code class="language-rust">use clap::Parser;

#[derive(Parser)]
struct Cli {
    /// File to process (relative to workspace)
    #[arg(value_name = "FILE")]
    file_path: String,
    
    /// Working directory
    #[arg(short, long, default_value = "workspace")]
    workspace: String,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let cli = Cli::parse();
    let processor = SafeFileProcessor::new(&amp;cli.workspace)?;
    processor.process_file(&amp;cli.file_path)?;
    Ok(())
}</code></pre></pre>
<h3 id="with-glob-patterns"><a class="header" href="#with-glob-patterns">With Glob Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use glob::glob;

fn process_glob(processor: &amp;SafeFileProcessor, pattern: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let workspace = processor.working_dir.strictpath_display().to_string();
    let full_pattern = format!("{}/{}", workspace, pattern);
    
    for entry in glob(&amp;full_pattern)? {
        let path = entry?;
        if let Ok(relative) = path.strip_prefix(&amp;workspace) {
            if let Some(relative_str) = relative.to_str() {
                processor.process_file(relative_str)?;
            }
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li>See <a href="examples/./config_manager.html">Configuration Manager</a> for handling config files safely</li>
<li>See <a href="examples/./archive_extraction.html">Archive Extraction</a> for processing archives from CLI</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-safe-context-separation"><a class="header" href="#type-safe-context-separation">Type-Safe Context Separation</a></h1>
<p>Learn how to use marker types to prevent accidentally mixing different storage contexts at compile time. This is one of the most powerful features of strict-path.</p>
<h2 id="the-problem-7"><a class="header" href="#the-problem-7">The Problem</a></h2>
<p>Applications often have multiple storage areas for different purposes:</p>
<ul>
<li>🌐 Web assets (CSS, JS, images)</li>
<li>📁 User uploads (documents, photos)</li>
<li>⚙️ Configuration files</li>
<li>🔒 Sensitive data (keys, tokens)</li>
</ul>
<p><strong>Without type safety</strong>, you might accidentally:</p>
<ul>
<li>❌ Serve a user's private document as a web asset</li>
<li>❌ Write config data to the uploads directory</li>
<li>❌ Read a sensitive key file when expecting a CSS file</li>
</ul>
<h2 id="the-solution-5"><a class="header" href="#the-solution-5">The Solution</a></h2>
<p>Use marker types with <code>StrictPath&lt;Marker&gt;</code> and <code>VirtualPath&lt;Marker&gt;</code> to encode context at the type level. The compiler prevents context mixing.</p>
<h2 id="complete-example-5"><a class="header" href="#complete-example-5">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, VirtualRoot, VirtualPath};

// Define marker types for different contexts
struct WebAssets;    // CSS, JS, images
struct UserFiles;    // Uploaded documents
struct ConfigData;   // Application configuration

// Functions enforce context via type system
fn serve_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, std::io::Error&gt; {
    path.read()
}

fn process_upload(path: &amp;StrictPath&lt;UserFiles&gt;) -&gt; Result&lt;(), std::io::Error&gt; {
    // Process user-uploaded file
    let content = path.read_to_string()?;
    println!("Processing user file: {} bytes", content.len());
    Ok(())
}

fn load_config(path: &amp;StrictPath&lt;ConfigData&gt;) -&gt; Result&lt;String, std::io::Error&gt; {
    path.read_to_string()
}

fn example_type_safety() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create context-specific boundaries
    let assets_root: VirtualRoot&lt;WebAssets&gt; = VirtualRoot::try_new("public")?;
    let uploads_root: VirtualRoot&lt;UserFiles&gt; = VirtualRoot::try_new("uploads")?;
    let config_boundary: PathBoundary&lt;ConfigData&gt; = PathBoundary::try_new("config")?;

    // Create paths with proper contexts
    let css: VirtualPath&lt;WebAssets&gt; = assets_root.virtual_join("app.css")?;
    let doc: VirtualPath&lt;UserFiles&gt; = uploads_root.virtual_join("report.pdf")?;
    let cfg: StrictPath&lt;ConfigData&gt; = config_boundary.strict_join("app.toml")?;

    // Type system prevents context mixing
    serve_asset(css.as_unvirtual())?;         // ✅ Correct context
    process_upload(doc.as_unvirtual())?;      // ✅ Correct context  
    load_config(&amp;cfg)?;                       // ✅ Correct context

    // These would be compile errors:
    // serve_asset(doc.as_unvirtual())?;      // ❌ Compile error - wrong context!
    // process_upload(css.as_unvirtual())?;   // ❌ Compile error - wrong context!
    // load_config(css.as_unvirtual())?;      // ❌ Compile error - wrong context!

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-benefits"><a class="header" href="#key-benefits">Key Benefits</a></h2>
<h3 id="1-compile-time-safety"><a class="header" href="#1-compile-time-safety">1. Compile-Time Safety</a></h3>
<p>The compiler catches context mixing errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let css: VirtualPath&lt;WebAssets&gt; = assets_root.virtual_join("app.css")?;
let doc: VirtualPath&lt;UserFiles&gt; = uploads_root.virtual_join("report.pdf")?;

serve_asset(css.as_unvirtual())?;  // ✅ OK
serve_asset(doc.as_unvirtual())?;  // ❌ Compile error!
//          ^^^ expected WebAssets, found UserFiles
<span class="boring">}</span></code></pre></pre>
<h3 id="2-clear-interfaces"><a class="header" href="#2-clear-interfaces">2. Clear Interfaces</a></h3>
<p>Function signatures document what they accept:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This function ONLY accepts web assets
fn serve_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, std::io::Error&gt; {
    // No need to check if this is the right type of file
    // The type system guarantees it
    path.read()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-refactoring-safety"><a class="header" href="#3-refactoring-safety">3. Refactoring Safety</a></h3>
<p>If you change a function's context requirement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Change signature from WebAssets to ConfigData
fn serve_asset(path: &amp;StrictPath&lt;ConfigData&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, std::io::Error&gt; {
    path.read()
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler finds all call sites that need updating. Zero-cost migration!</p>
<h3 id="4-team-collaboration"><a class="header" href="#4-team-collaboration">4. Team Collaboration</a></h3>
<p>New developers can't make context mixing mistakes - the compiler teaches them the correct patterns.</p>
<h2 id="real-world-pattern-multi-context-web-server"><a class="header" href="#real-world-pattern-multi-context-web-server">Real-World Pattern: Multi-Context Web Server</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath, VirtualRoot, VirtualPath};

struct WebAssets;
struct UserUploads;
struct ServerConfig;

struct WebServer {
    assets: VirtualRoot&lt;WebAssets&gt;,
    uploads: VirtualRoot&lt;UserUploads&gt;,
    config: PathBoundary&lt;ServerConfig&gt;,
}

impl WebServer {
    fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        Ok(Self {
            assets: VirtualRoot::try_new("public")?,
            uploads: VirtualRoot::try_new("uploads")?,
            config: PathBoundary::try_new("config")?,
        })
    }
    
    // This can ONLY serve web assets
    fn serve_static_file(&amp;self, path: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let asset: VirtualPath&lt;WebAssets&gt; = self.assets.virtual_join(path)?;
        Ok(self.read_asset(asset.as_unvirtual())?)
    }
    
    // Helper enforces WebAssets context
    fn read_asset(&amp;self, path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
        path.read()
    }
    
    // This can ONLY handle user uploads
    fn save_upload(&amp;self, filename: &amp;str, content: &amp;[u8]) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        let upload: VirtualPath&lt;UserUploads&gt; = self.uploads.virtual_join(filename)?;
        self.write_upload(upload.as_unvirtual(), content)?;
        Ok(())
    }
    
    // Helper enforces UserUploads context
    fn write_upload(&amp;self, path: &amp;StrictPath&lt;UserUploads&gt;, content: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
        path.create_parent_dir_all()?;
        path.write(content)
    }
    
    // This can ONLY read config files
    fn load_config(&amp;self, name: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let cfg: StrictPath&lt;ServerConfig&gt; = self.config.strict_join(name)?;
        Ok(self.read_config(&amp;cfg)?)
    }
    
    // Helper enforces ServerConfig context
    fn read_config(&amp;self, path: &amp;StrictPath&lt;ServerConfig&gt;) -&gt; std::io::Result&lt;String&gt; {
        path.read_to_string()
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let server = WebServer::new()?;
    
    // Each method can only access its designated context
    let css = server.serve_static_file("app.css")?;
    server.save_upload("document.pdf", b"PDF content")?;
    let config = server.load_config("server.toml")?;
    
    // These would be impossible to mess up due to type safety:
    // - Can't serve an upload as a static file
    // - Can't save a config as an upload
    // - Can't read an asset as config
    
    Ok(())
}</code></pre></pre>
<h2 id="advanced-permission-markers"><a class="header" href="#advanced-permission-markers">Advanced: Permission Markers</a></h2>
<p>Combine resource markers with permission markers using tuples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Resource markers
struct Documents;
struct DatabaseFiles;

// Permission markers
struct ReadOnly;
struct ReadWrite;

// Type-safe permission enforcement
fn read_document(path: &amp;StrictPath&lt;(Documents, ReadOnly)&gt;) -&gt; std::io::Result&lt;String&gt; {
    path.read_to_string()
}

fn write_document(
    path: &amp;StrictPath&lt;(Documents, ReadWrite)&gt;,
    content: &amp;str,
) -&gt; std::io::Result&lt;()&gt; {
    path.write(content)
}

fn backup_database(
    source: &amp;StrictPath&lt;(DatabaseFiles, ReadOnly)&gt;,
    dest: &amp;StrictPath&lt;(DatabaseFiles, ReadWrite)&gt;,
) -&gt; std::io::Result&lt;()&gt; {
    let data = source.read()?;
    dest.write(&amp;data)
}

fn example_permissions() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let docs_ro: PathBoundary&lt;(Documents, ReadOnly)&gt; = 
        PathBoundary::try_new("documents")?;
    let docs_rw: PathBoundary&lt;(Documents, ReadWrite)&gt; = 
        PathBoundary::try_new("documents")?;
    
    let file_ro = docs_ro.strict_join("report.txt")?;
    let file_rw = docs_rw.strict_join("report.txt")?;
    
    // Can read from read-only
    read_document(&amp;file_ro)?;
    
    // Can't write to read-only - compile error!
    // write_document(&amp;file_ro, "new content")?;  // ❌ Compile error!
    
    // Can write to read-write
    write_document(&amp;file_rw, "new content")?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-authorization-markers"><a class="header" href="#advanced-authorization-markers">Advanced: Authorization Markers</a></h2>
<p>Use <code>change_marker()</code> after authorization checks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

struct UserFiles;
struct ReadOnly;
struct ReadWrite;

fn authenticate_and_upgrade(
    path: StrictPath&lt;(UserFiles, ReadOnly)&gt;,
    user_has_write_access: bool,
) -&gt; Result&lt;StrictPath&lt;(UserFiles, ReadWrite)&gt;, &amp;'static str&gt; {
    if user_has_write_access {
        // Authorization succeeded - change marker to encode permission
        Ok(path.change_marker())
    } else {
        Err("Access denied")
    }
}

fn write_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;, content: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    path.write(content)
}

// Usage:
let boundary: PathBoundary&lt;(UserFiles, ReadOnly)&gt; = 
    PathBoundary::try_new("uploads")?;
let file_ro = boundary.strict_join("document.txt")?;

// Can't write yet - read-only marker
// write_file(&amp;file_ro, b"data")?;  // ❌ Compile error!

// After authorization, upgrade to read-write
if let Ok(file_rw) = authenticate_and_upgrade(file_ro, check_permissions()) {
    write_file(&amp;file_rw, b"data")?;  // ✅ Now allowed
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="examples/../authorization_security.html">Authorization &amp; Permissions</a> chapter for more details.</p>
<h2 id="shared-logic-across-contexts"><a class="header" href="#shared-logic-across-contexts">Shared Logic Across Contexts</a></h2>
<p>Use generics when logic applies to any context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generic over marker type - works with any context
fn get_file_size&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; std::io::Result&lt;u64&gt; {
    path.metadata().map(|m| m.len())
}

// Works with any marker
let asset_size = get_file_size(&amp;css_file)?;
let upload_size = get_file_size(&amp;upload_file)?;
let config_size = get_file_size(&amp;config_file)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="1-name-markers-after-resources"><a class="header" href="#1-name-markers-after-resources">1. Name Markers After Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserDocuments;   // ✅ Clear
struct Documents;       // ⚠️  Which documents?
struct MyMarker;        // ❌ Meaningless
<span class="boring">}</span></code></pre></pre>
<h3 id="2-use-tuples-for-multi-dimensional-context"><a class="header" href="#2-use-tuples-for-multi-dimensional-context">2. Use Tuples for Multi-Dimensional Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StrictPath&lt;(ResourceType, PermissionLevel)&gt;
StrictPath&lt;(UserFiles, ReadWrite)&gt;
<span class="boring">}</span></code></pre></pre>
<h3 id="3-keep-markers-simple"><a class="header" href="#3-keep-markers-simple">3. Keep Markers Simple</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Simple, zero-size
struct WebAssets;

// ❌ Don't add fields
struct WebAssets {
    size_limit: usize,  // Wrong - use runtime checks
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-document-marker-meaning"><a class="header" href="#4-document-marker-meaning">4. Document Marker Meaning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Marker for publicly-accessible web assets
/// (CSS, JavaScript, images, fonts)
struct WebAssets;

/// Marker for user-uploaded files
/// (documents, photos, videos)
struct UserUploads;
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-tips-4"><a class="header" href="#integration-tips-4">Integration Tips</a></h2>
<h3 id="with-web-frameworks-2"><a class="header" href="#with-web-frameworks-2">With Web Frameworks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Axum route handlers
async fn serve_asset(
    Path(asset_path): Path&lt;String&gt;,
) -&gt; Result&lt;Vec&lt;u8&gt;, StatusCode&gt; {
    let assets: VirtualRoot&lt;WebAssets&gt; = get_assets_root();
    let asset = assets.virtual_join(&amp;asset_path)
        .map_err(|_| StatusCode::BAD_REQUEST)?;
    
    read_asset(asset.as_unvirtual())
        .map_err(|_| StatusCode::NOT_FOUND)
}

fn read_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    path.read()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-async-runtimes-1"><a class="header" href="#with-async-runtimes-1">With Async Runtimes</a></h3>
<p>Type safety works with async code too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn read_asset_async(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    tokio::fs::read(path.interop_path()).await
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="pattern-1-service-with-multiple-contexts"><a class="header" href="#pattern-1-service-with-multiple-contexts">Pattern 1: Service with Multiple Contexts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AppService {
    assets: VirtualRoot&lt;WebAssets&gt;,
    uploads: VirtualRoot&lt;UserFiles&gt;,
    config: PathBoundary&lt;ConfigData&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-generic-helpers"><a class="header" href="#pattern-2-generic-helpers">Pattern 2: Generic Helpers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exists&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; bool {
    path.exists()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-marker-transformation"><a class="header" href="#pattern-3-marker-transformation">Pattern 3: Marker Transformation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn authorize&lt;R&gt;(
    path: StrictPath&lt;(R, ReadOnly)&gt;,
) -&gt; Result&lt;StrictPath&lt;(R, ReadWrite)&gt;, Error&gt; {
    // Check permissions...
    Ok(path.change_marker())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li>See <a href="examples/../authorization_security.html">Authorization &amp; Permissions</a> for advanced marker patterns</li>
<li>See <a href="examples/./web_upload_service.html">Web Upload Service</a> for practical multi-context usage</li>
<li>See <a href="examples/../tutorial/stage3_markers.html">Tutorial Stage 3</a> for marker basics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="axum-web-service-tutorial"><a class="header" href="#axum-web-service-tutorial">Axum Web Service Tutorial</a></h1>
<p>This tutorial demonstrates <strong>key security patterns</strong> for web services using <strong>Axum</strong> and <strong>strict-path</strong>. We focus on the essential integration points where path validation prevents vulnerabilities.</p>
<h2 id="what-youll-learn-1"><a class="header" href="#what-youll-learn-1">What You'll Learn</a></h2>
<p>How to integrate <code>strict-path</code> into an Axum web service:</p>
<ul>
<li><strong>Static file serving</strong> with <code>PathBoundary</code> to prevent directory traversal</li>
<li><strong>Per-user file storage</strong> with <code>VirtualRoot</code> for user isolation</li>
<li><strong>Type-safe contexts</strong> with marker types to prevent mixing boundaries</li>
</ul>
<h2 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h2>
<p>Without <code>strict-path</code>, common mistakes lead to vulnerabilities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ UNSAFE: User can access any file
let file_path = format!("./uploads/{}", user_input);
std::fs::read_to_string(file_path)?

// ✅ SAFE: Validated path, guaranteed within boundary
let file = uploads_root.virtual_join(user_input)?;
file.read_to_string()?
<span class="boring">}</span></code></pre></pre>
<h2 id="tutorial-structure"><a class="header" href="#tutorial-structure">Tutorial Structure</a></h2>
<p>Short, focused chapters showing essential patterns:</p>
<h3 id="chapter-1-project-setup"><a class="header" href="#chapter-1-project-setup"><a href="axum_tutorial/./chapter1_setup.html">Chapter 1: Project Setup</a></a></h3>
<p>Basic project structure, marker types, and boundary initialization.</p>
<h3 id="chapter-2-static-assets"><a class="header" href="#chapter-2-static-assets"><a href="axum_tutorial/./chapter2_static_assets.html">Chapter 2: Static Assets</a></a></h3>
<p>Serve static files safely with <code>StrictPath&lt;WebAssets&gt;</code>.</p>
<h3 id="chapter-3-per-user-storage"><a class="header" href="#chapter-3-per-user-storage"><a href="axum_tutorial/./chapter3_user_storage.html">Chapter 3: Per-User Storage</a></a></h3>
<p>Isolate user files with <code>VirtualRoot&lt;UserUploads&gt;</code>.</p>
<h3 id="chapter-3-user-authentication"><a class="header" href="#chapter-3-user-authentication"><a href="axum_tutorial/./chapter3_authentication.html">Chapter 3: User Authentication</a></a></h3>
<p>Add user authentication and create per-user storage isolation.</p>
<p><strong>What you'll learn:</strong></p>
<ul>
<li>Simple session-based authentication</li>
<li>Creating VirtualRoot per user</li>
<li>Authorization markers with change_marker()</li>
<li>Protecting routes with middleware</li>
</ul>
<h3 id="chapter-4-file-upload-system"><a class="header" href="#chapter-4-file-upload-system"><a href="axum_tutorial/./chapter4_uploads.html">Chapter 4: File Upload System</a></a></h3>
<p>Build a secure file upload system with per-user isolation.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><strong>Rust</strong>: 1.71.0 or later</li>
<li><strong>Basic Axum knowledge</strong>: Understanding handlers and state</li>
</ul>
<hr />
<p><strong>Ready to start?</strong> → <a href="axum_tutorial/./chapter1_setup.html">Chapter 1: Project Setup</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-project-setup-1"><a class="header" href="#chapter-1-project-setup-1">Chapter 1: Project Setup</a></h1>
<p>Let's set up our Axum web service with proper security boundaries from the start. We'll create the project structure, define our marker types, and establish path boundaries for different storage areas.</p>
<h2 id="create-the-project"><a class="header" href="#create-the-project">Create the Project</a></h2>
<pre><code class="language-bash">cargo new file-sharing-service
cd file-sharing-service
</code></pre>
<h2 id="add-dependencies"><a class="header" href="#add-dependencies">Add Dependencies</a></h2>
<p>Update your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "file-sharing-service"
version = "0.1.0"
edition = "2021"

[dependencies]
# Web framework
axum = "0.7"
tokio = { version = "1", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["fs", "trace"] }

# Security and paths
strict-path = { version = "0.1", features = ["serde"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Utilities
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
</code></pre>
<h2 id="define-security-boundaries"><a class="header" href="#define-security-boundaries">Define Security Boundaries</a></h2>
<p>Create <code>src/markers.rs</code> - this is where we define our type-safe contexts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Type-safe markers for different storage contexts.
//! 
//! These zero-cost markers prevent accidentally mixing different
//! types of files (e.g., serving user uploads as web assets).

/// Public web assets (CSS, JavaScript, images, fonts)
/// 
/// Files with this marker can be served to anyone without authentication.
pub struct WebAssets;

/// User-uploaded files (documents, photos, videos)
/// 
/// Each user has their own isolated VirtualRoot with this marker.
/// Files are private and require authentication to access.
pub struct UserUploads;

/// Application configuration files
/// 
/// Server configuration, secrets, and settings.
/// Never exposed to users.
pub struct AppConfig;

/// Read-only permission marker
pub struct ReadOnly;

/// Read-write permission marker  
pub struct ReadWrite;
<span class="boring">}</span></code></pre></pre>
<h2 id="application-state"><a class="header" href="#application-state">Application State</a></h2>
<p>Create <code>src/state.rs</code> - this holds our path boundaries and user sessions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, VirtualRoot};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

use crate::markers::{WebAssets, UserUploads, AppConfig};

/// Shared application state passed to all route handlers
#[derive(Clone)]
pub struct AppState {
    /// Path boundary for public web assets
    pub assets: Arc&lt;PathBoundary&lt;WebAssets&gt;&gt;,
    
    /// Path boundary for server configuration
    pub config: Arc&lt;PathBoundary&lt;AppConfig&gt;&gt;,
    
    /// Per-user upload roots (user_id -&gt; VirtualRoot)
    pub user_uploads: Arc&lt;RwLock&lt;HashMap&lt;Uuid, VirtualRoot&lt;UserUploads&gt;&gt;&gt;&gt;,
    
    /// Active user sessions (session_id -&gt; user_id)
    pub sessions: Arc&lt;RwLock&lt;HashMap&lt;String, Uuid&gt;&gt;&gt;,
}

impl AppState {
    /// Create new application state with initialized boundaries
    pub fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Create boundary for public assets
        let assets = PathBoundary::try_new_create("public")?;
        
        // Create boundary for config files
        let config = PathBoundary::try_new_create("config")?;
        
        Ok(Self {
            assets: Arc::new(assets),
            config: Arc::new(config),
            user_uploads: Arc::new(RwLock::new(HashMap::new())),
            sessions: Arc::new(RwLock::new(HashMap::new())),
        })
    }
    
    /// Get or create a VirtualRoot for a specific user
    pub async fn get_user_uploads(
        &amp;self,
        user_id: Uuid,
    ) -&gt; Result&lt;VirtualRoot&lt;UserUploads&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut uploads = self.user_uploads.write().await;
        
        if let Some(vroot) = uploads.get(&amp;user_id) {
            // Return existing user root
            Ok(vroot.clone())
        } else {
            // Create new isolated storage for this user
            let user_dir = format!("uploads/user_{}", user_id);
            let vroot = VirtualRoot::try_new_create(&amp;user_dir)?;
            uploads.insert(user_id, vroot.clone());
            
            tracing::info!("Created upload directory for user {}", user_id);
            Ok(vroot)
        }
    }
    
    /// Create a new user session
    pub async fn create_session(&amp;self, user_id: Uuid) -&gt; String {
        let session_id = Uuid::new_v4().to_string();
        self.sessions.write().await.insert(session_id.clone(), user_id);
        session_id
    }
    
    /// Get user ID from session ID
    pub async fn get_user_from_session(&amp;self, session_id: &amp;str) -&gt; Option&lt;Uuid&gt; {
        self.sessions.read().await.get(session_id).copied()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="main-server-setup"><a class="header" href="#main-server-setup">Main Server Setup</a></h2>
<p>Update <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use axum::{
    Router,
    routing::get,
};
use std::net::SocketAddr;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod markers;
mod state;

use state::AppState;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize tracing
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "file_sharing_service=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    // Initialize application state with security boundaries
    let state = AppState::new()?;
    
    tracing::info!("🔒 Security boundaries initialized:");
    tracing::info!("  - Public assets: {}", state.assets.strictpath_display());
    tracing::info!("  - Config files: {}", state.config.strictpath_display());
    tracing::info!("  - User uploads: uploads/user_&lt;uuid&gt;/");

    // Build our application with routes
    let app = Router::new()
        .route("/", get(root_handler))
        .route("/health", get(health_check))
        .layer(TraceLayer::new_for_http())
        .with_state(state);

    // Run the server
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    tracing::info!("🚀 Server listening on {}", addr);
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}

async fn root_handler() -&gt; &amp;'static str {
    "File Sharing Service - Use /health to check status"
}

async fn health_check() -&gt; &amp;'static str {
    "OK"
}</code></pre></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>Create the initial directory structure:</p>
<pre><code class="language-bash">mkdir -p public/{css,js,images}
mkdir -p config
mkdir -p src/routes
mkdir -p src/middleware
</code></pre>
<p>Create a sample HTML file in <code>public/index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;File Sharing Service&lt;/title&gt;
    &lt;link rel="stylesheet" href="/assets/css/style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;🔐 Secure File Sharing Service&lt;/h1&gt;
    &lt;p&gt;Protected by strict-path security boundaries.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Create <code>public/css/style.css</code>:</p>
<pre><code class="language-css">body {
    font-family: system-ui, -apple-system, sans-serif;
    max-width: 800px;
    margin: 2rem auto;
    padding: 0 1rem;
    background: #f5f5f5;
}

h1 {
    color: #2c3e50;
}
</code></pre>
<h2 id="test-the-server"><a class="header" href="#test-the-server">Test the Server</a></h2>
<p>Run the server:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see:</p>
<pre><code>🔒 Security boundaries initialized:
  - Public assets: public
  - Config files: config
  - User uploads: uploads/user_&lt;uuid&gt;/
🚀 Server listening on 127.0.0.1:3000
</code></pre>
<p>Visit <code>http://localhost:3000/health</code> - you should see "OK".</p>
<h2 id="understanding-the-security-model"><a class="header" href="#understanding-the-security-model">Understanding the Security Model</a></h2>
<p>Let's examine what we've built:</p>
<h3 id="1-separate-boundaries-for-each-context"><a class="header" href="#1-separate-boundaries-for-each-context">1. Separate Boundaries for Each Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub assets: Arc&lt;PathBoundary&lt;WebAssets&gt;&gt;,
pub config: Arc&lt;PathBoundary&lt;AppConfig&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>Each storage area has its own <code>PathBoundary</code> with a different marker type. This means:</p>
<ul>
<li>✅ You <strong>cannot</strong> accidentally serve config files as web assets</li>
<li>✅ You <strong>cannot</strong> write user uploads to the config directory</li>
<li>✅ The compiler <strong>enforces</strong> these boundaries</li>
</ul>
<h3 id="2-per-user-isolated-storage"><a class="header" href="#2-per-user-isolated-storage">2. Per-User Isolated Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub user_uploads: Arc&lt;RwLock&lt;HashMap&lt;Uuid, VirtualRoot&lt;UserUploads&gt;&gt;&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>Each user gets their own <code>VirtualRoot</code>:</p>
<ul>
<li>✅ User A <strong>cannot</strong> access User B's files</li>
<li>✅ Path traversal attacks (<code>../other-user/file.txt</code>) are automatically blocked</li>
<li>✅ Each user sees clean paths starting from <code>/</code></li>
</ul>
<h3 id="3-type-safe-state"><a class="header" href="#3-type-safe-state">3. Type-Safe State</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn get_user_uploads(
    &amp;self,
    user_id: Uuid,
) -&gt; Result&lt;VirtualRoot&lt;UserUploads&gt;, Box&lt;dyn std::error::Error&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p>Functions return typed paths:</p>
<ul>
<li>✅ You know exactly what type of storage you're working with</li>
<li>✅ Can't mix user uploads with web assets</li>
<li>✅ Refactoring is safe - compiler finds all usages</li>
</ul>
<h2 id="whats-next-7"><a class="header" href="#whats-next-7">What's Next?</a></h2>
<p>Now that we have our security boundaries established, we'll implement:</p>
<ol>
<li><strong><a href="axum_tutorial/./chapter2_static_assets.html">Chapter 2: Static Asset Serving</a></strong> - Serve CSS, JS, and images safely</li>
<li>User authentication and session management</li>
<li>File upload system with per-user isolation</li>
<li>File download and listing with authorization</li>
<li>Configuration management and deployment</li>
</ol>
<h2 id="key-takeaways-6"><a class="header" href="#key-takeaways-6">Key Takeaways</a></h2>
<p>✅ <strong>Separate boundaries</strong> - One <code>PathBoundary</code> per storage context<br />
✅ <strong>Type-safe markers</strong> - Compiler prevents context mixing<br />
✅ <strong>Per-user isolation</strong> - <code>VirtualRoot</code> for each user<br />
✅ <strong>Lazy initialization</strong> - User storage created on first access<br />
✅ <strong>Shared state</strong> - <code>Arc&lt;RwLock&lt;&gt;&gt;</code> for thread-safe access</p>
<hr />
<p><strong>Next:</strong> <a href="axum_tutorial/./chapter2_static_assets.html">Chapter 2: Static Asset Serving →</a></p>
<p><strong>Navigation:</strong><br />
← <a href="axum_tutorial/./overview.html">Tutorial Overview</a> | <a href="axum_tutorial/./chapter2_static_assets.html">Chapter 2 →</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-static-asset-serving"><a class="header" href="#chapter-2-static-asset-serving">Chapter 2: Static Asset Serving</a></h1>
<p>Now that we have our security boundaries established, let's implement secure static file serving. We'll serve CSS, JavaScript, and images while preventing path traversal attacks.</p>
<h2 id="the-security-challenge"><a class="header" href="#the-security-challenge">The Security Challenge</a></h2>
<p>Static file servers are a common attack vector:</p>
<ul>
<li>❌ <code>GET /assets/../config/secrets.json</code> - Try to escape to config</li>
<li>❌ <code>GET /assets/../../etc/passwd</code> - Try to access system files</li>
<li>❌ <code>GET /assets/../uploads/user_123/private.pdf</code> - Try to access user files</li>
</ul>
<p>With strict-path, these attacks are <strong>impossible</strong> because the type system enforces boundaries.</p>
<h2 id="create-the-assets-route-handler"><a class="header" href="#create-the-assets-route-handler">Create the Assets Route Handler</a></h2>
<p>Create <code>src/routes/assets.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    extract::{Path, State},
    http::{StatusCode, header},
    response::{IntoResponse, Response},
};
use strict_path::StrictPath;
use crate::markers::WebAssets;
use crate::state::AppState;

/// Serve a static asset file
/// 
/// Security: The PathBoundary&lt;WebAssets&gt; ensures files can ONLY
/// come from the public/ directory. Path traversal attacks are
/// automatically blocked by strict_join().
pub async fn serve_asset(
    State(state): State&lt;AppState&gt;,
    Path(asset_path): Path&lt;String&gt;,
) -&gt; Result&lt;Response, AppError&gt; {
    // Validate the requested path against the assets boundary
    // This is where security happens - strict_join() prevents escapes
    let safe_path: StrictPath&lt;WebAssets&gt; = state.assets
        .strict_join(&amp;asset_path)
        .map_err(|e| {
            tracing::warn!("❌ Blocked path traversal attempt: {}", asset_path);
            AppError::PathTraversal(e.to_string())
        })?;
    
    // Check if file exists
    if !safe_path.exists() {
        tracing::debug!("Asset not found: {}", asset_path);
        return Err(AppError::NotFound);
    }
    
    // Check if it's actually a file (not a directory)
    if !safe_path.is_file() {
        tracing::warn!("Attempted to serve directory as file: {}", asset_path);
        return Err(AppError::NotFound);
    }
    
    // Read the file - safe because path is validated
    let content = read_asset(&amp;safe_path).await?;
    
    // Determine content type from extension
    let content_type = get_content_type(&amp;safe_path);
    
    tracing::debug!("✅ Serving asset: {} ({})", asset_path, content_type);
    
    // Build response with appropriate content-type
    Ok((
        StatusCode::OK,
        [(header::CONTENT_TYPE, content_type)],
        content,
    ).into_response())
}

/// Read asset file - helper enforces WebAssets context
async fn read_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, AppError&gt; {
    tokio::fs::read(path.interop_path())
        .await
        .map_err(|e| AppError::IoError(e.to_string()))
}

/// Determine content-type from file extension
fn get_content_type(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; &amp;'static str {
    match path.strictpath_extension().and_then(|s| s.to_str()) {
        Some("html") =&gt; "text/html; charset=utf-8",
        Some("css") =&gt; "text/css; charset=utf-8",
        Some("js") =&gt; "application/javascript; charset=utf-8",
        Some("json") =&gt; "application/json",
        Some("png") =&gt; "image/png",
        Some("jpg") | Some("jpeg") =&gt; "image/jpeg",
        Some("gif") =&gt; "image/gif",
        Some("svg") =&gt; "image/svg+xml",
        Some("ico") =&gt; "image/x-icon",
        Some("woff") =&gt; "font/woff",
        Some("woff2") =&gt; "font/woff2",
        Some("ttf") =&gt; "font/ttf",
        Some("txt") =&gt; "text/plain; charset=utf-8",
        _ =&gt; "application/octet-stream",
    }
}

/// Application errors with appropriate HTTP status codes
#[derive(Debug)]
pub enum AppError {
    PathTraversal(String),
    NotFound,
    IoError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -&gt; Response {
        let (status, message) = match self {
            AppError::PathTraversal(msg) =&gt; {
                (StatusCode::BAD_REQUEST, format!("Invalid path: {}", msg))
            }
            AppError::NotFound =&gt; {
                (StatusCode::NOT_FOUND, "File not found".to_string())
            }
            AppError::IoError(msg) =&gt; {
                (StatusCode::INTERNAL_SERVER_ERROR, format!("IO error: {}", msg))
            }
        };
        
        (status, message).into_response()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="update-main-router"><a class="header" href="#update-main-router">Update Main Router</a></h2>
<p>Update <code>src/main.rs</code> to include the assets route:</p>
<pre><pre class="playground"><code class="language-rust">use axum::{
    Router,
    routing::get,
};
use std::net::SocketAddr;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod markers;
mod state;
mod routes;

use state::AppState;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize tracing
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "file_sharing_service=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    // Initialize application state with security boundaries
    let state = AppState::new()?;
    
    tracing::info!("🔒 Security boundaries initialized:");
    tracing::info!("  - Public assets: {}", state.assets.strictpath_display());
    tracing::info!("  - Config files: {}", state.config.strictpath_display());

    // Build our application with routes
    let app = Router::new()
        .route("/", get(root_handler))
        .route("/health", get(health_check))
        // Serve static assets - path parameter is validated by strict_join()
        .route("/assets/*path", get(routes::assets::serve_asset))
        .layer(TraceLayer::new_for_http())
        .with_state(state);

    // Run the server
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    tracing::info!("🚀 Server listening on {}", addr);
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}

async fn root_handler() -&gt; &amp;'static str {
    "File Sharing Service - Use /health to check status"
}

async fn health_check() -&gt; &amp;'static str {
    "OK"
}</code></pre></pre>
<p>Create <code>src/routes/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod assets;
<span class="boring">}</span></code></pre></pre>
<h2 id="test-asset-serving"><a class="header" href="#test-asset-serving">Test Asset Serving</a></h2>
<p>Run the server:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="test-valid-paths"><a class="header" href="#test-valid-paths">Test Valid Paths</a></h3>
<pre><code class="language-bash"># Should work - file exists in public/
curl http://localhost:3000/assets/css/style.css

# Should work - subdirectory access
curl http://localhost:3000/assets/images/logo.png
</code></pre>
<h3 id="test-attack-scenarios"><a class="header" href="#test-attack-scenarios">Test Attack Scenarios</a></h3>
<pre><code class="language-bash"># ❌ Try to escape to parent directory
curl http://localhost:3000/assets/../config/secrets.json
# Response: 400 Bad Request - "Invalid path: ..."

# ❌ Try to access system files
curl http://localhost:3000/assets/../../etc/passwd
# Response: 400 Bad Request - "Invalid path: ..."

# ❌ Try to access user uploads
curl http://localhost:3000/assets/../uploads/user_123/file.txt
# Response: 400 Bad Request - "Invalid path: ..."

# ❌ Try absolute path
curl http://localhost:3000/assets//var/log/system.log
# Response: 400 Bad Request - "Invalid path: ..."
</code></pre>
<p>All attacks are automatically blocked! 🎉</p>
<h2 id="understanding-the-security"><a class="header" href="#understanding-the-security">Understanding the Security</a></h2>
<h3 id="1-validation-happens-at-the-boundary"><a class="header" href="#1-validation-happens-at-the-boundary">1. Validation Happens at the Boundary</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let safe_path: StrictPath&lt;WebAssets&gt; = state.assets
    .strict_join(&amp;asset_path)
    .map_err(|e| {
        tracing::warn!("❌ Blocked path traversal attempt: {}", asset_path);
        AppError::PathTraversal(e.to_string())
    })?;
<span class="boring">}</span></code></pre></pre>
<p>This single line provides complete protection:</p>
<ul>
<li><code>strict_join()</code> normalizes the path (resolves <code>..</code>, <code>.</code>, etc.)</li>
<li>Checks if the result is within the <code>public/</code> boundary</li>
<li>Returns an error if the path escapes</li>
</ul>
<h3 id="2-type-safe-helpers"><a class="header" href="#2-type-safe-helpers">2. Type-Safe Helpers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn read_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, AppError&gt; {
    tokio::fs::read(path.interop_path()).await
        .map_err(|e| AppError::IoError(e.to_string()))
}
<span class="boring">}</span></code></pre></pre>
<p>By accepting <code>&amp;StrictPath&lt;WebAssets&gt;</code>, this function:</p>
<ul>
<li>✅ Only accepts validated asset paths</li>
<li>✅ Cannot be called with user uploads or config files</li>
<li>✅ Compiler enforces the security contract</li>
</ul>
<h3 id="3-content-type-based-on-extension"><a class="header" href="#3-content-type-based-on-extension">3. Content-Type Based on Extension</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_content_type(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; &amp;'static str {
    match path.strictpath_extension().and_then(|s| s.to_str()) {
        Some("css") =&gt; "text/css; charset=utf-8",
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We safely use the validated path to determine content-type. No risk of path manipulation here.</p>
<h2 id="why-this-is-better-than-standard-approaches"><a class="header" href="#why-this-is-better-than-standard-approaches">Why This Is Better Than Standard Approaches</a></h2>
<h3 id="-unsafe-string-based-validation"><a class="header" href="#-unsafe-string-based-validation">❌ Unsafe: String-Based Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Don't do this!
async fn serve_asset_unsafe(Path(asset_path): Path&lt;String&gt;) -&gt; Response {
    // Manual validation - easy to get wrong
    if asset_path.contains("..") {
        return (StatusCode::BAD_REQUEST, "Invalid path").into_response();
    }
    
    // Still vulnerable to attacks like:
    // - Encoded paths (%2e%2e%2f)
    // - Symlinks
    // - Case sensitivity issues on Windows
    
    let full_path = format!("public/{}", asset_path);
    let content = tokio::fs::read(&amp;full_path).await.unwrap();
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-safe-type-based-validation"><a class="header" href="#-safe-type-based-validation">✅ Safe: Type-Based Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Do this!
let safe_path: StrictPath&lt;WebAssets&gt; = state.assets.strict_join(&amp;asset_path)?;
let content = read_asset(&amp;safe_path).await?;
<span class="boring">}</span></code></pre></pre>
<p>Strict-path handles:</p>
<ul>
<li>✅ Path normalization (<code>.</code>, <code>..</code>, multiple <code>/</code>)</li>
<li>✅ Symlink resolution</li>
<li>✅ Encoding issues</li>
<li>✅ Case sensitivity</li>
<li>✅ Platform differences</li>
</ul>
<h2 id="adding-more-assets"><a class="header" href="#adding-more-assets">Adding More Assets</a></h2>
<p>Create some sample files to serve:</p>
<pre><code class="language-bash"># Create a JavaScript file
cat &gt; public/js/app.js &lt;&lt; 'EOF'
console.log('File sharing service initialized');
document.addEventListener('DOMContentLoaded', () =&gt; {
    console.log('DOM loaded - ready to upload files');
});
EOF

# Create an image (placeholder)
echo "Sample image data" &gt; public/images/logo.png

# Create a robots.txt
cat &gt; public/robots.txt &lt;&lt; 'EOF'
User-agent: *
Disallow: /uploads/
EOF
</code></pre>
<p>Test them:</p>
<pre><code class="language-bash">curl http://localhost:3000/assets/js/app.js
curl http://localhost:3000/assets/robots.txt
</code></pre>
<h2 id="handling-index-files"><a class="header" href="#handling-index-files">Handling Index Files</a></h2>
<p>Want to serve <code>index.html</code> when accessing <code>/assets/</code>? Update the route handler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn serve_asset(
    State(state): State&lt;AppState&gt;,
    Path(asset_path): Path&lt;String&gt;,
) -&gt; Result&lt;Response, AppError&gt; {
    // If path ends with /, append index.html
    let request_path = if asset_path.ends_with('/') || asset_path.is_empty() {
        format!("{}index.html", asset_path)
    } else {
        asset_path
    };
    
    let safe_path: StrictPath&lt;WebAssets&gt; = state.assets
        .strict_join(&amp;request_path)
        .map_err(|e| {
            tracing::warn!("❌ Blocked path traversal attempt: {}", request_path);
            AppError::PathTraversal(e.to_string())
        })?;
    
    // ... rest of the function
}
<span class="boring">}</span></code></pre></pre>
<p>Now <code>http://localhost:3000/assets/</code> serves <code>public/index.html</code>!</p>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<p>For production, consider adding caching headers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::http::header;

pub async fn serve_asset(
    // ... parameters
) -&gt; Result&lt;Response, AppError&gt; {
    // ... validation and reading
    
    // Add cache headers for static assets
    let cache_control = if is_immutable_asset(&amp;safe_path) {
        "public, max-age=31536000, immutable"  // 1 year for versioned assets
    } else {
        "public, max-age=3600"  // 1 hour for other assets
    };
    
    Ok((
        StatusCode::OK,
        [
            (header::CONTENT_TYPE, content_type),
            (header::CACHE_CONTROL, cache_control),
        ],
        content,
    ).into_response())
}

fn is_immutable_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; bool {
    // Check if filename contains hash (e.g., app-abc123.js)
    path.strictpath_file_name()
        .and_then(|n| n.to_str())
        .map(|n| n.contains('-') &amp;&amp; n.split('-').nth(1).is_some())
        .unwrap_or(false)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways-7"><a class="header" href="#key-takeaways-7">Key Takeaways</a></h2>
<p>✅ <strong>Single validation point</strong> - <code>strict_join()</code> handles all path security<br />
✅ <strong>Type-safe helpers</strong> - Functions accept <code>StrictPath&lt;WebAssets&gt;</code> only<br />
✅ <strong>Automatic attack blocking</strong> - No manual checks needed<br />
✅ <strong>Clear error handling</strong> - Failed validation returns appropriate HTTP errors<br />
✅ <strong>Content-type safety</strong> - Based on validated path extension</p>
<h2 id="whats-next-8"><a class="header" href="#whats-next-8">What's Next?</a></h2>
<p>Now that we can serve static assets securely, let's add user authentication:</p>
<p><strong><a href="axum_tutorial/./chapter3_authentication.html">Chapter 3: User Authentication →</a></strong></p>
<p>In the next chapter, we'll:</p>
<ul>
<li>Implement simple session-based authentication</li>
<li>Create per-user <code>VirtualRoot</code> instances</li>
<li>Use authorization markers with <code>change_marker()</code></li>
<li>Protect routes with middleware</li>
</ul>
<hr />
<p><strong>Navigation:</strong><br />
<a href="axum_tutorial/./chapter1_setup.html">← Chapter 1</a> | <a href="axum_tutorial/./overview.html">Tutorial Overview</a> | <a href="axum_tutorial/./chapter3_authentication.html">Chapter 3 →</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-per-user-storage-with-virtualroot"><a class="header" href="#chapter-3-per-user-storage-with-virtualroot">Chapter 3: Per-User Storage with VirtualRoot</a></h1>
<p>This chapter shows how to isolate user file storage using <code>VirtualRoot&lt;UserUploads&gt;</code>. Each user gets their own virtual filesystem that cannot access other users' files.</p>
<h2 id="the-problem-user-isolation"><a class="header" href="#the-problem-user-isolation">The Problem: User Isolation</a></h2>
<p>Without proper isolation, users could access each other's files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ UNSAFE: Users can escape their directory
let user_file = format!("./uploads/{}/{}", user_id, filename);
// User sends filename="../other_user/secret.txt"
<span class="boring">}</span></code></pre></pre>
<h2 id="the-solution-virtualroot-per-user"><a class="header" href="#the-solution-virtualroot-per-user">The Solution: VirtualRoot Per User</a></h2>
<p><code>VirtualRoot</code> creates an isolated view where paths are relative to the user's directory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ SAFE: Isolated per-user virtual filesystem
let user_root = VirtualRoot::&lt;UserUploads&gt;::try_new(
    format!("./uploads/user_{user_id}")
)?;

// User's paths are always within their root
let file = user_root.virtual_join(filename)?; // Can't escape!
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-file-upload-handler"><a class="header" href="#implementation-file-upload-handler">Implementation: File Upload Handler</a></h2>
<p>Create <code>src/routes/upload.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    extract::{Multipart, Path, State},
    http::StatusCode,
    response::IntoResponse,
};
use strict_path::VirtualRoot;
use crate::{markers::UserUploads, state::AppState, error::AppError};

/// Handle file upload for authenticated user
pub async fn upload_file(
    State(state): State&lt;AppState&gt;,
    Path(user_id): Path&lt;String&gt;,
    mut multipart: Multipart,
) -&gt; Result&lt;impl IntoResponse, AppError&gt; {
    // Get or create user's virtual root
    let user_root = state.get_user_root(&amp;user_id)?;

    while let Some(field) = multipart.next_field().await? {
        let filename = field
            .file_name()
            .ok_or(AppError::MissingFilename)?
            .to_string();

        // SECURITY: virtual_join validates filename
        // Rejects: "../", absolute paths, special chars
        let file_path = user_root
            .virtual_join(&amp;filename)
            .map_err(|_| AppError::InvalidFilename)?;

        let data = field.bytes().await?;
        
        // Safe: file_path is guaranteed within user's boundary
        file_path.write(data.as_ref())?;
    }

    Ok(StatusCode::CREATED)
}

/// List files in user's directory
pub async fn list_files(
    State(state): State&lt;AppState&gt;,
    Path(user_id): Path&lt;String&gt;,
) -&gt; Result&lt;impl IntoResponse, AppError&gt; {
    let user_root = state.get_user_root(&amp;user_id)?;
    
    // Convert to StrictPath to read directory
    let root_dir = user_root.as_unvirtual();
    let entries = root_dir.read_dir()?;

    let files: Vec&lt;String&gt; = entries
        .filter_map(|e| e.ok())
        .filter_map(|e| e.file_name().into_string().ok())
        .collect();

    Ok(axum::Json(files))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="update-appstate"><a class="header" href="#update-appstate">Update AppState</a></h2>
<p>Modify <code>src/state.rs</code> to manage per-user roots:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use strict_path::{PathBoundary, VirtualRoot};
use crate::markers::{WebAssets, UserUploads, AppConfig};

pub struct AppState {
    pub assets: PathBoundary&lt;WebAssets&gt;,
    pub config: PathBoundary&lt;AppConfig&gt;,
    uploads_base: PathBoundary&lt;UserUploads&gt;,
    // Cache of user virtual roots
    user_roots: Arc&lt;RwLock&lt;HashMap&lt;String, VirtualRoot&lt;UserUploads&gt;&gt;&gt;&gt;,
}

impl AppState {
    pub fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        Ok(Self {
            assets: PathBoundary::try_new_create("./data/assets")?,
            config: PathBoundary::try_new("./data/config")?,
            uploads_base: PathBoundary::try_new_create("./data/uploads")?,
            user_roots: Arc::new(RwLock::new(HashMap::new())),
        })
    }

    /// Get or create virtual root for user
    pub fn get_user_root(
        &amp;self,
        user_id: &amp;str,
    ) -&gt; Result&lt;VirtualRoot&lt;UserUploads&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        // Check cache first
        {
            let cache = self.user_roots.read().unwrap();
            if let Some(root) = cache.get(user_id) {
                return Ok(root.clone());
            }
        }

        // Create new user directory and virtual root
        let user_dir = self.uploads_base.strict_join(user_id)?;
        user_dir.create_dir_all()?;

        let vroot = VirtualRoot::try_new(user_dir.interop_path())?;

        // Cache it
        self.user_roots.write().unwrap().insert(user_id.to_string(), vroot.clone());

        Ok(vroot)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="register-routes"><a class="header" href="#register-routes">Register Routes</a></h2>
<p>Update <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">mod routes {
    pub mod assets;
    pub mod upload;
}

use axum::{
    routing::{get, post},
    Router,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let state = AppState::new()?;

    let app = Router::new()
        .route("/assets/*path", get(routes::assets::serve_asset))
        .route("/users/:user_id/files", post(routes::upload::upload_file))
        .route("/users/:user_id/files", get(routes::upload::list_files))
        .with_state(state);

    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000").await?;
    println!("Server running on http://127.0.0.1:3000");
    
    axum::serve(listener, app).await?;
    Ok(())
}</code></pre></pre>
<h2 id="key-security-properties"><a class="header" href="#key-security-properties">Key Security Properties</a></h2>
<ol>
<li><strong>User Isolation</strong>: Each <code>VirtualRoot</code> is scoped to one user's directory</li>
<li><strong>Path Validation</strong>: <code>virtual_join()</code> prevents directory traversal</li>
<li><strong>Type Safety</strong>: <code>VirtualRoot&lt;UserUploads&gt;</code> can't mix with <code>PathBoundary&lt;WebAssets&gt;</code></li>
<li><strong>Automatic Caching</strong>: User roots are cached for performance</li>
</ol>
<h2 id="testing-the-isolation"><a class="header" href="#testing-the-isolation">Testing the Isolation</a></h2>
<pre><code class="language-bash"># Upload to user_001
curl -F "file=@test.txt" http://localhost:3000/users/user_001/files

# Try to access user_002's files (will fail)
curl -F "file=@../user_002/secret.txt" http://localhost:3000/users/user_001/files
# Returns 400: InvalidFilename

# List user_001's files (only shows their files)
curl http://localhost:3000/users/user_001/files
</code></pre>
<h2 id="what-we-learned"><a class="header" href="#what-we-learned">What We Learned</a></h2>
<ul>
<li><code>VirtualRoot</code> provides per-user filesystem isolation</li>
<li><code>virtual_join()</code> validates filenames and prevents escapes</li>
<li>AppState can manage multiple virtual roots efficiently</li>
<li>Type markers prevent accidentally mixing user storage with other boundaries</li>
</ul>
<hr />
<p><strong>Navigation:</strong><br />
<a href="axum_tutorial/./chapter2_static_assets.html">← Chapter 2</a> | <a href="axum_tutorial/./overview.html">Tutorial Overview</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>The <code>strict-path</code> crate provides several optional features that extend functionality while maintaining the core security guarantees. All features are disabled by default to keep the core library lightweight.</p>
<pre><code class="language-toml">[dependencies]
strict-path = { 
    version = "0.1.0-beta.1", 
    features = ["dirs", "serde", "tempfile", "app-path"] 
}
</code></pre>
<h2 id="available-features"><a class="header" href="#available-features">Available Features</a></h2>
<h3 id="dirs---os-standard-directories"><a class="header" href="#dirs---os-standard-directories"><code>dirs</code> - OS Standard Directories</a></h3>
<p>Cross-platform access to operating system standard directories following platform conventions (XDG Base Directory on Linux, Known Folder API on Windows, Apple Standard Directories on macOS).</p>
<pre><code class="language-toml">[dependencies]
strict-path = { version = "0.1.0-beta.1", features = ["dirs"] }
</code></pre>
<p>Enables constructors like:</p>
<ul>
<li><code>PathBoundary::try_new_os_config("MyApp")</code> - Application configuration</li>
<li><code>PathBoundary::try_new_os_data("MyApp")</code> - Application data storage</li>
<li><code>PathBoundary::try_new_os_cache("MyApp")</code> - Application cache</li>
<li><code>PathBoundary::try_new_os_documents()</code> - User documents directory</li>
<li>And many more...</li>
</ul>
<p><strong><a href="./os_directories.html">→ Full OS Directories Documentation</a></strong></p>
<h3 id="serde---serialization-support"><a class="header" href="#serde---serialization-support"><code>serde</code> - Serialization Support</a></h3>
<p>Adds <code>Serialize</code> implementations for <code>StrictPath</code> and <code>VirtualPath</code>, plus deserialization helpers for secure path handling in web APIs and configuration files.</p>
<pre><code class="language-toml">[dependencies]
strict-path = { version = "0.1.0-beta.1", features = ["serde"] }
</code></pre>
<p>Enables:</p>
<ul>
<li>Direct serialization: <code>serde_json::to_string(&amp;strict_path)?</code></li>
<li>Context-aware deserialization helpers</li>
<li>Integration with web frameworks and config parsers</li>
</ul>
<h3 id="tempfile---temporary-directories"><a class="header" href="#tempfile---temporary-directories"><code>tempfile</code> - Temporary Directories</a></h3>
<p>RAII temporary directories that are automatically cleaned up when dropped, with each <code>PathBoundary</code> getting a unique temporary directory.</p>
<pre><code class="language-toml">[dependencies]
strict-path = { version = "0.1.0-beta.1", features = ["tempfile"] }
```Enables:
- `PathBoundary::try_new_temp()` - Unique temporary directory
- `PathBoundary::try_new_temp_with_prefix("my-prefix")` - Custom prefix
- Automatic cleanup when the boundary is dropped

### `app-path` - Portable Application Directories
Integration with the `app-path` crate for discovering application directories relative to the executable with environment variable overrides.

```toml
[dependencies]
strict-path = { version = "0.1.0-beta.1", features = ["app-path"] }
</code></pre>
<p>Enables portable application directory discovery for:</p>
<ul>
<li>Configuration directories relative to executable</li>
<li>Data directories with environment overrides</li>
<li>Cross-platform deployment scenarios</li>
</ul>
<h2 id="feature-combinations"><a class="header" href="#feature-combinations">Feature Combinations</a></h2>
<p>Features can be combined as needed:</p>
<pre><code class="language-toml">[dependencies]
strict-path = { 
    version = "0.1.0-alpha.1", 
    features = ["dirs", "serde", "tempfile"] 
}
</code></pre>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>All optional features:</p>
<ul>
<li><strong>Maintain security</strong>: Never compromise path boundary enforcement</li>
<li><strong>Zero-cost when unused</strong>: Features add no overhead if not enabled</li>
<li><strong>Composable</strong>: Features work together seamlessly</li>
<li><strong>Platform-aware</strong>: Handle platform differences gracefully</li>
<li><strong>Standards-compliant</strong>: Follow established conventions and specifications</li>
</ul>
<h2 id="migration-and-compatibility"><a class="header" href="#migration-and-compatibility">Migration and Compatibility</a></h2>
<p>Features are additive and backward-compatible. Enabling new features won't break existing code, and the core API remains stable across all feature combinations.</p>
<p>When features are unavailable:</p>
<ul>
<li>Missing feature methods result in compile-time errors (not runtime failures)</li>
<li>Documentation clearly indicates feature requirements</li>
<li>Examples include feature guards for conditional compilation</li>
</ul>
<h2 id="api-reference-summary"><a class="header" href="#api-reference-summary">API Reference Summary</a></h2>
<h3 id="core-types-comparison"><a class="header" href="#core-types-comparison">Core Types Comparison</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th><code>Path</code>/<code>PathBuf</code></th><th><code>StrictPath</code></th><th><code>VirtualPath</code></th></tr></thead><tbody>
<tr><td><strong>Security</strong></td><td>None 💥</td><td>Validates &amp; rejects ✅</td><td>Clamps any input ✅</td></tr>
<tr><td><strong>Join safety</strong></td><td>Unsafe (can escape)</td><td>Boundary-checked</td><td>Boundary-clamped</td></tr>
<tr><td><strong>Boundary guarantee</strong></td><td>None</td><td>Jailed (cannot escape)</td><td>Jailed (virtual view)</td></tr>
<tr><td><strong>Input permissiveness</strong></td><td>Any path (no validation)</td><td>Only safe paths</td><td>Any input (auto-clamped)</td></tr>
<tr><td><strong>Display format</strong></td><td>OS path</td><td>OS path</td><td>Virtual root path</td></tr>
<tr><td><strong>Example: good input</strong></td><td><code>"file.txt"</code> → <code>"file.txt"</code></td><td><code>"file.txt"</code> → <code>"boundary/file.txt"</code></td><td><code>"file.txt"</code> → <code>"/file.txt"</code></td></tr>
<tr><td><strong>Example: attack input</strong></td><td><code>"/etc/passwd"</code> → <strong>System breach</strong> 💥</td><td><code>"/etc/passwd"</code> → <strong>Error</strong> ❌</td><td><code>"/etc/passwd"</code> → <strong><code>/etc/passwd</code></strong> (safe) ✅</td></tr>
<tr><td><strong>Best for</strong></td><td>Known-safe paths</td><td>System boundaries</td><td>User interfaces</td></tr>
</tbody></table>
</div>
<h3 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h3>
<h4 id="serde-integration"><a class="header" href="#serde-integration">Serde Integration</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct FileRequest {
    filename: String,  // Accept as string first
}

#[derive(Serialize)]  
struct FileResponse {
    path: StrictPath&lt;UserFiles&gt;,  // Serialize safe path
}

async fn handle_upload(req: FileRequest) -&gt; Result&lt;FileResponse, Error&gt; {
    let uploads = PathBoundary::try_new("uploads")?;
    let safe_path = uploads.strict_join(&amp;req.filename)?;  // Validate here
    
    // ... process file ...
    
    Ok(FileResponse { path: safe_path })
}
<span class="boring">}</span></code></pre></pre>
<h4 id="axum-web-framework"><a class="header" href="#axum-web-framework">Axum Web Framework</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{extract::Path, response::Result};
use strict_path::PathBoundary;

struct StaticFiles;

async fn serve_static(Path(filename): Path&lt;String&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let static_dir = PathBoundary::&lt;StaticFiles&gt;::try_new("./static")?;
    let safe_path = static_dir.strict_join(&amp;filename)?; // Attack = Error
    
    Ok(safe_path.read()?)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="configuration-with-app-path"><a class="header" href="#configuration-with-app-path">Configuration with app-path</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use app_path::AppPath;
use strict_path::PathBoundary;

fn load_app_config() -&gt; Result&lt;Config, Box&lt;dyn std::error::Error&gt;&gt; {
    let app_dir = AppPath::new("MyApp").get_app_dir();
    let config_boundary = PathBoundary::try_new_create(app_dir)?;
    let config_file = config_boundary.strict_join("config.toml")?;
    
    Ok(toml::from_str(&amp;config_file.read_to_string()?)?)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><strong>For OS directories</strong>: See <a href="./os_directories.html">OS Standard Directories</a></li>
<li><strong>For serialization</strong>: Check the integrations section in <a href="./chapter_1.html">Getting Started</a></li>
<li><strong>For examples</strong>: Browse <a href="./examples.html">Real-World Examples</a> with feature-specific demos</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-standard-directories"><a class="header" href="#os-standard-directories">OS Standard Directories</a></h1>
<blockquote>
<p><strong>Feature</strong>: <code>dirs</code> - Enable with <code>features = ["dirs"]</code> in your <code>Cargo.toml</code></p>
</blockquote>
<p>The <code>strict-path</code> crate provides seamless integration with operating system standard directories through the <a href="https://crates.io/crates/dirs"><code>dirs</code></a> crate. This enables cross-platform applications to securely access user and system directories like configuration, data storage, cache, and user content locations.</p>
<p><strong>Quick Start:</strong></p>
<pre><code class="language-toml">[dependencies]
strict-path = { version = "0.1.0-beta.1", features = ["dirs"] }
</code></pre>
<h2 id="cross-platform-standards"><a class="header" href="#cross-platform-standards">Cross-Platform Standards</a></h2>
<p>The integration follows established cross-platform directory standards:</p>
<h3 id="linux-xdg-base-directory-specification"><a class="header" href="#linux-xdg-base-directory-specification">Linux (XDG Base Directory Specification)</a></h3>
<ul>
<li><strong>Config</strong>: <code>$XDG_CONFIG_HOME</code> or <code>~/.config</code></li>
<li><strong>Data</strong>: <code>$XDG_DATA_HOME</code> or <code>~/.local/share</code></li>
<li><strong>Cache</strong>: <code>$XDG_CACHE_HOME</code> or <code>~/.cache</code></li>
<li><strong>Runtime</strong>: <code>$XDG_RUNTIME_DIR</code> or <code>/tmp</code></li>
</ul>
<h3 id="windows-known-folder-api"><a class="header" href="#windows-known-folder-api">Windows (Known Folder API)</a></h3>
<ul>
<li><strong>Config</strong>: <code>%APPDATA%</code> (Roaming)</li>
<li><strong>Data</strong>: <code>%APPDATA%</code> (Roaming)</li>
<li><strong>Cache</strong>: <code>%LOCALAPPDATA%</code></li>
<li><strong>Local Config</strong>: <code>%LOCALAPPDATA%</code></li>
<li><strong>Local Data</strong>: <code>%LOCALAPPDATA%</code></li>
</ul>
<h3 id="macos-apple-standard-directories"><a class="header" href="#macos-apple-standard-directories">macOS (Apple Standard Directories)</a></h3>
<ul>
<li><strong>Config</strong>: <code>~/Library/Application Support</code></li>
<li><strong>Data</strong>: <code>~/Library/Application Support</code></li>
<li><strong>Cache</strong>: <code>~/Library/Caches</code></li>
</ul>
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<p>Both <code>PathBoundary</code> and <code>VirtualRoot</code> provide comprehensive OS directory constructors:</p>
<h3 id="application-directories"><a class="header" href="#application-directories">Application Directories</a></h3>
<h4 id="try_new_os_configapp_name-str"><a class="header" href="#try_new_os_configapp_name-str"><code>try_new_os_config(app_name: &amp;str)</code></a></h4>
<p>Creates a secure boundary for application configuration storage.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

let config_dir = PathBoundary::&lt;()&gt;::try_new_os_config("MyApp")?;
let config_file = config_dir.strict_join("settings.json")?;
config_file.write(r#"{"theme": "dark"}"#)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Platform paths:</strong></p>
<ul>
<li>Linux: <code>~/.config/MyApp/</code></li>
<li>Windows: <code>%APPDATA%/MyApp/</code></li>
<li>macOS: <code>~/Library/Application Support/MyApp/</code></li>
</ul>
<h4 id="try_new_os_dataapp_name-str"><a class="header" href="#try_new_os_dataapp_name-str"><code>try_new_os_data(app_name: &amp;str)</code></a></h4>
<p>Creates a secure boundary for application data storage.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data_dir = PathBoundary::&lt;()&gt;::try_new_os_data("MyApp")?;
let database = data_dir.strict_join("app.db")?;
database.write(b"SQLite database content")?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Platform paths:</strong></p>
<ul>
<li>Linux: <code>~/.local/share/MyApp/</code></li>
<li>Windows: <code>%APPDATA%/MyApp/</code></li>
<li>macOS: <code>~/Library/Application Support/MyApp/</code></li>
</ul>
<h4 id="try_new_os_cacheapp_name-str"><a class="header" href="#try_new_os_cacheapp_name-str"><code>try_new_os_cache(app_name: &amp;str)</code></a></h4>
<p>Creates a secure boundary for application cache storage.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cache_dir = PathBoundary::&lt;()&gt;::try_new_os_cache("MyApp")?;
let thumbnail_cache = cache_dir.strict_join("thumbnails/")?;
thumbnail_cache.create_dir_all()?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Platform paths:</strong></p>
<ul>
<li>Linux: <code>~/.cache/MyApp/</code></li>
<li>Windows: <code>%LOCALAPPDATA%/MyApp/</code></li>
<li>macOS: <code>~/Library/Caches/MyApp/</code></li>
</ul>
<h3 id="platform-specific-directories"><a class="header" href="#platform-specific-directories">Platform-Specific Directories</a></h3>
<h4 id="try_new_os_config_localapp_name-str-windowslinux-only"><a class="header" href="#try_new_os_config_localapp_name-str-windowslinux-only"><code>try_new_os_config_local(app_name: &amp;str)</code> (Windows/Linux only)</a></h4>
<p>Creates a local (non-roaming) config directory boundary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(any(target_os = "windows", target_os = "linux"))]
let local_config = PathBoundary::&lt;()&gt;::try_new_os_config_local("MyApp")?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Platform paths:</strong></p>
<ul>
<li>Linux: <code>~/.config/MyApp/</code> (same as config)</li>
<li>Windows: <code>%LOCALAPPDATA%/MyApp/</code> (non-roaming)</li>
<li>macOS: Not available (returns <code>Err</code>)</li>
</ul>
<h4 id="try_new_os_data_localapp_name-str-windowslinux-only"><a class="header" href="#try_new_os_data_localapp_name-str-windowslinux-only"><code>try_new_os_data_local(app_name: &amp;str)</code> (Windows/Linux only)</a></h4>
<p>Creates a local (non-roaming) data directory boundary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(any(target_os = "windows", target_os = "linux"))]
let local_data = PathBoundary::&lt;()&gt;::try_new_os_data_local("MyApp")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="user-content-directories"><a class="header" href="#user-content-directories">User Content Directories</a></h3>
<h4 id="standard-user-folders"><a class="header" href="#standard-user-folders">Standard User Folders</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// User's home directory
let home_dir = PathBoundary::&lt;()&gt;::try_new_os_home()?;

// Desktop folder
let desktop_dir = PathBoundary::&lt;()&gt;::try_new_os_desktop()?;

// Documents folder  
let documents_dir = PathBoundary::&lt;()&gt;::try_new_os_documents()?;

// Downloads folder
let downloads_dir = PathBoundary::&lt;()&gt;::try_new_os_downloads()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="media-directories"><a class="header" href="#media-directories">Media Directories</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pictures/Photos
let pictures_dir = PathBoundary::&lt;()&gt;::try_new_os_pictures()?;

// Music/Audio files
let audio_dir = PathBoundary::&lt;()&gt;::try_new_os_audio()?;

// Videos/Movies
let videos_dir = PathBoundary::&lt;()&gt;::try_new_os_videos()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="system-directories"><a class="header" href="#system-directories">System Directories</a></h3>
<h4 id="try_new_os_executables-unix-only"><a class="header" href="#try_new_os_executables-unix-only"><code>try_new_os_executables()</code> (Unix only)</a></h4>
<p>Creates a boundary for user executable binaries.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(unix)]
let bin_dir = PathBoundary::&lt;()&gt;::try_new_os_executables()?;
// Typically ~/.local/bin on Linux
<span class="boring">}</span></code></pre></pre>
<h4 id="try_new_os_runtime-unix-only"><a class="header" href="#try_new_os_runtime-unix-only"><code>try_new_os_runtime()</code> (Unix only)</a></h4>
<p>Creates a boundary for runtime files like sockets and PIDs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(unix)]
let runtime_dir = PathBoundary::&lt;()&gt;::try_new_os_runtime()?;
// Uses $XDG_RUNTIME_DIR or falls back to /tmp
<span class="boring">}</span></code></pre></pre>
<h4 id="try_new_os_state-linux-only"><a class="header" href="#try_new_os_state-linux-only"><code>try_new_os_state()</code> (Linux only)</a></h4>
<p>Creates a boundary for application state data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = "linux")]
let state_dir = PathBoundary::&lt;()&gt;::try_new_os_state("MyApp")?;
// Uses $XDG_STATE_HOME or ~/.local/state/MyApp
<span class="boring">}</span></code></pre></pre>
<h2 id="virtual-root-integration"><a class="header" href="#virtual-root-integration">Virtual Root Integration</a></h2>
<p>All OS directory constructors are available on <code>VirtualRoot</code> as well:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualRoot;

// Create virtual root for user documents
let docs_root = VirtualRoot::&lt;()&gt;::try_new_os_documents()?;

// User sees clean virtual paths, system handles real location
let project_file = docs_root.virtual_join("projects/my-app/notes.txt")?;
println!("Virtual path: {}", project_file.virtualpath_display());
// Output: "/projects/my-app/notes.txt"

println!("Real path: {}", project_file.as_unvirtual().strictpath_display());
// Output: "/home/user/Documents/projects/my-app/notes.txt" (Linux example)
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-application-example"><a class="header" href="#complete-application-example">Complete Application Example</a></h2>
<p>Here's a realistic media organizer application demonstrating the OS directories integration:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, VirtualRoot};
use std::collections::HashMap;

#[derive(Debug)]
struct MediaOrganizerApp {
    config_dir: PathBoundary&lt;()&gt;,
    data_dir: PathBoundary&lt;()&gt;,
    cache_dir: PathBoundary&lt;()&gt;,
}

impl MediaOrganizerApp {
    fn new(app_name: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Initialize with OS standard directories
        let config_dir = PathBoundary::&lt;()&gt;::try_new_os_config(app_name)?;
        let data_dir = PathBoundary::&lt;()&gt;::try_new_os_data(app_name)?;
        let cache_dir = PathBoundary::&lt;()&gt;::try_new_os_cache(app_name)?;
        
        println!("📁 Config: {}", config_dir.strictpath_display());
        println!("💾 Data: {}", data_dir.strictpath_display());
        println!("🗄️ Cache: {}", cache_dir.strictpath_display());
        
        Ok(Self { config_dir, data_dir, cache_dir })
    }
    
    fn scan_user_media(&amp;self) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Access standard user media directories securely
        let media_directories = vec![
            ("Pictures", PathBoundary::&lt;()&gt;::try_new_os_pictures()?),
            ("Music", PathBoundary::&lt;()&gt;::try_new_os_audio()?),
            ("Videos", PathBoundary::&lt;()&gt;::try_new_os_videos()?),
            ("Downloads", PathBoundary::&lt;()&gt;::try_new_os_downloads()?),
        ];
        
        for (dir_name, dir_path) in media_directories {
            println!("📂 Scanning {}: {}", dir_name, dir_path.strictpath_display());
            
            // In a real app, recursively scan for media files
            // All file operations stay within secure boundaries
            if dir_path.exists() {
                println!("   ✅ Directory accessible and secure");
            }
        }
        
        Ok(())
    }
    
    fn manage_cache(&amp;self) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Create cache subdirectories securely
        let thumbnails_dir = self.cache_dir.strict_join("thumbnails")?;
        let metadata_dir = self.cache_dir.strict_join("metadata")?;
        
        thumbnails_dir.create_dir_all()?;
        metadata_dir.create_dir_all()?;
        
        println!("🖼️ Thumbnails: {}", thumbnails_dir.strictpath_display());
        println!("📝 Metadata: {}", metadata_dir.strictpath_display());
        
        Ok(())
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = MediaOrganizerApp::new("MediaOrganizer")?;
    app.scan_user_media()?;
    app.manage_cache()?;
    Ok(())
}</code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>OS directory functions return <code>StrictPathError</code> when:</p>
<ul>
<li>The directory doesn't exist and cannot be created</li>
<li>Permission denied accessing the directory</li>
<li>The OS doesn't support the requested directory type</li>
<li>Invalid characters in the application name</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPathError};

match PathBoundary::&lt;()&gt;::try_new_os_config("My App") {
    Ok(config_dir) =&gt; println!("Config: {}", config_dir.strictpath_display()),
    Err(StrictPathError::PathResolutionError(msg)) =&gt; {
        eprintln!("Failed to resolve config directory: {}", msg);
    }
    Err(e) =&gt; eprintln!("Other error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="platform-compatibility"><a class="header" href="#platform-compatibility">Platform Compatibility</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Linux</th><th>Windows</th><th>macOS</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>try_new_os_config</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_data</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_cache</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_config_local</code></td><td>✅</td><td>✅</td><td>❌</td><td>Returns error on macOS</td></tr>
<tr><td><code>try_new_os_data_local</code></td><td>✅</td><td>✅</td><td>❌</td><td>Returns error on macOS</td></tr>
<tr><td><code>try_new_os_home</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_desktop</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_documents</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_downloads</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_pictures</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_audio</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_videos</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_executables</code></td><td>✅</td><td>❌</td><td>✅</td><td>Unix only</td></tr>
<tr><td><code>try_new_os_runtime</code></td><td>✅</td><td>❌</td><td>✅</td><td>Unix only</td></tr>
<tr><td><code>try_new_os_state</code></td><td>✅</td><td>❌</td><td>❌</td><td>Linux only</td></tr>
</tbody></table>
</div>
<h2 id="integration-with-dirs-crate"><a class="header" href="#integration-with-dirs-crate">Integration with <code>dirs</code> Crate</a></h2>
<p>This feature integrates with the <a href="https://github.com/dirs-dev/dirs-rs"><code>dirs</code></a> crate v6.0.0, which provides the underlying OS directory discovery. The <code>strict-path</code> crate adds:</p>
<ul>
<li><strong>Security</strong>: All directory access happens within <code>PathBoundary</code> restrictions</li>
<li><strong>Type Safety</strong>: Compile-time guarantees about directory boundaries</li>
<li><strong>Symlink Safety</strong>: Safe resolution of symbolic links and junctions</li>
<li><strong>Cross-Platform</strong>: Consistent API across Windows, macOS, and Linux</li>
<li><strong>Application Scoping</strong>: Automatic subdirectory creation for app-specific storage</li>
</ul>
<h3 id="relationship-to-dirs-functions"><a class="header" href="#relationship-to-dirs-functions">Relationship to <code>dirs</code> Functions</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>strict-path</code> Method</th><th><code>dirs</code> Function</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>try_new_os_config</code></td><td><code>dirs::config_dir()</code> + join</td><td>App config storage</td></tr>
<tr><td><code>try_new_os_data</code></td><td><code>dirs::data_dir()</code> + join</td><td>App data storage</td></tr>
<tr><td><code>try_new_os_cache</code></td><td><code>dirs::cache_dir()</code> + join</td><td>App cache storage</td></tr>
<tr><td><code>try_new_os_config_local</code></td><td><code>dirs::config_local_dir()</code> + join</td><td>Local config (non-roaming)</td></tr>
<tr><td><code>try_new_os_data_local</code></td><td><code>dirs::data_local_dir()</code> + join</td><td>Local data (non-roaming)</td></tr>
<tr><td><code>try_new_os_home</code></td><td><code>dirs::home_dir()</code></td><td>User home directory</td></tr>
<tr><td><code>try_new_os_desktop</code></td><td><code>dirs::desktop_dir()</code></td><td>Desktop folder</td></tr>
<tr><td><code>try_new_os_documents</code></td><td><code>dirs::document_dir()</code></td><td>Documents folder</td></tr>
<tr><td><code>try_new_os_downloads</code></td><td><code>dirs::download_dir()</code></td><td>Downloads folder</td></tr>
<tr><td><code>try_new_os_pictures</code></td><td><code>dirs::picture_dir()</code></td><td>Pictures folder</td></tr>
<tr><td><code>try_new_os_audio</code></td><td><code>dirs::audio_dir()</code></td><td>Music/Audio folder</td></tr>
<tr><td><code>try_new_os_videos</code></td><td><code>dirs::video_dir()</code></td><td>Videos folder</td></tr>
<tr><td><code>try_new_os_executables</code></td><td><code>dirs::executable_dir()</code></td><td>User binaries (Unix)</td></tr>
<tr><td><code>try_new_os_runtime</code></td><td><code>dirs::runtime_dir()</code></td><td>Runtime files (Unix)</td></tr>
<tr><td><code>try_new_os_state</code></td><td><code>dirs::state_dir()</code> + join</td><td>State data (Linux)</td></tr>
</tbody></table>
</div>
<p>For more details on the underlying directory locations, see the <a href="https://docs.rs/dirs/"><code>dirs</code> crate documentation</a>.</p>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="1-application-naming"><a class="header" href="#1-application-naming">1. Application Naming</a></h3>
<p>Use consistent, filesystem-safe application names:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good
let config = PathBoundary::&lt;()&gt;::try_new_os_config("MyApp")?;

// Avoid special characters that might cause issues
let config = PathBoundary::&lt;()&gt;::try_new_os_config("My App &amp; Tools")?; // Risky
<span class="boring">}</span></code></pre></pre>
<h3 id="2-graceful-fallbacks"><a class="header" href="#2-graceful-fallbacks">2. Graceful Fallbacks</a></h3>
<p>Handle platform-specific directories gracefully:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Try platform-specific first, fall back to generic
let data_dir = PathBoundary::&lt;()&gt;::try_new_os_data_local("MyApp")
    .or_else(|_| PathBoundary::&lt;()&gt;::try_new_os_data("MyApp"))?;
<span class="boring">}</span></code></pre></pre>
<h3 id="3-directory-creation"><a class="header" href="#3-directory-creation">3. Directory Creation</a></h3>
<p>Create application subdirectories as needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_dir = PathBoundary::&lt;()&gt;::try_new_os_config("MyApp")?;
let themes_dir = config_dir.strict_join("themes")?;
themes_dir.create_dir_all()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="4-cross-platform-testing"><a class="header" href="#4-cross-platform-testing">4. Cross-Platform Testing</a></h3>
<p>Test your application on all target platforms to verify directory behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_config_directory_creation() {
        let config_dir = PathBoundary::&lt;()&gt;::try_new_os_config("TestApp").unwrap();
        assert!(config_dir.exists() || config_dir.create_dir_all().is_ok());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="./examples.html">Real-World Examples</a> - Complete application examples</li>
<li><a href="./chapter_1.html">Getting Started</a> - Basic <code>strict-path</code> concepts</li>
<li><a href="https://crates.io/crates/dirs"><code>dirs</code> crate</a> - Underlying OS directory library</li>
<li><a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG Base Directory Specification</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid">Windows Known Folder API</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-strict-path-with-archive-extractors"><a class="header" href="#using-strict-path-with-archive-extractors">Using strict-path with archive extractors</a></h1>
<p>Archive formats (ZIP, TAR, etc.) embed file names provided by untrusted sources. Treat each entry name as hostile and validate it through VirtualRoot or PathBoundary before any filesystem I/O.</p>
<h2 id="recommended-patterns"><a class="header" href="#recommended-patterns">Recommended patterns</a></h2>
<ul>
<li>Prefer VirtualRoot for extraction pipelines: it accepts any input and clamps it to the path boundary. This makes batch extraction resilient and user-friendly.</li>
<li>Use create_parent_dir_all() before writes to avoid TOCTOU-style parent creation races in your own code. Our operations re-validate boundaries internally.</li>
<li>Do not concatenate paths manually. Always join via vroot.virtual_join(name) or path_boundary.strict_join(name).</li>
<li>Treat absolute, UNC, drive-relative, or namespace-prefixed paths as untrusted inputs. The virtual join will clamp these to the virtual root.</li>
<li>On Windows, NTFS Alternate Data Streams (ADS) like "file.txt:stream" are handled safely. Writes remain within the path boundary or are cleanly rejected by the OS.</li>
</ul>
<h2 id="minimal-example-zip-like-flow"><a class="header" href="#minimal-example-zip-like-flow">Minimal example (ZIP-like flow)</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualRoot;

fn extract_all&lt;M: Default&gt;(dest: &amp;std::path::Path, entries: impl IntoIterator&lt;Item=(String, Vec&lt;u8&gt;)&gt;) -&gt; std::io::Result&lt;()&gt; {
    let vroot: VirtualRoot&lt;M&gt; = VirtualRoot::try_new_create(dest)?;

    for (name, data) in entries {
        // 1) Safely map entry name to a strict path (clamped on escape attempts)
        let vpath = match vroot.virtual_join(&amp;name) {
            Ok(v) =&gt; v,
            Err(_) =&gt; continue, // cleanly reject this entry, log if needed
        };

        // 2) Ensure parent directories exist (inside the path boundary)
        vpath.create_parent_dir_all()?;

        // 3) Perform the write safely
        vpath.write(&amp;data)?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="anti-patterns-dont-do-this"><a class="header" href="#anti-patterns-dont-do-this">Anti-patterns (don’t do this)</a></h2>
<ul>
<li>Building paths with format!/push/join on std::path::Path without validation</li>
<li>Stripping "../" by string replacement</li>
<li>Allowing absolute paths through to the OS</li>
<li>Treating encoded/unicode tricks (URL-encoded, dot lookalikes) as pre-sanitized</li>
</ul>
<h2 id="testing-advice"><a class="header" href="#testing-advice">Testing advice</a></h2>
<ul>
<li>Add corpus entries with: "../", "..\", absolute paths, UNC/\?\ prefixes, drive-relative ("C:..\foo"), unicode lookalikes, long paths.</li>
<li>On Windows, include ADS cases like "decoy.txt:..\..\evil.exe" and reserved names.</li>
<li>Assert that successful joins produce paths contained within the path boundary and failed joins are clean, with no creation outside the path boundary.</li>
</ul>
<h2 id="notes-on-behavior"><a class="header" href="#notes-on-behavior">Notes on behavior</a></h2>
<ul>
<li>Virtual joins clamp traversal lexically to the virtual root; system-facing escapes (e.g., via symlinks/junctions) are rejected during resolution.</li>
<li>We do not normalize Unicode; you can store/display NFC or NFD forms as-is. Both are contained safely.</li>
<li>Hard links and privileged mount tricks are outside the scope of path-level protections (see README limitations).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices--guidelines"><a class="header" href="#best-practices--guidelines">Best Practices &amp; Guidelines</a></h1>
<p>This page distills how to use strict-path correctly and ergonomically. Pair it with the Anti‑Patterns page for tell‑offs to avoid.</p>
<h2 id="why-every-simple-solution-fails"><a class="header" href="#why-every-simple-solution-fails">Why Every "Simple" Solution Fails</a></h2>
<p>The path security rabbit hole is deeper than you think. Here's why every naive approach creates new vulnerabilities:</p>
<h3 id="approach-1-just-check-for-"><a class="header" href="#approach-1-just-check-for-">Approach 1: "Just check for <code>../</code>"</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if path.contains("../") { return Err("Invalid path"); }
// ✅ Blocks: "../../../etc/passwd"
// ❌ Bypassed by: "..%2F..%2F..%2Fetc%2Fpasswd" (URL encoding)
// ❌ Bypassed by: "....//....//etc//passwd" (double encoding)
// ❌ Bypassed by: "..\\..\\..\etc\passwd" (Windows separators)
<span class="boring">}</span></code></pre></pre>
<h3 id="approach-2-use-canonicalize-then-check"><a class="header" href="#approach-2-use-canonicalize-then-check">Approach 2: "Use canonicalize() then check"</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let canonical = fs::canonicalize(path)?;
if !canonical.starts_with("/safe/") { return Err("Escape attempt"); }
// ✅ Blocks: Most directory traversal
// ❌ CVE-2022-21658: Race condition - symlink created between canonicalize and check
// ❌ CVE-2019-9855: Windows 8.3 names ("PROGRA~1" → "Program Files")
// ❌ Fails on non-existent files (can't canonicalize what doesn't exist)
<span class="boring">}</span></code></pre></pre>
<h3 id="approach-3-normalize-the-path-first"><a class="header" href="#approach-3-normalize-the-path-first">Approach 3: "Normalize the path first"</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let normalized = path.replace("\\", "/").replace("../", "");
// ✅ Blocks: Basic traversal
// ❌ Bypassed by: "....//" → "../" after one replacement
// ❌ CVE-2020-12279: Unicode normalization attacks
// ❌ CVE-2017-17793: NTFS Alternate Data Streams ("file.txt:hidden")
// ❌ Misses absolute path replacement: "/etc/passwd" completely replaces base
<span class="boring">}</span></code></pre></pre>
<h3 id="approach-4-use-a-allowlist-of-safe-characters"><a class="header" href="#approach-4-use-a-allowlist-of-safe-characters">Approach 4: "Use a allowlist of safe characters"</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !path.chars().all(|c| c.is_alphanumeric() || c == '/') { return Err("Invalid"); }
// ✅ Blocks: Most special characters
// ❌ Still vulnerable to: "/etc/passwd" (absolute path replacement)
// ❌ Too restrictive: blocks legitimate files like "report-2025.pdf"
// ❌ CVE-2025-8088: Misses platform-specific issues (Windows UNC, device names)
<span class="boring">}</span></code></pre></pre>
<h3 id="approach-5-combine-multiple-checks"><a class="header" href="#approach-5-combine-multiple-checks">Approach 5: "Combine multiple checks"</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check for ../, canonicalize, validate prefix, sanitize chars...
// ✅ Blocks: Many attack vectors
// ❌ Complex = Buggy: 20+ edge cases, hard to maintain
// ❌ Platform-specific gaps: Windows vs Unix behavior differences  
// ❌ Performance cost: Multiple filesystem calls per validation
// ❌ Future CVEs: New attack vectors require updating every check
<span class="boring">}</span></code></pre></pre>
<h3 id="the-fundamental-problem"><a class="header" href="#the-fundamental-problem">The Fundamental Problem</a></h3>
<p><strong>Each "fix" creates new attack surface.</strong> Path security isn't a single problem—it's a class of problems that interact in complex ways. You need:</p>
<ol>
<li><strong>Encoding normalization</strong> (but not breaking legitimate files)</li>
<li><strong>Symlink resolution</strong> (but preventing race conditions)</li>
<li><strong>Platform consistency</strong> (Windows ≠ Unix ≠ Web)</li>
<li><strong>Boundary enforcement</strong> (mathematical, not string-based)</li>
<li><strong>Future-proof design</strong> (resistant to new attack vectors)</li>
</ol>
<p><strong>This is why strict-path exists.</strong> We solved this problem class once, correctly, so you don't have to.</p>
<h2 id="pick-the-right-type"><a class="header" href="#pick-the-right-type">Pick The Right Type</a></h2>
<h3 id="quick-decision-guide"><a class="header" href="#quick-decision-guide">Quick Decision Guide</a></h3>
<ul>
<li><strong>External/untrusted segments</strong> (HTTP/DB/manifest/LLM/archive entry):
<ul>
<li>UI/virtual flows: start with <code>VirtualPath::with_root(..).virtual_join(..)</code> for clamped joins and user‑facing display. For reuse across many joins, keep either the virtual root path value (<code>let root = VirtualPath::with_root(..)?;</code>) or a <code>VirtualRoot</code> and call <code>virtual_join(..)</code> — both take <code>&amp;self</code> and return a new <code>VirtualPath</code> (no ownership taken).</li>
<li>System flows: start with <code>StrictPath::with_boundary(..).strict_join(..)</code> to reject unsafe joins and for system display. For reuse across many joins, keep a <code>PathBoundary</code> and call <code>strict_join(..)</code>.</li>
</ul>
</li>
<li><strong>Internal/trusted paths</strong> (hardcoded/CLI/env): use <code>Path</code>/<code>PathBuf</code>; only validate when combining with untrusted segments.</li>
</ul>
<h3 id="detailed-decision-matrix"><a class="header" href="#detailed-decision-matrix">Detailed Decision Matrix</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Source</th><th>Typical Input</th><th>Use VirtualPath For</th><th>Use StrictPath For</th><th>Notes</th></tr></thead><tbody>
<tr><td>🌐 <strong>HTTP requests</strong></td><td>URL path segments, file names</td><td>Display/logging, safe virtual joins</td><td>System-facing interop/I/O</td><td>Always clamp user paths via <code>VirtualPath::virtual_join</code></td></tr>
<tr><td>🌍 <strong>Web forms</strong></td><td>Form file fields, route params</td><td>User-facing display, UI navigation</td><td>System-facing interop/I/O</td><td>Treat all form inputs as untrusted</td></tr>
<tr><td>⚙️ <strong>Configuration files</strong></td><td>Paths in config</td><td>UI display and I/O within boundary</td><td>System-facing interop/I/O</td><td>Validate each path before I/O</td></tr>
<tr><td>💾 <strong>Database content</strong></td><td>Stored file paths</td><td>Rendering paths in UI dashboards</td><td>System-facing interop/I/O</td><td>Storage does not imply safety; validate on use</td></tr>
<tr><td>📂 <strong>CLI arguments</strong></td><td>Command-line path args</td><td>Pretty printing, I/O within boundary</td><td>System-facing interop/I/O</td><td>Validate args before touching filesystem</td></tr>
<tr><td>🔌 <strong>External APIs</strong></td><td>Webhooks, 3rd-party payloads</td><td>Present sanitized paths to logs</td><td>System-facing interop/I/O</td><td>Never trust external systems</td></tr>
<tr><td>🤖 <strong>LLM/AI output</strong></td><td>Generated file names/paths</td><td>Display suggestions, I/O within boundary</td><td>System-facing interop/I/O</td><td>LLM output is untrusted by default</td></tr>
<tr><td>📨 <strong>Inter-service msgs</strong></td><td>Queue/event payloads</td><td>Observability output, I/O within boundary</td><td>System-facing interop/I/O</td><td>Validate on the consumer side</td></tr>
<tr><td>📱 <strong>Apps (desktop/mobile)</strong></td><td>Drag-and-drop, file pickers</td><td>Show picked paths in UI</td><td>System-facing interop/I/O</td><td>Validate selected paths before I/O</td></tr>
<tr><td>📦 <strong>Archive contents</strong></td><td>Entry names from ZIP/TAR</td><td>Progress UI, virtual joins</td><td>System-facing interop/I/O</td><td>Validate each entry to block zip-slip</td></tr>
<tr><td>🔧 <strong>File format internals</strong></td><td>Embedded path strings</td><td>Diagnostics, I/O within boundary</td><td>System-facing interop/I/O</td><td>Never dereference without validation</td></tr>
</tbody></table>
</div>
<h3 id="security-philosophy"><a class="header" href="#security-philosophy">Security Philosophy</a></h3>
<p><strong>Think of it this way:</strong></p>
<ul>
<li><code>StrictPath</code> = <strong>Security Filter</strong> — validates and rejects unsafe paths</li>
<li><code>VirtualPath</code> = <strong>Complete Sandbox</strong> — clamps any input to stay safe</li>
</ul>
<p><strong>The Golden Rule</strong>: If you didn't create the path yourself, secure it first.</p>
<h2 id="why-keep-virtualroot-and-pathboundary-even-with-sugar"><a class="header" href="#why-keep-virtualroot-and-pathboundary-even-with-sugar">Why Keep <code>VirtualRoot</code> and <code>PathBoundary</code> (Even With Sugar)</a></h2>
<p>The sugar constructors (<code>StrictPath::with_boundary(..)</code>, <code>VirtualPath::with_root(..)</code>) are great for simple flows, but the root/boundary types still matter for correctness, reuse, and ergonomics as your code grows.</p>
<ul>
<li>
<p>Policy reuse and separation of concerns</p>
<ul>
<li>Roots/boundaries represent the security policy (the restriction) while paths represent validated values within that policy.</li>
<li>Construct once, reuse everywhere: join many untrusted segments against the same <code>&amp;PathBoundary</code>/<code>&amp;VirtualRoot</code> without re‑choosing policy.</li>
<li>Don’t construct boundaries inside helpers — boundary choice is policy; encoding it at call sites improves reviewability and testing.</li>
</ul>
</li>
<li>
<p>Clear function signatures (stronger guarantees)</p>
<ul>
<li>Two canonical patterns that make intent obvious:
<ul>
<li>Take <code>&amp;StrictPath&lt;_&gt;</code> / <code>&amp;VirtualPath&lt;_&gt;</code> when the call site has already validated the input.</li>
<li>Take <code>&amp;PathBoundary&lt;_&gt;</code> / <code>&amp;VirtualRoot&lt;_&gt;</code> plus the untrusted segment when the helper performs validation.</li>
</ul>
</li>
<li>These signatures prevent helpers from “picking a root” silently and make security rules visible in code review.</li>
</ul>
</li>
<li>
<p>Contextual deserialization (serde)</p>
<ul>
<li><code>StrictPath</code>/<code>VirtualPath</code> can’t implement a blanket <code>Deserialize</code> safely — they need runtime context (the boundary/root) to validate.</li>
<li>The serde seeds live on the context types: <code>serde_ext::WithBoundary(&amp;boundary)</code> and <code>serde_ext::WithVirtualRoot(&amp;vroot)</code>.</li>
<li>This makes deserialization explicit and auditable: where did the policy come from? what are we validating against?</li>
</ul>
</li>
<li>
<p>Interop and trait boundaries</p>
<ul>
<li>We intentionally do not implement <code>AsRef&lt;Path&gt;</code> on path types; this prevents leaking raw paths into APIs without review.</li>
<li>Roots/boundaries do implement <code>AsRef&lt;Path&gt;</code> so you can discover/walk directories at the root while keeping joins validated.</li>
<li>Display stays explicit: system display via <code>strictpath_display()</code>, virtual display via <code>virtualpath_display()</code>.</li>
</ul>
</li>
<li>
<p>OS directories and RAII helpers</p>
<ul>
<li>Discovery helpers (<code>try_new_os_*</code>, feature <code>dirs</code>) and temporary roots (<code>try_new_temp*</code>, feature <code>tempfile</code>) are on the root types.</li>
<li>Sugar constructors build on these — you can still start simple and “upgrade” to explicit roots when needed.</li>
</ul>
</li>
<li>
<p>Performance and canonicalization</p>
<ul>
<li>Canonicalize the root once; strict/virtual joins reuse that canonicalized state.</li>
<li>Virtual joins use anchored canonicalization to apply virtual semantics safely and consistently.</li>
</ul>
</li>
<li>
<p>Auditability and testing</p>
<ul>
<li>Centralizing the policy in a root value simplifies logging, tracing, and tests (e.g., pass <code>&amp;vroot</code> into helpers).</li>
<li>Debug for <code>VirtualPath</code> is intentionally verbose (system path + virtual view + restriction root) to aid audits.</li>
</ul>
</li>
</ul>
<p>When not to use them: if your flow is small and local, the sugar constructors are perfectly fine. Start with sugar; keep <code>PathBoundary</code>/<code>VirtualRoot</code> handy for policy reuse, serde, and shared helpers.</p>
<h2 id="encode-guarantees-in-signatures"><a class="header" href="#encode-guarantees-in-signatures">Encode Guarantees In Signatures</a></h2>
<ul>
<li>Helpers that touch the filesystem must encode safety:
<ul>
<li>Accept <code>&amp;StrictPath&lt;_&gt;</code> or <code>&amp;VirtualPath&lt;_&gt;</code> directly, or</li>
<li>Accept <code>&amp;PathBoundary&lt;_&gt;</code> / <code>&amp;VirtualRoot&lt;_&gt;</code> + the untrusted segment.</li>
</ul>
</li>
<li>Don’t construct boundaries/roots inside helpers — boundary choice is policy.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, VirtualRoot, VirtualPath};

fn save_to_storage(p: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; { p.write("ok") }
fn load_from_storage(p: &amp;VirtualPath) -&gt; std::io::Result&lt;String&gt; { p.read_to_string() }

fn create_config(boundary: &amp;PathBoundary, name: &amp;str) -&gt; std::io::Result&lt;()&gt; {
  boundary.strict_join(name)?.write("cfg")
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multiuser-isolation-virtualpath-root"><a class="header" href="#multiuser-isolation-virtualpath-root">Multi‑User Isolation (VirtualPath root)</a></h2>
<ul>
<li>Per‑user/tenant: for small flows, construct a root via <code>VirtualPath::with_root(..)</code> and join untrusted names with <code>virtual_join(..)</code>. For larger flows and reuse, create a <code>VirtualRoot</code> per user and call <code>virtual_join(..)</code>.</li>
<li>Share strict helpers by borrowing the strict view: <code>vpath.as_unvirtual()</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn upload(user_root: &amp;VirtualRoot, filename: &amp;str, bytes: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
  let vpath = user_root.virtual_join(filename)?;
  vpath.create_parent_dir_all()?;
  vpath.write(bytes)
}

// Sugar-first call site (one-off):
// let vroot = VirtualPath::with_root(format!("./cloud/user_{user_id}"))?;
// let vpath = vroot.virtual_join(filename)?; // same guarantees; keep VirtualRoot for reuse
<span class="boring">}</span></code></pre></pre>
<h2 id="interop--display"><a class="header" href="#interop--display">Interop &amp; Display</a></h2>
<ul>
<li>Interop (pass into <code>AsRef&lt;Path&gt;</code> APIs): <code>path.interop_path()</code> (no allocations).</li>
<li>Display:
<ul>
<li>System‑facing: <code>strictpath_display()</code> on <code>PathBoundary</code>/<code>StrictPath</code></li>
<li>User‑facing: <code>virtualpath_display()</code> on <code>VirtualPath</code></li>
</ul>
</li>
<li>Never use <code>interop_path().to_string_lossy()</code> for display.</li>
</ul>
<h2 id="directory-discovery-vs-validation"><a class="header" href="#directory-discovery-vs-validation">Directory Discovery vs Validation</a></h2>
<ul>
<li>Discovery (walking): call <code>boundary.read_dir()</code> (or <code>vroot.read_dir()</code>), collect names via <code>entry.file_name()</code>, then re‑join with <code>strict_join</code>/<code>virtual_join</code> to validate before I/O.</li>
<li>Validation: join those relatives via <code>boundary.strict_join(..)</code> or <code>vroot.virtual_join(..)</code> before I/O. For small flows without a reusable root, you can construct via <code>StrictPath::with_boundary(..)</code> or <code>VirtualPath::with_root(..)</code> and then join.</li>
<li>Don’t validate constants like <code>"."</code>; only validate untrusted segments.</li>
</ul>
<h2 id="operations-use-explicit-methods"><a class="header" href="#operations-use-explicit-methods">Operations (Use Explicit Methods)</a></h2>
<ul>
<li>Joins: <code>strict_join(..)</code> / <code>virtual_join(..)</code></li>
<li>Parents: <code>strictpath_parent()</code> / <code>virtualpath_parent()</code></li>
<li>With file name/ext: <code>strictpath_with_file_name()</code> / <code>virtualpath_with_file_name()</code>, etc.</li>
<li>Rename/move: <code>strict_rename(..)</code> / <code>virtual_rename(..)</code></li>
<li>Deletion: <code>remove_file()</code> / <code>remove_dir()</code> / <code>remove_dir_all()</code></li>
<li>Metadata: <code>metadata()</code> (inspect filesystem info without leaking boundaries)</li>
<li>Avoid std <code>Path::join</code>/<code>parent</code> on leaked paths — they ignore strict/virtual semantics.</li>
</ul>
<p>Example (rename):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, VirtualPath};

fn rotate_log(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let current = boundary.strict_join("logs/app.log")?;
    current.create_parent_dir_all()?;
  current.write("ok")?;

    // Strict rename within same directory
    let rotated = current.strict_rename("logs/app.old")?;
    assert!(rotated.exists());

    // Virtual rename (user-facing path)
    let vp = rotated.clone().virtualize();
    let vp2 = vp.virtual_rename("app.archived")?;
    assert!(vp2.exists());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="naming-from-agentsmd"><a class="header" href="#naming-from-agentsmd">Naming (from AGENTS.md)</a></h2>
<ul>
<li>Variables reflect domain, not type:
<ul>
<li>Good: <code>config_dir</code>, <code>uploads_root</code>, <code>archive_src</code>, <code>mirror_src</code>, <code>user_vroot</code></li>
<li>Bad: <code>boundary</code>, <code>jail</code>, <code>source_</code> prefix</li>
</ul>
</li>
<li>Keep names consistent with the directory they represent (e.g., <code>archive_src</code> for <code>./archive_src</code>).</li>
</ul>
<h2 id="do--dont"><a class="header" href="#do--dont">Do / Don’t</a></h2>
<ul>
<li>Do: validate once at the boundary, pass types through helpers.</li>
<li>Do: use <code>VirtualRoot</code> for per‑user isolation; borrow strict view for shared helpers.</li>
<li>Do: prefer <code>impl AsRef&lt;Path&gt;</code> in helper params where you forward to validation.</li>
<li>Don’t: wrap secure types in <code>Path::new</code>/<code>PathBuf::from</code>.</li>
<li>Don’t: use <code>interop_path().as_ref()</code> or <code>as_unvirtual().interop_path()</code> (use <code>interop_path()</code> directly).</li>
<li>Don’t: use lossy strings for display or comparisons.</li>
</ul>
<h2 id="testing--doctests"><a class="header" href="#testing--doctests">Testing &amp; Doctests</a></h2>
<ul>
<li>Make doctests encode guarantees (signatures) and use the explicit ops.</li>
<li>Create temporary roots via <code>PathBoundary::try_new_create(..)</code> / <code>VirtualRoot::try_new_create(..)</code> in setup; clean up afterwards. Or use the sugar constructors for tests: <code>StrictPath::with_boundary_create(..)</code> / <code>VirtualPath::with_root_create(..)</code>.</li>
<li>For archive/HTTP examples, prefer offline simulations with deterministic inputs.</li>
</ul>
<h2 id="quick-patterns"><a class="header" href="#quick-patterns">Quick Patterns</a></h2>
<ul>
<li>Validate + write:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn write(boundary: &amp;PathBoundary, name: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    let sp = boundary.strict_join(name)?;
    sp.create_parent_dir_all()?;
    sp.write(data)
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Validate archive entry:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extract(vroot: &amp;VirtualRoot, entry: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    let vp = vroot.virtual_join(entry)?;
    vp.create_parent_dir_all()?;
    vp.write(data)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ergonomics-cheatsheet"><a class="header" href="#ergonomics-cheatsheet">Ergonomics Cheatsheet</a></h2>
<ul>
<li>
<p>Built-in I/O: prefer <code>StrictPath</code>/<code>VirtualPath</code> methods over exposing raw <code>Path</code></p>
</li>
<li>
<p>Interop: use <code>interop_path()</code> when passing into <code>AsRef&lt;Path&gt;</code> APIs (no allocations)</p>
</li>
<li>
<p>Avoid anti-patterns: never wrap secure types in <code>Path::new()</code> / <code>PathBuf::from()</code></p>
</li>
<li>
<p>Function signatures: encode policy via marker types in <code>StrictPath&lt;MyMarker&gt;</code> / <code>VirtualPath&lt;MyMarker&gt;</code></p>
</li>
<li>
<p>Equality/ordering: rely on the types’ derived semantics; don’t convert to strings for comparison</p>
</li>
<li>
<p>Escape hatch (borrow): <code>as_unvirtual()</code>; ownership conversions: <code>virtualize()</code> / <code>unvirtual()</code> / <code>unstrict()</code> (use sparingly)</p>
</li>
<li>
<p>Share logic across strict/virtual:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consume_strict(p: &amp;StrictPath) -&gt; std::io::Result&lt;String&gt; { p.read_to_string() }
fn consume_virtual(p: &amp;VirtualPath) -&gt; std::io::Result&lt;String&gt; { consume_strict(p.as_unvirtual()) }
<span class="boring">}</span></code></pre></pre>
<p>See the dedicated Ergonomics section for deeper guidance:</p>
<ul>
<li>Overview: ./ergonomics/overview.md</li>
<li>Interop vs Display: ./ergonomics/interop_display.md</li>
<li>Function Signatures: ./ergonomics/signatures.md</li>
<li>Escape Hatches: ./ergonomics/escape_hatches.md</li>
<li>Equality &amp; Ordering: ./ergonomics/equality_ordering.md</li>
<li>Naming: ./ergonomics/naming.md</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-mistakes-to-avoid"><a class="header" href="#common-mistakes-to-avoid">Common Mistakes to Avoid</a></h1>
<p>Here are the most common mistakes developers make with strict-path, and how to fix them.</p>
<h2 id="the-big-picture-dont-defeat-your-own-security"><a class="header" href="#the-big-picture-dont-defeat-your-own-security">The Big Picture: Don't Defeat Your Own Security</a></h2>
<p>Most anti-patterns come down to one thing: <strong>treating strict-path types like regular paths</strong>. When you convert back to <code>Path</code> or <code>String</code>, you're throwing away the safety you worked to create.</p>
<p>The core principle is: <strong>make functions safe by design</strong>. Instead of accepting raw strings and validating inside every function, accept safe types that guarantee the validation already happened.</p>
<h2 id="security-theater-only-validating-constants"><a class="header" href="#security-theater-only-validating-constants">Security Theater: Only Validating Constants</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_dir = PathBoundary::try_new("./config")?;
let settings = config_dir.strict_join("settings.toml")?;  // Only literals!
let cache = config_dir.strict_join("cache")?;            // No user input validated
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> You're using strict-path but never validating untrusted input. This provides no security value—it's just security theater that looks safe but protects nothing.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_dir = PathBoundary::try_new("./config")?;
// Actually validate untrusted input from users, HTTP, databases, archives, etc.
let user_file = config_dir.strict_join(&amp;user_provided_filename)?;
let archive_entry = config_dir.strict_join(&amp;entry_name_from_zip)?;
let db_path = config_dir.strict_join(&amp;path_from_database)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="hidden-policy-decisions-in-functions"><a class="header" href="#hidden-policy-decisions-in-functions">Hidden Policy Decisions in Functions</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_user_data(filename: &amp;str) -&gt; Result&lt;String, Error&gt; {
    // Policy hidden inside the function!
    let data_dir = PathBoundary::try_new("./userdata")?;
    let file = data_dir.strict_join(filename)?;
    file.read_to_string()
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> Callers can't see or control the security policy. What if they want a different directory? What if different users need different boundaries? The function makes security decisions that should be visible.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_user_data(user_dir: &amp;PathBoundary, filename: &amp;str) -&gt; std::io::Result&lt;String&gt; {
    let file = user_dir.strict_join(filename)?;
    file.read_to_string()
}

// OR even better - accept the validated path directly:
fn load_user_data(file_path: &amp;StrictPath) -&gt; std::io::Result&lt;String&gt; {
    file_path.read_to_string()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="converting-back-to-unsafe-types"><a class="header" href="#converting-back-to-unsafe-types">Converting Back to Unsafe Types</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let safe_path = uploads_dir.strict_join("photo.jpg")?;
// WHY are you converting back to the unsafe Path type?!
if Path::new(safe_path.interop_path()).exists() {
    std::fs::copy(
        Path::new(safe_path.interop_path()), 
        "./backup/photo.jpg"
    )?;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> <code>StrictPath</code> already has <code>.exists()</code>, <code>.read()</code>, <code>.write()</code>, and other methods. You're defeating the entire point by converting back to <code>Path</code>, which ignores all security restrictions.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let safe_path = uploads_dir.strict_join("photo.jpg")?;
if safe_path.exists() {
    let backup_dir = PathBoundary::try_new("./backup")?;
    let backup_path = backup_dir.strict_join("photo.jpg")?;
    safe_path.strict_copy(backup_path.interop_path())?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-std-path-operations-on-leaked-values"><a class="header" href="#using-std-path-operations-on-leaked-values">Using std Path Operations on Leaked Values</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uploads_dir = PathBoundary::try_new("uploads")?;
let leaked = Path::new(uploads_dir.interop_path());
let dangerous = leaked.join("../../../etc/passwd");  // Can escape!
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> <code>Path::join()</code> is the #1 cause of path traversal vulnerabilities. It completely replaces the base path when you pass an absolute path, ignoring all security restrictions.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uploads_dir = PathBoundary::try_new("uploads")?;
// This will return an error instead of escaping:
let safe_result = uploads_dir.strict_join("../../../etc/passwd");
match safe_result {
    Ok(path) =&gt; println!("Safe path: {}", path.strictpath_display()),
    Err(e) =&gt; println!("Rejected dangerous path: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="wrong-display-method"><a class="header" href="#wrong-display-method">Wrong Display Method</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Processing: {}", file.interop_path().to_string_lossy());
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> <code>interop_path()</code> is for passing to external APIs that need <code>AsRef&lt;Path&gt;</code>, like <code>std::fs::File::open()</code>. For displaying to users, it's the wrong tool and can lose information.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Processing: {}", file.strictpath_display());

// For VirtualPath:
println!("Virtual path: {}", vpath.virtualpath_display());

// For VirtualRoot:
println!("Root: {}", vroot.as_unvirtual().strictpath_display());
<span class="boring">}</span></code></pre></pre>
<h2 id="terrible-variable-names"><a class="header" href="#terrible-variable-names">Terrible Variable Names</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let boundary = PathBoundary::try_new("./uploads")?;
let restriction = PathBoundary::try_new("./config")?;
let jail = VirtualRoot::try_new("./user_data")?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> These names tell you the type but nothing about what the directories are for. When you see <code>boundary.strict_join("photo.jpg")</code>, you have no idea what boundary you're joining to.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uploads_dir = PathBoundary::try_new("./uploads")?;
let config_dir = PathBoundary::try_new("./config")?;
let user_data = VirtualRoot::try_new("./user_data")?;
<span class="boring">}</span></code></pre></pre>
<p>Now <code>uploads_dir.strict_join("photo.jpg")</code> reads naturally as "uploads directory join photo.jpg".</p>
<h2 id="functions-that-accept-dangerous-inputs"><a class="header" href="#functions-that-accept-dangerous-inputs">Functions That Accept Dangerous Inputs</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_file(filename: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    // Every function has to validate - error prone!
    let uploads = PathBoundary::try_new("uploads")?;
    let safe_path = uploads.strict_join(filename)?;
    safe_path.write(data)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> Every caller has to trust that this function validates correctly. Someone could call <code>save_file("../../../etc/passwd", data)</code> and you're relying on runtime validation instead of the type system.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_file(safe_path: &amp;StrictPath, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    safe_path.write(data)  // Already guaranteed safe!
}
<span class="boring">}</span></code></pre></pre>
<p>Now it's <strong>impossible</strong> to call this function unsafely. The validation happens once when creating the <code>StrictPath</code>, and the type system prevents all misuse.</p>
<h2 id="multi-user-data-with-single-boundary"><a class="header" href="#multi-user-data-with-single-boundary">Multi-User Data with Single Boundary</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Global boundary for all users - dangerous!
static UPLOADS: PathBoundary = /* ... */;

fn save_user_file(user_id: u64, filename: &amp;str, data: &amp;[u8]) {
    // All users share the same directory - data mixing risk!
    let path = UPLOADS.strict_join(&amp;format!("{}/{}", user_id, filename))?;
    path.write(data)?;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> All users share the same boundary, making it easy to accidentally access another user's files or create insecure paths.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_user_root(user_id: u64) -&gt; Result&lt;VirtualRoot&lt;UserData&gt;, Error&gt; {
    let user_dir = format!("./users/{}", user_id);
    VirtualRoot::try_new(user_dir)
}

fn save_user_file(user_root: &amp;VirtualRoot&lt;UserData&gt;, filename: &amp;str, data: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
    let safe_path = user_root.virtual_join(filename)?.as_unvirtual();
    safe_path.write(data)?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="redundant-method-chaining"><a class="header" href="#redundant-method-chaining">Redundant Method Chaining</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Redundant .as_ref() call
external_api(path.interop_path().as_ref());

// Redundant unvirtualization 
vroot.as_unvirtual().interop_path();  // VirtualRoot already has interop_path()!
<span class="boring">}</span></code></pre></pre>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// interop_path() already implements AsRef&lt;Path&gt;
external_api(path.interop_path());

// VirtualRoot and VirtualPath have interop_path() directly
vroot.interop_path();
vpath.interop_path();
<span class="boring">}</span></code></pre></pre>
<h2 id="quick-reference-bad--good"><a class="header" href="#quick-reference-bad--good">Quick Reference: Bad → Good</a></h2>
<div class="table-wrapper"><table><thead><tr><th>❌ Bad Pattern</th><th>✅ Good Pattern</th></tr></thead><tbody>
<tr><td><code>Path::new(secure_path.interop_path()).exists()</code></td><td><code>secure_path.exists()</code></td></tr>
<tr><td><code>println!("{}", path.interop_path().to_string_lossy())</code></td><td><code>println!("{}", path.strictpath_display())</code></td></tr>
<tr><td><code>fn process(path: &amp;str)</code></td><td><code>fn process(path: &amp;StrictPath&lt;_&gt;)</code></td></tr>
<tr><td><code>let boundary = PathBoundary::try_new(...)?</code></td><td><code>let uploads_dir = PathBoundary::try_new(...)?</code></td></tr>
<tr><td><code>leaked_path.join("child")</code></td><td><code>secure_path.strict_join("child")?</code></td></tr>
<tr><td><code>vroot.as_unvirtual().interop_path()</code></td><td><code>vroot.interop_path()</code></td></tr>
<tr><td><code>path.interop_path().as_ref()</code></td><td><code>path.interop_path()</code></td></tr>
</tbody></table>
</div>
<h2 id="the-golden-rules"><a class="header" href="#the-golden-rules">The Golden Rules</a></h2>
<ol>
<li><strong>Never convert secure types back to <code>Path</code>/<code>PathBuf</code></strong> - use their native methods instead</li>
<li><strong>Make functions accept safe types</strong> - don't validate inside every function</li>
<li><strong>Name variables by purpose, not type</strong> - <code>config_dir</code> not <code>boundary</code></li>
<li><strong>Use the right method for the job</strong> - <code>strictpath_display()</code> for display, <code>interop_path()</code> for external APIs</li>
<li><strong>Let callers control security policy</strong> - don't hide <code>PathBoundary</code> creation inside helpers</li>
<li><strong>Actually validate untrusted input</strong> - don't just validate constants</li>
</ol>
<p>Remember: The whole point of strict-path is to make path operations safe by design. If you find yourself converting back to regular paths or validating inside every function, you're probably doing it wrong!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ergonomics-overview"><a class="header" href="#ergonomics-overview">Ergonomics Overview</a></h1>
<p>This section collects high-signal, copy-pasteable guidance for day-to-day use without re-explaining the security model. Each page is short and focused so you can jump directly to what you need.</p>
<ul>
<li>Interop vs Display: how to pass paths to std/third-party APIs vs how to render them for users.</li>
<li>Function Signatures: encode guarantees in types; when to accept strict/virtual vs roots + segments.</li>
<li>Escape Hatches: borrowing and ownership conversions; when to use them (sparingly).</li>
<li>Equality &amp; Ordering: how comparisons work; what to compare and what not to.</li>
<li>Naming: domain-first naming that teaches intent in code review.</li>
</ul>
<p>For in-depth design and security rationale, see Best Practices and Anti-Patterns. This section stays focused on ergonomics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interop-vs-display"><a class="header" href="#interop-vs-display">Interop vs Display</a></h1>
<ul>
<li>Interop (AsRef<Path>): use <code>interop_path()</code> on <code>StrictPath</code>, <code>VirtualPath</code>, <code>PathBoundary</code>, and <code>VirtualRoot</code>. It borrows the underlying OS path without allocations.</li>
<li>Display to users:
<ul>
<li>System paths: use <code>strictpath_display()</code> (on <code>StrictPath</code>/<code>PathBoundary</code>).</li>
<li>Virtual UI paths: use <code>virtualpath_display()</code> (on <code>VirtualPath</code>).</li>
</ul>
</li>
<li>Never use <code>interop_path().to_string_lossy()</code> for display—mixes concerns and may leak internals.</li>
<li>Do not wrap secure types with <code>Path::new</code> or <code>PathBuf::from</code>.</li>
<li>Directory discovery vs validation:
<ul>
<li>Discover children via <code>read_dir(root.interop_path())</code> or root helpers.</li>
<li>Re-validate names with <code>strict_join()</code>/<code>virtual_join()</code> before any I/O.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h1>
<p>Encode guarantees so misuse is hard:</p>
<ul>
<li>Accept validated paths directly when the caller did validation:
<ul>
<li><code>fn process(file: &amp;StrictPath&lt;MyMarker&gt;) -&gt; io::Result&lt;()&gt; { ... }</code></li>
<li><code>fn read(user_file: &amp;VirtualPath&lt;MyMarker&gt;) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; { ... }</code></li>
</ul>
</li>
<li>Validate inside helpers by accepting policy + untrusted segment:
<ul>
<li><code>fn write(cfg: &amp;PathBoundary&lt;MyMarker&gt;, name: &amp;str) -&gt; io::Result&lt;()&gt; { ... }</code></li>
<li><code>fn upload(vroot: &amp;VirtualRoot&lt;MyMarker&gt;, filename: &amp;str) -&gt; io::Result&lt;()&gt; { ... }</code></li>
</ul>
</li>
<li>Don’t construct boundaries/roots inside helpers—policy lives at the call site.</li>
<li>Prefer domain names over type names: <code>uploads_root</code>, <code>config_dir</code>, <code>user_project_root</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escape-hatches"><a class="header" href="#escape-hatches">Escape Hatches</a></h1>
<p>Use escape hatches sparingly and deliberately.</p>
<ul>
<li>Borrow strict view from virtual: <code>vpath.as_unvirtual()</code> (preferred for shared helpers).</li>
<li>Ownership conversions:
<ul>
<li><code>StrictPath::virtualize()</code> → <code>VirtualPath</code></li>
<li><code>VirtualPath::unvirtual()</code> → <code>StrictPath</code></li>
<li><code>StrictPath::unstrict()</code> → <code>PathBuf</code> (avoid unless you truly need an owned <code>PathBuf</code>)</li>
</ul>
</li>
<li>Avoid chaining escape hatches in application code. If you must own a <code>PathBuf</code>, isolate it in a clearly-marked narrow scope.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality--ordering"><a class="header" href="#equality--ordering">Equality &amp; Ordering</a></h1>
<ul>
<li><code>StrictPath</code> and <code>VirtualPath</code> equality/ordering are based on their underlying system paths (within the same restriction).</li>
<li>Do not compare display strings. Use the types’ built-in Eq/Ord/Hash.</li>
<li>When you need system-path equality in virtual flows, compare via <code>as_unvirtual()</code>.</li>
<li>Avoid lossy or normalization-prone string conversions for comparisons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="naming"><a class="header" href="#naming">Naming</a></h1>
<p>Prefer domain-based names; avoid type-based names.</p>
<ul>
<li>Good: <code>config_dir</code>, <code>uploads_root</code>, <code>archive_src</code>, <code>user_vroot</code>, <code>system_root</code>.</li>
<li>Avoid: <code>boundary</code>, <code>jail</code>, <code>source_</code> prefixes, or one-letter variables.</li>
<li>Keep names consistent with the directory they represent and convey intent in code review.</li>
</ul>
<h3 id="marker-types"><a class="header" href="#marker-types">Marker Types</a></h3>
<ul>
<li>Name markers after the storage domain (<code>struct PublicAssets;</code>, <code>struct BrandEditorWorkspace;</code>). Reviewers should understand the filesystem contents from the type alone.</li>
<li>Skip suffixes like <code>Marker</code>, <code>Type</code>, or <code>Root</code>; they repeat what Rust already communicates. <code>struct MediaLibrary;</code> is clearer than <code>struct MediaLibraryMarker;</code>.</li>
<li>Tuples that pair storage with authorization should keep the resource first and the capability second: <code>StrictPath&lt;(BrandDirectorArchive, FullControlCapability)&gt;</code>.</li>
<li>Focus on what's stored, not who uses it. A marker like <code>BrandAssets</code> tells you the directory contains brand materials, while <code>EditorFiles</code> only tells you someone called "Editor" uses it. The marker describes the filesystem contents and access policy, not the caller's identity.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choosing-canonicalized-vs-lexical-solution"><a class="header" href="#choosing-canonicalized-vs-lexical-solution">Choosing Canonicalized vs Lexical Solution</a></h1>
<p>Scope: strict-path always uses canonicalized path security. There is no “lexical mode” in this crate. When we say “lexical,” we mean using a different crate that only does string/segment checks. This page helps you decide when to use strict-path (canonicalized) versus when a lexical-only crate might be acceptable.</p>
<p>New here? This page helps you pick the right approach without security footguns.</p>
<p>In one sentence: Prefer the “canonicalized” approach unless you 100% control the environment and have tests proving your assumptions. Lexical (in other crates) is for rare, performance‑critical hot paths with strong guarantees.</p>
<h2 id="first-what-do-these-words-mean"><a class="header" href="#first-what-do-these-words-mean">First: What do these words mean?</a></h2>
<ul>
<li>Canonicalized (what strict-path does): We ask the OS to resolve the real, absolute path before deciding if it’s safe. This resolves symlinks/junctions and normalizes platform‑specific quirks (like Windows 8.3 short names, UNC, ADS). That way, sneaky inputs can’t trick simple string checks.</li>
<li>Lexical (other crates): We treat the path like plain text and only do string/segment checks (no OS resolution). It can be fast, but it doesn’t see what’s really on disk.</li>
</ul>
<h2 id="why-you-probably-want-canonicalized-ie-strict-path"><a class="header" href="#why-you-probably-want-canonicalized-ie-strict-path">Why you probably want canonicalized (i.e., strict-path)</a></h2>
<ul>
<li>Defends against real‑world attacks: directory traversal (../../../), symlink swaps, aliasing (8.3 short names like <code>PROGRA~1</code>), UNC/verbatim forms, ADS, Unicode normalization tricks.</li>
<li>Works across platforms the same way.</li>
<li>Matches “zero‑trust” handling for inputs from HTTP, config files, databases, archives, and LLMs.</li>
</ul>
<p>Trade‑off: a bit more I/O work to ask the filesystem what’s actually there.</p>
<h2 id="when-lexical-other-crates-can-be-ok"><a class="header" href="#when-lexical-other-crates-can-be-ok">When lexical (other crates) can be OK</a></h2>
<p>Only consider lexical if ALL of these are true:</p>
<ul>
<li>No symlinks/junctions/mounts in the relevant tree</li>
<li>Inputs are already normalized (no weird separators or encodings)</li>
<li>You own the environment (e.g., an internal tool in a sealed container)</li>
<li>You have tests that enforce the above (so a future change doesn’t silently break safety)</li>
</ul>
<p>If you’re unsure, use strict-path (canonicalized).</p>
<h2 id="fast-decision-guide"><a class="header" href="#fast-decision-guide">Fast decision guide</a></h2>
<ul>
<li>Is the input from users, files, network, LLMs, or archives? → Use strict-path (canonicalized: <code>StrictPath</code>/<code>VirtualPath</code>).</li>
<li>Is this a perf‑critical inner loop on paths you generate yourself and you’ve proven there are no symlinks? → A lexical-only crate might be acceptable.</li>
<li>Mixed or uncertain? → Use strict-path (canonicalized).</li>
</ul>
<h2 id="concrete-examples"><a class="header" href="#concrete-examples">Concrete examples</a></h2>
<ul>
<li>
<p>“User uploads a file named <code>../../etc/passwd</code>”</p>
<ul>
<li>strict-path (canonicalized): Rejected or clamped safely; cannot escape the root.</li>
<li>lexical-only crate: Traversal may be blocked, but symlinks or platform quirks can still break containment.</li>
</ul>
</li>
<li>
<p>“Windows machine with <code>C:\Program Files</code> also visible as <code>C:\PROGRA~1</code>”</p>
<ul>
<li>strict-path (canonicalized): Treats both as the same real place; escape attempts fail.</li>
<li>lexical-only crate: A clever alias or hidden symlink may trick a simple prefix check—even if traversal is blocked.</li>
</ul>
</li>
</ul>
<h2 id="short-recipes"><a class="header" href="#short-recipes">Short recipes</a></h2>
<ul>
<li>
<p>strict-path (canonicalized, default):</p>
<ul>
<li>Validate via a boundary/root, then operate through <code>StrictPath</code>/<code>VirtualPath</code> methods.</li>
<li>Accept <code>&amp;StrictPath&lt;_&gt;</code>/<code>&amp;VirtualPath&lt;_&gt;</code> in helpers, or accept a <code>&amp;PathBoundary/_VirtualRoot</code> plus the untrusted segment.</li>
</ul>
</li>
<li>
<p>If you intentionally use a lexical-only crate (advanced):</p>
<ul>
<li>Keep lexical checks isolated and documented; add tests that assert “no symlinks / normalized inputs”.</li>
<li>If the situation changes later, migrate back to strict-path with minimal refactors because your signatures stayed explicit.</li>
</ul>
</li>
</ul>
<p>See also:</p>
<ul>
<li>Ergonomics → Interop vs Display</li>
<li>README → “Where This Makes Sense”</li>
</ul>
<blockquote>
<p>"Lexical checks aren't just about traversal—symlinks and platform quirks are the real troublemakers."</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-decisions---guide-for-the-frustrated-rustacean"><a class="header" href="#design-decisions---guide-for-the-frustrated-rustacean">Design Decisions - Guide for the Frustrated Rustacean</a></h1>
<p>Since this is a security crate, I took on myself more design decision liberties towards increased security, correctness and avoidance of misuse.</p>
<h2 id="the-journey-from-ergonomic-to-secure"><a class="header" href="#the-journey-from-ergonomic-to-secure">The Journey: From Ergonomic to Secure</a></h2>
<p>The initial prototype had straightforward ergonomics, with non-original, boring API. Which is normally good and required design. Easy transitions between types and common method names.</p>
<p>As I was generating code using different LLMs, a disaster unfolded. <strong>The LLM did not use the API correctly at all!</strong> It constantly worked its way around safety features and since it was generating a lot of code, it became harder to have code review and easy to miss an introduced vulnerability by the LLM.</p>
<p>That had me realize that since LLM Agents is all that is happening nowadays, I had to think carefully about how to guide it towards correct usage of my API in a way that a human will also benefit from.</p>
<h2 id="security-measures-taken"><a class="header" href="#security-measures-taken">Security Measures Taken</a></h2>
<h3 id="llm-aware-documentation"><a class="header" href="#llm-aware-documentation">LLM-Aware Documentation</a></h3>
<ul>
<li><strong>Complete API summary file dedicated to an LLM</strong> - <a href="https://github.com/DK26/strict-path-rs/blob/main/LLM_API_REFERENCE.md"><code>LLM_API_REFERENCE.md</code></a> provides usage-first guidance</li>
<li><strong>Code comments in a style that tooling agents can reason with</strong> - Explicit function documentation with SUMMARY/PARAMETERS/RETURNS/ERRORS/EXAMPLE sections</li>
</ul>
<h3 id="api-design-philosophy"><a class="header" href="#api-design-philosophy">API Design Philosophy</a></h3>
<ul>
<li><strong>Highly explicit API</strong> - Easy to review and detect errors by method names
<ul>
<li><code>strictpath_display()</code> vs <code>virtualpath_display()</code> instead of generic <code>display()</code></li>
<li><code>strict_join()</code> vs <code>virtual_join()</code> instead of generic <code>join()</code></li>
<li><code>interop_path()</code> for third-party integration instead of hidden <code>AsRef&lt;Path&gt;</code> impls</li>
</ul>
</li>
<li><strong>Best practices vs anti-patterns in docs</strong> - Clear guidance on what to do and what to avoid</li>
<li><strong>Minimal API surface</strong> - Less ways to get it wrong</li>
<li><strong>Safe built-in I/O operations</strong> - <code>read_to_string()</code>, <code>write()</code>, <code>create_file()</code> on the secure types</li>
<li><strong>Type-based security</strong> - Markers enforce boundaries at compile time</li>
</ul>
<h2 id="the-path-extension-trait-decision"><a class="header" href="#the-path-extension-trait-decision">The Path Extension Trait Decision</a></h2>
<p>I was thinking about having an extension trait for <code>Path</code>/<code>PathBuf</code>, to introduce built-in I/O methods just like we have in our <code>StrictPath</code> and <code>VirtualPath</code>. The idea was to keep the code nice and consistent, since using <code>Path</code> and <code>PathBuf</code> are legit in some contexts.</p>
<p>However, I realized <strong>it is far quicker to notice we are using the wrong Path type</strong>. The moment we see old-style code for I/O, it helps ask questions like:</p>
<blockquote>
<p>"Why do we use regular Path here? Is this legit?"</p>
</blockquote>
<p>And that's awesome for code review and overall security! 🛡️</p>
<h2 id="why-this-matters-for-you"><a class="header" href="#why-this-matters-for-you">Why This Matters for You</a></h2>
<h3 id="human-benefits"><a class="header" href="#human-benefits">Human Benefits</a></h3>
<ul>
<li><strong>Code review clarity</strong> - Suspicious patterns are immediately visible</li>
<li><strong>Intention signaling</strong> - Method names communicate security guarantees</li>
<li><strong>Compile-time safety</strong> - Type system prevents mixing secure and insecure paths</li>
</ul>
<h3 id="llm-agent-benefits"><a class="header" href="#llm-agent-benefits">LLM Agent Benefits</a></h3>
<ul>
<li><strong>Explicit guidance</strong> - Clear documentation prevents misuse</li>
<li><strong>Fewer escape hatches</strong> - Limited ways to bypass security</li>
<li><strong>Pattern recognition</strong> - Consistent naming helps AI understand correct usage</li>
</ul>
<h2 id="examples-of-security-first-design"><a class="header" href="#examples-of-security-first-design">Examples of Security-First Design</a></h2>
<h3 id="-what-we-could-have-done-ergonomic-but-dangerous"><a class="header" href="#-what-we-could-have-done-ergonomic-but-dangerous">❌ What We Could Have Done (Ergonomic but Dangerous)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hypothetical "ergonomic" design - DON'T DO THIS
let path: StrictPath&lt;_&gt; = boundary.join(user_input)?;  // Generic method
let content = std::fs::read_to_string(path)?;          // Easy to bypass
<span class="boring">}</span></code></pre></pre>
<h3 id="-what-we-actually-do-explicit-and-secure"><a class="header" href="#-what-we-actually-do-explicit-and-secure">✅ What We Actually Do (Explicit and Secure)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Actual secure design - explicit and reviewable
let path: StrictPath&lt;_&gt; = boundary.strict_join(user_input)?;  // Clearly strict
let content = path.read_to_string()?;                        // Built-in secure I/O
<span class="boring">}</span></code></pre></pre>
<p>The second example makes it immediately clear:</p>
<ol>
<li>We're operating in strict mode (<code>strict_join</code>)</li>
<li>We're using built-in secure I/O (no raw <code>std::fs</code>)</li>
<li>The path type carries security guarantees</li>
</ol>
<h2 id="the-result"><a class="header" href="#the-result">The Result</a></h2>
<p>This design philosophy has proven effective in practice:</p>
<ul>
<li><strong>Reduced vulnerabilities</strong> - Harder to accidentally introduce path traversal</li>
<li><strong>Better code reviews</strong> - Security issues are immediately visible</li>
<li><strong>LLM-compatible</strong> - AI agents use the API correctly when following the documentation</li>
<li><strong>Human-friendly</strong> - Developers understand the security implications at a glance</li>
</ul>
<p>Remember: <strong>Security-critical crates should prioritize correctness over ergonomics</strong>. A slightly more verbose API that prevents vulnerabilities is infinitely better than an elegant API that's easy to misuse.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design--internals"><a class="header" href="#design--internals">Design &amp; Internals</a></h1>
<blockquote>
<p><strong>⚠️ CONTRIBUTOR DOCUMENTATION</strong><br />
This section is for contributors, library developers, and curious developers who want to understand how strict-path works internally.</p>
</blockquote>
<p>If you're just using strict-path in your project, you probably want:</p>
<ul>
<li><a href="./chapter_1.html">Getting Started</a> - Learn the basic API</li>
<li><a href="./examples.html">Real-World Examples</a> - See practical usage patterns</li>
</ul>
<h2 id="whats-in-this-section"><a class="header" href="#whats-in-this-section">What's in This Section</a></h2>
<p>This section covers the internal design decisions and patterns that make strict-path secure and maintainable:</p>
<h3 id="type-history-design-pattern"><a class="header" href="#type-history-design-pattern">Type-History Design Pattern</a></h3>
<p>The core security mechanism that uses Rust's type system to enforce that paths go through required validation steps in the correct order. This prevents accidentally using unvalidated paths and makes security guarantees compile-time checked rather than runtime hopes.</p>
<p><a href="./type_history_design.html">Read about Type-History →</a></p>
<h2 id="for-contributors"><a class="header" href="#for-contributors">For Contributors</a></h2>
<p>If you're contributing to strict-path, understanding these internals will help you:</p>
<ul>
<li>Maintain the security guarantees</li>
<li>Add new features safely</li>
<li>Understand why certain design decisions were made</li>
<li>Write tests that verify the type-level constraints</li>
</ul>
<p>The design patterns used here can also be applied to other security-critical Rust libraries where you need compile-time guarantees about data processing pipelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-history-design-pattern-1"><a class="header" href="#type-history-design-pattern-1">Type-History Design Pattern</a></h1>
<h2 id="the-problem-were-solving"><a class="header" href="#the-problem-were-solving">The Problem We're Solving</a></h2>
<p>Imagine you're writing code that needs to safely process data through multiple steps. You need to:</p>
<ol>
<li>Take raw input from an untrusted source</li>
<li>Clean/sanitize it</li>
<li>Validate it meets requirements</li>
<li>Transform it to final form</li>
<li>Only then use it for critical operations</li>
</ol>
<p>The problem? It's really easy to forget a step, or do them in the wrong order. And if you mess up, you might have bugs, security vulnerabilities, or data corruption.</p>
<p><strong>What if the compiler could remember which steps you've completed and enforce the correct order?</strong></p>
<p>That's exactly what the Type-History pattern does.</p>
<h2 id="type-history-in-simple-terms"><a class="header" href="#type-history-in-simple-terms">Type-History in Simple Terms</a></h2>
<p>The Type-History pattern is like having a checklist that follows your data around. Each time you complete a step, you get a new "stamp" on your checklist. Functions can then require that certain stamps are present before they'll work with your data.</p>
<p>Here's a simple example with strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These are our "stamps"
struct Raw;          // Just created, no processing yet
struct Trimmed;      // Whitespace has been removed
struct Validated;    // Content has been checked

// This is our wrapper that carries both data and stamps
struct ProcessedString&lt;History&gt; {
    content: String,
    _stamps: std::marker::PhantomData&lt;History&gt;, // Invisible stamps
}

// Start with a raw string
impl ProcessedString&lt;Raw&gt; {
    fn new(s: String) -&gt; Self {
        ProcessedString { 
            content: s, 
            _stamps: std::marker::PhantomData 
        }
    }
}

// Any string can be trimmed, adding a "Trimmed" stamp
impl&lt;H&gt; ProcessedString&lt;H&gt; {
    fn trim(self) -&gt; ProcessedString&lt;(H, Trimmed)&gt; {
        ProcessedString {
            content: self.content.trim().to_string(),
            _stamps: std::marker::PhantomData,
        }
    }
}

// Only trimmed strings can be validated
impl&lt;H&gt; ProcessedString&lt;(H, Trimmed)&gt; {
    fn validate(self) -&gt; Result&lt;ProcessedString&lt;((H, Trimmed), Validated)&gt;, &amp;'static str&gt; {
        if self.content.is_empty() {
            Err("String cannot be empty")
        } else {
            Ok(ProcessedString {
                content: self.content,
                _stamps: std::marker::PhantomData,
            })
        }
    }
}

// This function only accepts fully processed strings
fn save_to_database(s: &amp;ProcessedString&lt;((Raw, Trimmed), Validated)&gt;) {
    // We know this string has been trimmed AND validated
    println!("Safely saving: {}", s.content);
}
<span class="boring">}</span></code></pre></pre>
<p>Now look what happens when you use it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This works - we follow the correct steps
let s = ProcessedString::new("  hello world  ".to_string())
    .trim()           // Now has (Raw, Trimmed) stamps
    .validate()?;     // Now has ((Raw, Trimmed), Validated) stamps

save_to_database(&amp;s); // ✅ Compiles fine

// This won't compile - we skipped trimming!
let bad = ProcessedString::new("hello".to_string())
    .validate()?;     // This line itself won't compile!

// This won't compile either - missing validation
let also_bad = ProcessedString::new("hello".to_string())
    .trim();
save_to_database(&amp;also_bad); // ❌ Compilation error
<span class="boring">}</span></code></pre></pre>
<h2 id="other-applications-of-type-history"><a class="header" href="#other-applications-of-type-history">Other Applications of Type-History</a></h2>
<p>The Type-History pattern is useful anywhere you have multi-step data processing that must be done correctly:</p>
<h3 id="network-request-processing"><a class="header" href="#network-request-processing">Network Request Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Raw;
struct Authenticated;
struct RateLimited;
struct Validated;

struct Request&lt;H&gt; {
    data: RequestData,
    _history: PhantomData&lt;H&gt;,
}

// Must authenticate, then rate-limit, then validate
fn handle_request(req: &amp;Request&lt;(((Raw, Authenticated), RateLimited), Validated)&gt;) {
    // We know this request is safe to process
}
<span class="boring">}</span></code></pre></pre>
<h3 id="financial-transaction-processing"><a class="header" href="#financial-transaction-processing">Financial Transaction Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Raw;
struct AmountValidated;
struct FundsChecked;
struct Authorized;

struct Transaction&lt;H&gt; {
    amount: Decimal,
    from: AccountId,
    to: AccountId,
    _history: PhantomData&lt;H&gt;,
}

// Critical: must validate amount, check funds, get authorization
fn execute_transfer(tx: &amp;Transaction&lt;(((Raw, AmountValidated), FundsChecked), Authorized)&gt;) {
    // Guaranteed to be safe for execution
}
<span class="boring">}</span></code></pre></pre>
<h3 id="database-query-building"><a class="header" href="#database-query-building">Database Query Building</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Raw;
struct Sanitized;
struct Parameterized;
struct Validated;

struct Query&lt;H&gt; {
    sql: String,
    params: Vec&lt;Value&gt;,
    _history: PhantomData&lt;H&gt;,
}

// Must sanitize inputs, parameterize query, validate syntax
fn execute_query(q: &amp;Query&lt;(((Raw, Sanitized), Parameterized), Validated)&gt;) {
    // Safe from SQL injection
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-this-applies-to-strict-path"><a class="header" href="#how-this-applies-to-strict-path">How This Applies to strict-path</a></h2>
<p>For file paths, security is critical. We need to ensure that every path goes through the right checks in the right order:</p>
<ol>
<li><strong>Canonicalize</strong>: Resolve <code>.</code>, <code>..</code>, symlinks, etc.</li>
<li><strong>Boundary Check</strong>: Make sure the path is within our jail</li>
<li><strong>Existence Check</strong>: Verify the path actually exists (if needed)</li>
</ol>
<p>Using Type-History, we can make it impossible to use a path that hasn't been properly validated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These are the stamps for paths
struct Raw;               // Fresh from user input
struct Canonicalized;     // Cleaned up and resolved
struct BoundaryChecked;   // Verified to be within jail bounds
struct Exists;           // Confirmed to exist on filesystem

// Our internal path wrapper (you rarely see this directly)
struct PathHistory&lt;History&gt; {
    path: PathBuf,
    _stamps: std::marker::PhantomData&lt;History&gt;,
}

// Only canonicalized AND boundary-checked paths can be used for I/O
fn safe_file_operation(path: &amp;PathHistory&lt;((Raw, Canonicalized), BoundaryChecked)&gt;) {
    // We KNOW this path is safe to use
    std::fs::read_to_string(&amp;path.path).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="reading-the-type-signatures"><a class="header" href="#reading-the-type-signatures">Reading the Type Signatures</a></h2>
<p>The stamp history is written as nested tuples. Read them left-to-right to see the sequence:</p>
<ul>
<li><code>PathHistory&lt;Raw&gt;</code> = Just created, no processing</li>
<li><code>PathHistory&lt;(Raw, Canonicalized)&gt;</code> = Created, then canonicalized</li>
<li><code>PathHistory&lt;((Raw, Canonicalized), BoundaryChecked)&gt;</code> = Created, then canonicalized, then boundary-checked</li>
</ul>
<p>It's like reading a receipt that shows every step that was completed.</p>
<h2 id="why-not-just-use-booleans"><a class="header" href="#why-not-just-use-booleans">Why Not Just Use Booleans?</a></h2>
<p>You might wonder: "Why not just have a struct with boolean fields like <code>is_canonicalized</code> and <code>is_boundary_checked</code>?"</p>
<p>The problem with booleans is that they can lie:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ With booleans, you can fake it
struct UnsafePath {
    path: PathBuf,
    is_canonicalized: bool,    // I can set this to `true`
    is_boundary_checked: bool, // even if I never actually did the checks!
}

let fake_safe = UnsafePath {
    path: PathBuf::from("../../../etc/passwd"),
    is_canonicalized: true,    // Lies!
    is_boundary_checked: true, // More lies!
};
<span class="boring">}</span></code></pre></pre>
<p>With Type-History, you literally cannot create a value with the wrong stamps unless you actually performed the operations. The type system enforces honesty.</p>
<h2 id="the-public-api-hides-the-complexity"><a class="header" href="#the-public-api-hides-the-complexity">The Public API Hides the Complexity</a></h2>
<p>Users of strict-path never see <code>PathHistory</code> directly. Instead, they work with simple types like <code>StrictPath</code> and <code>VirtualPath</code>. But internally, these types contain properly stamped paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// What users see
pub struct StrictPath&lt;Marker&gt; {
    // What's hidden inside: a path that's been through the full validation pipeline
    inner: PathHistory&lt;((Raw, Canonicalized), BoundaryChecked)&gt;,
    // ... other fields
}

// Users just call simple methods
let safe_dir = PathBoundary::try_new_create("safe_dir")?;
let safe_user_file = safe_dir.strict_join("user_file.txt")?; // Returns StrictPath

// But the type system guarantees this path is safe to use
<span class="boring">}</span></code></pre></pre>
<h2 id="benefits-of-this-approach"><a class="header" href="#benefits-of-this-approach">Benefits of This Approach</a></h2>
<ol>
<li><strong>Impossible to Forget Steps</strong>: The compiler prevents you from skipping required processing</li>
<li><strong>Self-Documenting Code</strong>: Function signatures clearly show what processing is required</li>
<li><strong>Refactor-Safe</strong>: If you change the processing pipeline, the compiler finds all places that need updates</li>
<li><strong>Zero Runtime Cost</strong>: All the type checking happens at compile time - no performance overhead</li>
<li><strong>Audit-Friendly</strong>: Security reviewers can see exactly what guarantees each function requires</li>
</ol>
<h2 id="when-to-use-type-history"><a class="header" href="#when-to-use-type-history">When to Use Type-History</a></h2>
<p>This pattern is overkill for simple cases, but it's valuable when:</p>
<ul>
<li>Security is critical (like file path validation)</li>
<li>You have a multi-step process that must be done in order</li>
<li>Skipping steps could cause bugs or vulnerabilities</li>
<li>You want to encode important guarantees in the type system</li>
<li>Multiple functions need different combinations of processing steps</li>
</ul>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping Up</a></h2>
<p>The Type-History pattern might seem complex at first, but it's really just a way to make the compiler remember what you've done and enforce what you need to do. It turns potential runtime errors into compile-time guarantees.</p>
<p>In strict-path, this means that once you have a <code>StrictPath</code> or <code>VirtualPath</code>, you can be 100% confident it's safe to use - the type system guarantees it went through all the necessary security checks.</p>
<p>For most users of strict-path, you don't need to understand these internals. Just know that the library uses advanced type system features to make it impossible to accidentally create security vulnerabilities. The compiler has your back!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-journey-to-strict-path"><a class="header" href="#the-journey-to-strict-path">The Journey to strict-path</a></h1>
<h2 id="why-do-i-need-this-library"><a class="header" href="#why-do-i-need-this-library">Why Do I Need This Library?</a></h2>
<p>The development of <code>strict-path</code> is a story of discovering security gaps in path handling and iteratively building a comprehensive solution. Here's the complete development journey that led to the creation of this crate.</p>
<h3 id="why-use-this-crate-tldr"><a class="header" href="#why-use-this-crate-tldr">Why Use This Crate (TL;DR)</a></h3>
<p>Path security is not about comparing strings. It requires:</p>
<ul>
<li>Full normalization/canonicalization that works even when targets don’t exist</li>
<li>Safe symlink/junction handling (with cycle detection and boundary enforcement)</li>
<li>Windows-specific defenses (8.3 short names, UNC/verbatim prefixes, ADS)</li>
<li>Unicode/encoding awareness (mixed separators, normalization differences)</li>
</ul>
<p><code>strict-path</code> solves this class of problems comprehensively, then encodes the guarantees in the type system. If a <code>StrictPath&lt;Marker&gt;</code> exists, it’s proven to be inside its boundary by construction.</p>
<h2 id="the-development-process-story"><a class="header" href="#the-development-process-story">The Development Process Story</a></h2>
<h3 id="the-simple-beginning"><a class="header" href="#the-simple-beginning">The Simple Beginning</a></h3>
<p>It started as an apparently simple idea for a crate that validates paths by making sure they are within an expected boundary, using canonicalization. The concept was straightforward: create a type that validates the correct path (<code>PathValidator</code>) and a generated byproduct that serves as proof of validation (<code>JailedPath</code>).</p>
<p>That wasn't too hard to do... except...</p>
<h3 id="the-first-major-obstacle"><a class="header" href="#the-first-major-obstacle">The First Major Obstacle</a></h3>
<p><strong>The std::canonicalize Problem</strong>: Rust's standard library <code>canonicalize()</code> could only accept and work with paths that already exist. This was a fundamental limitation that broke the entire concept.</p>
<p><strong>Existing Crates Were Insufficient</strong>: Other Rust crates were only offering lexical path resolution, ignoring symlinks and unable to deliver the promise of canonicalized/realpath values without demanding that the target path must exist.</p>
<p>This was a big problem! How could I validate that a location for a future file is within a legal boundary if the file doesn't exist yet?</p>
<h3 id="the-python-inspiration"><a class="header" href="#the-python-inspiration">The Python Inspiration</a></h3>
<p>A quick search revealed that Python had already faced this exact problem and solved it in Python 3.6 by adding the following feature: <code>pathlib.Path.resolve(strict=False)</code>.</p>
<p>That's when I realized I'd need to create another crate! One that mimics that same logic—both to solve my problem and as an opportunity to give back to the Rust community.</p>
<p><strong>Enter soft-canonicalize</strong>: This became the foundation crate that would enable proper path validation without requiring file existence.</p>
<h3 id="building-soft-canonicalize"><a class="header" href="#building-soft-canonicalize">Building soft-canonicalize</a></h3>
<p>I asked an LLM agent to fetch Python's implementation unit tests, translate them to Rust, and run them over our <code>soft-canonicalize</code> implementation. This revealed gaps in my own implementation and led me to ask for the same algorithm that Python uses (later modified for optimizations and CVE resolutions).</p>
<p>Voilà! I had a working <code>soft-canonicalize</code> crate, so I could publish it and continue work on my jailed-path crate.</p>
<p>From here, the path guarantee became practical: validate first (without requiring existence), then operate safely.</p>
<h3 id="the-marker-type-innovation"><a class="header" href="#the-marker-type-innovation">The Marker Type Innovation</a></h3>
<p>Continuing work on <code>JailedPath</code>, I realized that sometimes we might wish to have more than one validated path, but how could we identify them correctly? That's when I came up with the <strong>Marker type</strong> idea: simply create your very own Marker type, providing additional context for the compiler and allowing us to prevent mixing up paths!</p>
<h3 id="security-research-and-cve-analysis"><a class="header" href="#security-research-and-cve-analysis">Security Research and CVE Analysis</a></h3>
<p>OK, now we have a really cool <code>JailedPath</code> crate! Let's further validate that we are safe by researching CVEs.</p>
<p>Oops! It looked like we had some gaps in our <code>soft-canonicalize</code> crate. That's where I took additional time investing in improving correctness, resilience, and performance. I created comprehensive Python benchmarks where I could validate <code>soft-canonicalize</code> performance vs Python's C language implementation. That took a while to perfect, but it was worth it because it could improve scalability in heavy usage cases.</p>
<h3 id="the-virtual-path-discovery"><a class="header" href="#the-virtual-path-discovery">The Virtual Path Discovery</a></h3>
<p>Researching existing alternatives, I discovered a use case for <strong>virtual paths</strong>—paths that are clamped to a virtual root. This made me reconsider my own use case for creating this crate, revealing a lot of potential.</p>
<p>I started wondering if this should be our default behavior. Eventually, I came to this conclusion: All I needed was a secure, validated Path type. So I applied the KISS method (Keep It Simple, Stupid) and decided that the core <code>JailedPath</code> should represent simply a path that has been validated.</p>
<p>However, there were clear uses for <code>VirtualPath</code>. After long consideration about whether this should be in a different crate, I decided to keep it inside <code>JailedPath</code> because:</p>
<ul>
<li>They share the same foundation</li>
<li>I didn't want to scatter logic across two crates</li>
<li>It's easier to maintain, use, and perform transitions between the two</li>
</ul>
<h3 id="the-great-renaming-journey"><a class="header" href="#the-great-renaming-journey">The Great Renaming Journey</a></h3>
<h4 id="from-pathvalidator-to-jail"><a class="header" href="#from-pathvalidator-to-jail">From PathValidator to Jail</a></h4>
<p>My first gut feeling was that while our <code>PathValidator</code> type was quite self-explanatory, it felt like an extra tool we needed to carry around. I was aiming to simplify the developer experience. <code>PathValidator</code> seemed easy to understand but not fun, with no clear relation to <code>JailedPath</code>.</p>
<p>So I decided to rename <code>PathValidator</code> to <code>Jail</code>. It made sense: we set up a jail and then validate paths against it.</p>
<h4 id="from-jail-to-pathboundary"><a class="header" href="#from-jail-to-pathboundary">From Jail to PathBoundary</a></h4>
<p>Eventually, <code>Jail</code> didn't feel completely right either, only because we were also supporting <code>VirtualPath</code> (created from a <code>VirtualRoot</code>). I realized that a newcomer (or someone returning to code after a long while) might get confused about what behavior to expect from a <code>Jail</code> and <code>JailedPath</code> type.</p>
<h4 id="the-api-surface-problem"><a class="header" href="#the-api-surface-problem">The API Surface Problem</a></h4>
<p>As a result of LLM agents generating faulty code, I could see how the API was being misused. This motivated me to reduce the API surface to the minimum required and ensure all methods are explicit about the difference between <code>JailedPath</code> and <code>VirtualPath</code>. No vague method names (such as <code>as_ref()</code>). No <code>Path</code> type escapes—the LLM would simply defeat the purpose of my crate by calling its inner path and calling <code>.join()</code> on it.</p>
<p><strong>The Problem with .join()</strong>: Calling <code>Path::join()</code> is no longer validated. The path could escape easily. And joining to a full path would completely override the path it's being joined to.</p>
<h4 id="the-three-join-problem"><a class="header" href="#the-three-join-problem">The "Three join() Problem"</a></h4>
<p>This led me to the "Three join() problem"—each time I saw a generated <code>.join()</code> in test code, I had to take a moment following the chain of methods to figure out if a <code>join()</code> belongs to <code>Path</code>, <code>JailedPath</code>, or <code>VirtualPath</code>.</p>
<p>This is where I decided that methods must be explicit. Seeing them in generated code helps immediately notice and understand their behavior:</p>
<ul>
<li><code>jailedpath_join()</code> vs <code>virtualpath_join()</code> vs <code>join()</code></li>
</ul>
<p>Seeing <code>join()</code> in our code would mean unsafe behavior that we could notice immediately.</p>
<p>This explicitness is critical for LLM- and review-friendly code: <code>.strict_join(..)</code>/<code>.virtual_join(..)</code> are visibly safe; raw <code>Path::join</code> stands out as a red flag.</p>
<h4 id="finding-the-right-balance"><a class="header" href="#finding-the-right-balance">Finding the Right Balance</a></h4>
<p>Fixing my demo projects, these methods seemed verbose. Since they were very common, I decided on shorter, easier names:</p>
<ul>
<li><code>jailed_join()</code>, <code>virtual_join()</code></li>
</ul>
<p>But we're back to behavior differences. Seeing <code>jailed_join()</code>, what does it mean? We'd need to refer to docs. While docs are important, wouldn't it be nicer if we could understand from the method name what's happening?</p>
<h4 id="the-final-names"><a class="header" href="#the-final-names">The Final Names</a></h4>
<p>Eventually (and finally), I did another rename:</p>
<ul>
<li><code>JailedPath</code> → <code>StrictPath</code> (clear that the path is restricted!)</li>
<li><code>Jail</code> → <code>PathBoundary</code> (goes hand-in-hand with <code>VirtualRoot</code>)</li>
<li><code>strict_join()</code> vs <code>virtual_join()</code> (perfect clarity!)</li>
</ul>
<h3 id="path-ergonomics-and-safety"><a class="header" href="#path-ergonomics-and-safety">Path Ergonomics and Safety</a></h3>
<p>Path ergonomics were crucial! I wanted to be as ergonomic as possible without breaking our established safety rules—especially not leaking out a <code>Path</code> type that could do a <code>.join()</code>.</p>
<p>Eventually, I came up with <code>.interop_path()</code>. It contains the suffix <code>_path</code> to hint that this is what API users need to interop <code>VirtualPath</code> and <code>StrictPath</code> directly in places where <code>AsRef&lt;Path&gt;</code> is expected. But we do not expose a <code>Path</code> type! Instead, we expose a borrow of an <code>OsStr</code>.</p>
<p>This is perfect! <code>OsStr</code>:</p>
<ul>
<li>Implements <code>AsRef&lt;Path&gt;</code> for integration with everything expecting <code>AsRef&lt;Path&gt;</code></li>
<li>Is cross-platform and fits the underlying operating system</li>
<li>Doesn't lose any data</li>
<li>Is what <code>Path</code> wraps anyway—we're just stripping off all the dangerous methods</li>
<li>Is what <code>Path</code> wraps anyway—we're just stripping off all the dangerous methods</li>
</ul>
<p>Escape hatches exist, but are explicit:</p>
<ul>
<li>Borrow strict from virtual: <code>vpath.as_unvirtual()</code></li>
<li>Ownership conversions: <code>virtualize()</code> / <code>unvirtual()</code> / <code>unstrict()</code> (use sparingly)</li>
</ul>
<h3 id="feature-integration"><a class="header" href="#feature-integration">Feature Integration</a></h3>
<p>I wanted to explore additional features by integrating with popular crates:</p>
<ul>
<li><strong>app-path</strong>: My own crate for easily referring to files near our executable, ensuring operations cannot escape our application directory</li>
<li><strong>dirs</strong>: Cross-platform access to system directories</li>
<li><strong>tempfile</strong>: Generate temporary directories with <code>PathBoundary::try_new_temp()</code></li>
</ul>
<h3 id="api-simplification"><a class="header" href="#api-simplification">API Simplification</a></h3>
<p>I kept improving demo examples and API clarity. Eventually, I realized: <code>StrictPath</code> contains the boundary path within it, just as <code>VirtualRoot</code> contains its root path (which is a <code>StrictPath</code>).</p>
<p>I explored whether we could work with just 2 types: <code>VirtualPath</code> and <code>StrictPath</code>. While possible, it wouldn't be ideal—sometimes we want to be explicit about roots and boundaries as promises.</p>
<p>I decided to keep <code>VirtualRoot</code> and <code>PathBoundary</code> but make common usage more concise with <code>StrictPath::with_boundary()</code> and <code>VirtualPath::with_root()</code>. This made code much more concise while remaining highly readable.</p>
<h3 id="zerotrust-vs-lexical-approaches"><a class="header" href="#zerotrust-vs-lexical-approaches">Zero‑Trust vs Lexical Approaches</a></h3>
<ul>
<li>If you want a zero‑trust approach that covers (almost) everything that can go wrong, prefer canonicalized validation and joins. They resolve symlinks and normalize platform-specific forms before enforcement.</li>
<li>If you need maximum performance and you are absolutely certain symlinks cannot occur and paths are already canonical/normalized, a lexical solution from another crate may fit — but you accept the risk and narrower threat model.</li>
</ul>
<h3 id="the-road-to-publication"><a class="header" href="#the-road-to-publication">The Road to Publication</a></h3>
<p>This was a long journey, but it isn't over yet. It's time to make this crate public, ensuring all generated docs are correct and we don't have leftovers.</p>
<p>The version is now good enough to be the first stable foundation for a security crate! I hope this catches on (I didn't really expect it when I started), and at some point, I began thinking of it as a potential new standard for securing paths.</p>
<p>If this succeeds, I'd like to port it to other programming languages—JavaScript, Java, and Python first! In a way, I hope this will be what prepared statements are for SQL: a fundamental security practice that becomes standard across the ecosystem.</p>
<h2 id="lessons-learned"><a class="header" href="#lessons-learned">Lessons Learned</a></h2>
<p>The journey taught me several important lessons:</p>
<ol>
<li><strong>Security requires iteration</strong>: Each security review revealed new edge cases</li>
<li><strong>API design is crucial</strong>: Small naming decisions have huge impacts on usability</li>
<li><strong>Ergonomics vs Safety</strong>: You can have both, but it requires careful design</li>
<li><strong>Community feedback matters</strong>: LLM-generated code revealed real usage patterns</li>
<li><strong>Standards evolve</strong>: What seems like a simple idea often grows into something much more comprehensive</li>
</ol>
<p>The result is <code>strict-path</code>—a crate that not only solves the original path validation problem but provides a comprehensive, ergonomic, and secure foundation for all path operations in Rust applications.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
