<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Complete StrictPath Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive guide to strict-path: Type-safe path boundaries preventing directory traversal attacks">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Complete StrictPath Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DK26/strict-path-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started-with-strict-path"><a class="header" href="#getting-started-with-strict-path">Getting Started with strict-path</a></h1>
<h2 id="what-is-strict-path"><a class="header" href="#what-is-strict-path">What is strict-path?</a></h2>
<p>Have you ever worried about users trying to access files they shouldn't? Like when someone enters <code>../../../etc/passwd</code> to try to escape from a safe directory? That's called a "directory traversal" attack, and it's surprisingly common.</p>
<p><strong>strict-path strictly enforces path boundaries to prevent directory traversal attacks.</strong> It creates safe boundaries that paths cannot escape from. It comes in two modes: StrictPath (via PathBoundary) which detects and rejects escape attempts, and VirtualPath (via VirtualRoot) which contains and redirects escape attempts within a virtual sandbox.</p>
<h2 id="why-should-you-care"><a class="header" href="#why-should-you-care">Why Should You Care?</a></h2>
<p>Directory traversal vulnerabilities are everywhere:</p>
<ul>
<li>Web applications where users upload files</li>
<li>CLI tools that accept file paths as arguments</li>
<li>Any application that processes user-provided paths</li>
<li>Systems that extract archives (ZIP files, etc.)</li>
</ul>
<p>Getting path security wrong can expose your entire filesystem to attackers. With strict-path, the Rust compiler helps ensure you can't make these mistakes.</p>
<h2 id="your-first-pathboundary"><a class="header" href="#your-first-pathboundary">Your First PathBoundary</a></h2>
<p>Let's start with a simple example. Say you're building a web app where users can upload and download their files, but you want to keep them contained in a specific directory:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::PathBoundary;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a path boundary in the "user_files" directory
    // This creates the directory if it doesn't exist
    let user_files_dir = PathBoundary::try_new_create("user_files")?;

    // Now any path we validate through this path boundary will be contained
    // within the "user_files" directory

    // ✅ This is SAFE - creates "user_files/documents/report.txt"
    let report = user_files_dir.strict_join("documents/report.txt")?;
    report.create_parent_dir_all()?;
    report.write("Quarterly report contents")?;

    // ❌ This would FAIL - can't escape the path boundary!
    // let _bad = user_files_dir.strict_join("../../../etc/passwd")?; // Error!

    let display = report.strictpath_display();
    println!("Safe path: {display}");

    Ok(())
}</code></pre></pre>
<h2 id="what-just-happened"><a class="header" href="#what-just-happened">What Just Happened?</a></h2>
<ol>
<li><strong>Created a path boundary</strong>: <code>PathBoundary::try_new_create("user_files")</code> sets up a safe boundary</li>
<li><strong>Validated a path</strong>: <code>path_boundary.strict_join("documents/report.txt")</code> checks the path is safe</li>
<li><strong>Got protection</strong>: Any attempt to escape the path boundary (like <code>../../../etc/passwd</code>) fails immediately</li>
</ol>
<p>The magic is that once you have a <code>StrictPath</code>, you <em>know</em> it's safe. The type system guarantees it.</p>
<h2 id="working-with-strict-paths"><a class="header" href="#working-with-strict-paths">Working with Strict Paths</a></h2>
<p>Once you have a <code>StrictPath</code>, you can use it for file operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn save_user_file() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads_dir = PathBoundary::try_new_create("uploads")?;

    // User wants to save to "my-document.txt"
    let user_input = "my-document.txt"; // untrusted
    let safe_path = uploads_dir.strict_join(user_input)?;

    // Write some content safely using built-in helpers
    safe_path.write("Hello, world!")?;

    // Read it back
    let content = safe_path.read_to_string()?;
    println!("File contains: {content}");

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="type-safety-the-secret-sauce"><a class="header" href="#type-safety-the-secret-sauce">Type Safety: The Secret Sauce</a></h2>
<p>Here's where strict-path gets really clever. You can write functions that <em>only</em> accept safe paths:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath};

// This function can ONLY be called with safe paths
fn process_user_file(path: &amp;StrictPath) -&gt; std::io::Result&lt;String&gt; {
    // We know this path is safe - no need to validate again
    path.read_to_string()
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let data_dir = PathBoundary::try_new_create("safe_area")?;
    let user_data = data_dir.strict_join("user-data.txt")?;

    // ✅ This works - user_data is a StrictPath
    let _content = process_user_file(&amp;user_data)?;

    // ❌ This won't compile - can't pass an unsafe path!
    // let unsafe_path = std::path::Path::new("/etc/passwd");
    // let _content = process_user_file(unsafe_path); // Compilation error!

    Ok(())
}</code></pre></pre>
<p>This means once you set up your path boundaries correctly, the compiler prevents you from accidentally using unsafe paths.</p>
<h2 id="virtual-paths-user-friendly-sandboxes"><a class="header" href="#virtual-paths-user-friendly-sandboxes">Virtual Paths: User-Friendly Sandboxes</a></h2>
<p>Sometimes you want to give users the illusion that they have their own private filesystem, starting from <code>/</code>. That's what <code>VirtualPath</code> is for:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::VirtualRoot;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a virtual root that maps to "user_123_files" on disk
    let vroot = VirtualRoot::try_new_create("user_123_files")?;

    // User thinks they're working from "/"
    let vpath = vroot.virtual_join("/documents/my-file.txt")?;

    // But it actually maps to "user_123_files/documents/my-file.txt"
    let user_sees = vpath.virtualpath_display();
    let system_path = vpath.as_unvirtual().strictpath_display();
    println!("User sees: {user_sees}");
    println!("Actually stored at: {system_path}");

    Ok(())
}</code></pre></pre>
<p>This is perfect for multi-user applications where each user should feel like they have their own filesystem.</p>
<h3 id="the-critical-difference-symlink-behavior"><a class="header" href="#the-critical-difference-symlink-behavior">The Critical Difference: Symlink Behavior</a></h3>
<p><strong><code>StrictPath</code></strong> validates paths and <strong>rejects</strong> anything that escapes:</p>
<ul>
<li>User input <code>"../../../etc/passwd"</code> → ❌ Error</li>
<li>Symlink pointing to <code>/etc/passwd</code> → ❌ Error (if outside boundary)</li>
</ul>
<p><strong><code>VirtualPath</code></strong> implements true virtual filesystem and <strong>clamps</strong> absolute paths:</p>
<ul>
<li>User input <code>"../../../etc/passwd"</code> → ✅ Clamped to <code>vroot/etc/passwd</code></li>
<li>Symlink pointing to <code>/etc/passwd</code> → ✅ Clamped to <code>vroot/etc/passwd</code></li>
</ul>
<p>This makes <code>VirtualPath</code> perfect for:</p>
<ul>
<li>🗜️ Archive extraction (malicious entries are safely clamped)</li>
<li>🏢 Multi-tenant systems (users can't escape their sandbox)</li>
<li>📦 Container-like environments (absolute paths stay inside)</li>
</ul>
<p><strong>Rule of thumb:</strong> Use <code>StrictPath</code> for system resources (explicit validation), use <code>VirtualPath</code> for user sandboxes (graceful containment).</p>
<h2 id="api-summary"><a class="header" href="#api-summary">API Summary</a></h2>
<p>That's really all you need to know! The core API is simple:</p>
<h3 id="creating-safe-boundaries"><a class="header" href="#creating-safe-boundaries">Creating Safe Boundaries</a></h3>
<ul>
<li><code>PathBoundary::try_new(path)</code> - Use existing directory as path boundary (fails if not found)</li>
<li><code>PathBoundary::try_new_create(path)</code> - Create directory if needed (for setup/initialization)</li>
<li><code>VirtualRoot::try_new(path)</code> - Virtual filesystem root (expects existing directory)</li>
<li><code>VirtualRoot::try_new_create(path)</code> - Create virtual root if needed (for user storage)</li>
</ul>
<h3 id="validating-paths"><a class="header" href="#validating-paths">Validating Paths</a></h3>
<ul>
<li><code>path_boundary.strict_join(user_path)</code> - Returns <code>StrictPath</code> or error</li>
<li><code>vroot.virtual_join(user_path)</code> - Returns <code>VirtualPath</code> or error</li>
</ul>
<h3 id="using-safe-paths"><a class="header" href="#using-safe-paths">Using Safe Paths</a></h3>
<ul>
<li>Both <code>StrictPath</code> and <code>VirtualPath</code> work with standard file operations</li>
<li>They implement <code>.interop_os()</code> so you can pass them to <code>fs::read</code>, <code>fs::write</code>, etc.</li>
<li>The type system prevents using unvalidated paths</li>
</ul>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="web-file-upload"><a class="header" href="#web-file-upload">Web File Upload</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Public API: callers pass untrusted filename; we validate, then call an internal helper
fn handle_file_upload(filename: &amp;str, content: &amp;[u8]) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads_dir = PathBoundary::try_new_create("uploads")?;
    let dest = uploads_dir.strict_join(filename)?; // ✅ Validate external input
    save_uploaded(&amp;dest, content) // Internal API enforces &amp;StrictPath in signature
}

// Internal helper encodes guarantee in its signature
fn save_uploaded(path: &amp;StrictPath, content: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    path.create_parent_dir_all()?;
    path.write(content)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, VirtualRoot};

// Prefer signatures that encode guarantees explicitly: pass the boundary and the untrusted name
fn load_config(config_dir: &amp;PathBoundary, config_name: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    config_dir.strict_join(config_name)?.read_to_string() // ✅ Validated
}

fn setup_user_storage(user_id: u32) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a user-facing virtual root for UI flows
    let vroot = VirtualRoot::try_new_create(format!("users/{user_id}"))?;
    let docs = vroot.virtual_join("documents")?;
    docs.create_dir_all()?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<ul>
<li><strong>Real-World Examples</strong>: See complete applications using strict-path</li>
<li><strong>Understanding Type-History</strong>: Learn how the internal security works (for contributors)</li>
<li><strong>Choosing Canonicalized vs Lexical</strong>: See Ergonomics → Choosing Canonicalized vs Lexical for performance vs safety trade-offs</li>
</ul>
<p>The key rule: <strong>always validate external paths through a path boundary before using them</strong>. Whether it's user input, configuration files, or data from external sources - if you didn't create the path yourself, join it to a path boundary first!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unlocking-the-mathematical-security-of-strict-path"><a class="header" href="#unlocking-the-mathematical-security-of-strict-path">Unlocking the Mathematical Security of strict-path</a></h1>
<blockquote>
<p><strong>Welcome!</strong> You're about to learn how to make filesystem attacks <em>mathematically impossible</em> in your code. No CVE research required. No security expertise needed. Just types, the compiler, and some clever design patterns.</p>
</blockquote>
<p>This tutorial builds your understanding step-by-step, from basic path validation to compile-time authorization guarantees. Each section introduces <strong>one concept at a time</strong>, with runnable examples you can copy and paste.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h2>
<p><strong>Stage 1: <a href="tutorial/./stage1_basic_promise.html">The Basic Promise</a></strong><br />
Learn how <code>StrictPath</code> makes path escapes mathematically impossible, without any markers yet.</p>
<p><strong>Stage 2: <a href="tutorial/./stage2_mixup_problem.html">The Mix-Up Problem</a></strong><br />
Discover the confusing problem that emerges when you have multiple boundaries.</p>
<p><strong>Stage 3: <a href="tutorial/./stage3_markers.html">Markers to the Rescue</a></strong><br />
See how markers solve the mix-up problem with compile-time domain separation.</p>
<p><strong>Stage 4: <a href="tutorial/./stage4_authorization.html">Authorization with change_marker()</a></strong><br />
Learn to encode authorization requirements in the type system using <code>change_marker()</code>.</p>
<p><strong>Stage 5: <a href="tutorial/./stage5_virtual_paths.html">Virtual Paths</a></strong><br />
Understand how <code>VirtualPath</code> extends <code>StrictPath</code> with user-friendly sandboxing semantics.</p>
<p><strong>Stage 6: <a href="tutorial/./stage6_features.html">Feature Integration</a></strong><br />
Integrate with your ecosystem using feature-gated constructors (<code>dirs</code>, <code>tempfile</code>, <code>app-path</code>, <code>serde</code>).</p>
<h2 id="the-progressive-guarantee"><a class="header" href="#the-progressive-guarantee">The Progressive Guarantee</a></h2>
<p>As you progress through the stages, the compiler's guarantees grow stronger:</p>
<div class="table-wrapper"><table><thead><tr><th>Stage</th><th>What You Master</th><th>The Guarantee</th></tr></thead><tbody>
<tr><td><strong>1</strong></td><td>Basic boundaries</td><td>Path cannot escape</td></tr>
<tr><td><strong>2</strong></td><td>(Problem statement)</td><td>—</td></tr>
<tr><td><strong>3</strong></td><td>Domain separation</td><td>Path is in correct domain</td></tr>
<tr><td><strong>4</strong></td><td>Authorization encoding</td><td>Authorization proven by compiler</td></tr>
<tr><td><strong>5</strong></td><td>Virtual sandboxes</td><td>Clean UX + safe system paths</td></tr>
<tr><td><strong>6</strong></td><td>Ecosystem integration</td><td>External APIs + boundary enforcement</td></tr>
</tbody></table>
</div>
<h2 id="the-end-result"><a class="header" href="#the-end-result">The End Result</a></h2>
<blockquote>
<p><strong>By the end of this tutorial, you'll understand how the Rust compiler can mathematically prove that:</strong></p>
<ul>
<li>✅ Paths cannot escape their boundaries</li>
<li>✅ Paths are in the correct resource domain</li>
<li>✅ Authorization was granted for the specified operations</li>
<li>✅ All of this happens at <strong>compile time</strong> — no runtime overhead!</li>
</ul>
</blockquote>
<p>Ready? Let's unlock the security vault. 🔐</p>
<p><strong><a href="tutorial/./stage1_basic_promise.html">Start with Stage 1: The Basic Promise →</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-1-the-basic-promise--paths-that-cant-escape"><a class="header" href="#stage-1-the-basic-promise--paths-that-cant-escape">Stage 1: The Basic Promise — Paths That Can't Escape</a></h1>
<blockquote>
<p><em>"Give me one untrusted filename, and I'll show you a safe filesystem operation."</em></p>
</blockquote>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>You're building a web service. Users upload files. Simple, right? <strong>Wrong.</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ DISASTER WAITING TO HAPPEN
fn save_user_upload(filename: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    let path = format!("uploads/{}", filename);
    std::fs::write(path, data)?;  // filename could be "../../../etc/passwd"
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>What just happened?</strong> If <code>filename = "../../../etc/passwd"</code>, you just gave an attacker write access to your entire filesystem. Game over.</p>
<h2 id="the-solution-strictpath"><a class="header" href="#the-solution-strictpath">The Solution: StrictPath</a></h2>
<p><code>StrictPath</code> makes escapes <strong>mathematically impossible</strong>. Here's the same code, but safe:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn save_user_upload(filename: &amp;str, data: &amp;[u8]) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a boundary — the perimeter fence
    let uploads_boundary = StrictPath::with_boundary_create("uploads")?;

    // Validate the untrusted filename
    let safe_path = uploads_boundary.strict_join(filename)?;  // ✅ Attack = Error

    // Now we can safely write
    safe_path.write(data)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="what-changed"><a class="header" href="#what-changed">What Changed?</a></h2>
<ol>
<li><strong><code>with_boundary_create("uploads")</code></strong> — Sets up a security perimeter at <code>./uploads/</code></li>
<li><strong><code>strict_join(filename)</code></strong> — Validates that <code>filename</code> stays inside the boundary
<ul>
<li>Valid: <code>"report.txt"</code> → <code>./uploads/report.txt</code> ✅</li>
<li>Valid: <code>"docs/report.txt"</code> → <code>./uploads/docs/report.txt</code> ✅</li>
<li>Attack: <code>"../../../etc/passwd"</code> → <strong>Error</strong> ❌</li>
</ul>
</li>
<li><strong><code>safe_path.write(data)</code></strong> — Built-in I/O helpers that work directly on <code>StrictPath</code></li>
</ol>
<p><strong>The guarantee:</strong> If you have a <code>StrictPath</code>, it's <strong>impossible</strong> for it to reference anything outside its boundary. Not "we validated it" — <strong>impossible by construction</strong>.</p>
<h2 id="try-it-yourself"><a class="header" href="#try-it-yourself">Try It Yourself</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::StrictPath;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create the boundary
    let data_dir = StrictPath::with_boundary_create("user_data")?;

    // These all work fine
    let file1 = data_dir.strict_join("notes.txt")?;
    let file2 = data_dir.strict_join("projects/rust/main.rs")?;
    let file3 = data_dir.strict_join("deeply/nested/structure/file.json")?;

    println!("✅ Safe: {}", file1.strictpath_display());
    println!("✅ Safe: {}", file2.strictpath_display());
    println!("✅ Safe: {}", file3.strictpath_display());

    // This would fail at runtime with an error
    // let evil = data_dir.strict_join("../../../etc/passwd")?;  // ❌ PathEscapesBoundary

    Ok(())
}</code></pre></pre>
<h2 id="the-core-promise"><a class="header" href="#the-core-promise">The Core Promise</a></h2>
<blockquote>
<p><strong>If you have a <code>StrictPath</code>, it is impossible for it to escape its boundary.</strong></p>
</blockquote>
<p>This isn't validation — it's a <strong>type-level guarantee</strong>. The security is in the types, enforced by Rust's compiler.</p>
<h2 id="understanding-the-boundary"><a class="header" href="#understanding-the-boundary">Understanding the Boundary</a></h2>
<p>Think of a <code>StrictPath</code> like a <strong>smart pointer with memory</strong> of where it came from:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn demonstrate_boundary() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads = StrictPath::with_boundary_create("uploads")?;
    
    // Every path remembers its boundary
    let doc = uploads.strict_join("document.pdf")?;
    let img = uploads.strict_join("images/photo.jpg")?;
    
    // Both carry a mathematical proof: "I'm inside uploads/"
    // The compiler enforces this guarantee
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Head First Moment:</strong> Think of <code>StrictPath</code> like a smart pointer that remembers its boundary. Once created, it carries a mathematical proof: "I'm inside the fence." The compiler won't let you break that promise.</p>
<h2 id="what-about-edge-cases"><a class="header" href="#what-about-edge-cases">What About Edge Cases?</a></h2>
<p><strong>Q: What if the user provides <code>"../../etc/passwd"</code>?</strong><br />
A: <code>strict_join()</code> returns an error. The path is never created.</p>
<p><strong>Q: What about symlinks that escape?</strong><br />
A: <code>strict-path</code> resolves symlinks during validation. If a symlink points outside the boundary, you get an error.</p>
<p><strong>Q: What about Windows 8.3 short names (<code>PROGRA~1</code>)?</strong><br />
A: Caught and rejected. We validate against all known path aliasing attacks.</p>
<p><strong>Q: What about NTFS Alternate Data Streams (<code>file.txt:hidden</code>)?</strong><br />
A: Normalized and handled safely. No escapes possible.</p>
<p><strong>Q: Is this just string validation?</strong><br />
A: No! This is full canonicalization with filesystem resolution. We handle symlinks, junctions, mounts, and all platform quirks.</p>
<p>See <a href="tutorial/../security_methodology.html">Security Methodology</a> for the complete list of 19+ CVEs we've tested against.</p>
<h2 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h2>
<p>Once you have a <code>StrictPath</code>, you can perform filesystem operations directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn file_operations() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let storage = StrictPath::with_boundary_create("storage")?;
    let file = storage.strict_join("data.txt")?;

    // Write
    file.write(b"Hello, world!")?;

    // Read
    let content = file.read_to_string()?;
    println!("Content: {}", content);

    // Check metadata
    let metadata = file.metadata()?;
    println!("Size: {} bytes", metadata.len());

    // Create parent directories
    let nested = storage.strict_join("deep/nested/file.txt")?;
    nested.create_parent_dir_all()?;
    nested.write(b"Nested content")?;

    // Remove file
    file.remove_file()?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p>✅ <strong><code>StrictPath</code> = Mathematical boundary guarantee</strong><br />
✅ <strong>Attack paths fail explicitly at validation time</strong><br />
✅ <strong>Works with any untrusted input</strong> (user input, config files, LLM output, archive entries)<br />
✅ <strong>Built-in I/O helpers</strong> — no need to convert to <code>Path</code> for common operations<br />
✅ <strong>Handles edge cases</strong> — symlinks, Windows quirks, encoding tricks, etc.</p>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's Next?</a></h2>
<p>You now understand the <strong>basic promise</strong>: paths cannot escape their boundaries.</p>
<p>But what happens when your app grows and you need <strong>multiple</strong> safe directories? That's where things get confusing...</p>
<p><strong><a href="tutorial/./stage2_mixup_problem.html">Continue to Stage 2: The Mix-Up Problem →</a></strong></p>
<hr />
<p><strong>Quick Reference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create boundary
let boundary = StrictPath::with_boundary_create("safe_dir")?;

// Validate untrusted input
let safe_path = boundary.strict_join(untrusted_filename)?;

// Perform I/O
safe_path.write(data)?;
let content = safe_path.read_to_string()?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-2-the-mix-up-problem--when-you-have-multiple-boundaries"><a class="header" href="#stage-2-the-mix-up-problem--when-you-have-multiple-boundaries">Stage 2: The Mix-Up Problem — When You Have Multiple Boundaries</a></h1>
<blockquote>
<p><em>"Wait, which uploads folder is this again?"</em></p>
</blockquote>
<p>In Stage 1, you learned that <code>StrictPath</code> guarantees paths can't escape their boundaries. Perfect! But real applications need <strong>multiple</strong> safe directories. That's where a new problem emerges...</p>
<h2 id="real-world-complexity"><a class="header" href="#real-world-complexity">Real-World Complexity</a></h2>
<p>As your app grows, you need multiple safe directories:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn file_server() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // User uploads
    let uploads_dir = StrictPath::with_boundary_create("user_uploads")?;
    
    // Public web assets (CSS, JS, images)
    let assets_dir = StrictPath::with_boundary_create("public_assets")?;
    
    // System configuration files
    let config_dir = StrictPath::with_boundary_create("system_config")?;

    // Now we have paths from different domains...
    let user_file = uploads_dir.strict_join("document.pdf")?;
    let css_file = assets_dir.strict_join("style.css")?;
    let config_file = config_dir.strict_join("database.toml")?;

    // But they're all the same type!
    // let _: StrictPath = user_file;
    // let _: StrictPath = css_file;
    // let _: StrictPath = config_file;

    // 🚨 DANGER: Easy to mix them up!
    serve_public_asset(&amp;user_file)?;      // Oops! Serving user upload as public asset
    save_user_upload(&amp;config_file)?;      // Double oops! User overwrites config

    Ok(())
}

fn serve_public_asset(path: &amp;StrictPath) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    path.read()  // Should only serve public assets!
}

fn save_user_upload(path: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    path.write(b"user data")  // Should only write to user uploads!
}
<span class="boring">}</span></code></pre></pre>
<h2 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h2>
<p>All <code>StrictPath</code> values look the same to the compiler:</p>
<ul>
<li>User uploads → <code>StrictPath</code></li>
<li>Public assets → <code>StrictPath</code></li>
<li>System config → <code>StrictPath</code></li>
</ul>
<p><strong>The compiler can't help you</strong> catch domain mix-ups. Code review is your only defense. And humans make mistakes.</p>
<h2 id="what-could-go-wrong"><a class="header" href="#what-could-go-wrong">What Could Go Wrong?</a></h2>
<p>Let's see the concrete dangers:</p>
<h3 id="1-security-leak-private-files-exposed"><a class="header" href="#1-security-leak-private-files-exposed">1. Security Leak: Private Files Exposed</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn security_leak_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let private_uploads = StrictPath::with_boundary_create("private_uploads")?;
    let public_site = StrictPath::with_boundary_create("public_site")?;

    // User uploads a private document
    let tax_return = private_uploads.strict_join("tax_return_2024.pdf")?;
    tax_return.write(b"Sensitive financial data")?;

    // Oops! Developer accidentally serves it from the public site handler
    serve_to_internet(&amp;tax_return)?;  // 🚨 Private file now publicly accessible!

    Ok(())
}

fn serve_to_internet(path: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    // This function should only receive public site files
    // But the compiler can't enforce that!
    println!("Serving {} to the internet...", path.strictpath_display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-data-corruption-wrong-directory-modified"><a class="header" href="#2-data-corruption-wrong-directory-modified">2. Data Corruption: Wrong Directory Modified</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn data_corruption_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let user_data = StrictPath::with_boundary_create("user_data")?;
    let system_logs = StrictPath::with_boundary_create("system_logs")?;

    let user_note = user_data.strict_join("notes.txt")?;
    let system_log = system_logs.strict_join("audit.log")?;

    // Oops! Passed the wrong path to the wrong function
    append_user_content(&amp;system_log, "User's random thoughts")?;  // 🚨 Corrupting system log!
    append_audit_entry(&amp;user_note, "ADMIN LOGIN")?;              // 🚨 Audit data in user file!

    Ok(())
}

fn append_user_content(path: &amp;StrictPath, content: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    // Should only receive user_data paths
    let mut existing = path.read_to_string().unwrap_or_default();
    existing.push_str(content);
    path.write(existing.as_bytes())
}

fn append_audit_entry(path: &amp;StrictPath, entry: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    // Should only receive system_logs paths
    let mut log = path.read_to_string().unwrap_or_default();
    log.push_str(&amp;format!("[AUDIT] {}\n", entry));
    path.write(log.as_bytes())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-authorization-bypass-wrong-permissions-applied"><a class="header" href="#3-authorization-bypass-wrong-permissions-applied">3. Authorization Bypass: Wrong Permissions Applied</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn authorization_bypass_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let admin_files = StrictPath::with_boundary_create("admin_files")?;
    let guest_files = StrictPath::with_boundary_create("guest_files")?;

    let sensitive_config = admin_files.strict_join("secrets.toml")?;
    let public_readme = guest_files.strict_join("README.md")?;

    // Oops! Applied wrong permission check to wrong path
    allow_guest_access(&amp;sensitive_config)?;  // 🚨 Guest can access admin secrets!
    require_admin_access(&amp;public_readme)?;   // 🚨 Admin required for public file!

    Ok(())
}

fn allow_guest_access(path: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    println!("Guest can access: {}", path.strictpath_display());
    Ok(())
}

fn require_admin_access(path: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    println!("Admin required for: {}", path.strictpath_display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="why-this-happens"><a class="header" href="#why-this-happens">Why This Happens</a></h2>
<p>The problem is <strong>type erasure</strong>. Once you create paths from different boundaries, they all collapse to the same type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn demonstrate_type_erasure() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads = StrictPath::with_boundary_create("uploads")?;
    let config = StrictPath::with_boundary_create("config")?;
    let cache = StrictPath::with_boundary_create("cache")?;

    let file1 = uploads.strict_join("a.txt")?;  // Type: StrictPath
    let file2 = config.strict_join("b.txt")?;   // Type: StrictPath
    let file3 = cache.strict_join("c.txt")?;    // Type: StrictPath

    // The compiler sees them all as identical
    // You can accidentally swap them and nothing will complain
    let paths = vec![file1, file2, file3];
    
    // Which path is which? The compiler doesn't know!
    for path in paths {
        // Is this uploads, config, or cache? 🤷
        println!("{}", path.strictpath_display());
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="the-defense-human-code-review-fragile"><a class="header" href="#the-defense-human-code-review-fragile">The Defense: Human Code Review (Fragile!)</a></h2>
<p>Without compiler help, you rely on:</p>
<ul>
<li>✍️ <strong>Careful naming</strong> — Hope developers use descriptive variable names</li>
<li>👀 <strong>Code review</strong> — Hope reviewers catch the mix-ups</li>
<li>📝 <strong>Documentation</strong> — Hope everyone reads and remembers it</li>
<li>🧪 <strong>Testing</strong> — Hope tests cover the edge cases</li>
</ul>
<p><strong>Problem:</strong> Humans are fallible. Mistakes slip through. Security bugs ship to production.</p>
<h2 id="head-first-moment"><a class="header" href="#head-first-moment">Head First Moment</a></h2>
<p>Imagine a hospital where <strong>every door key looks identical</strong>. The keys work — they're genuine hospital keys — but there's no way to know which key opens which door.</p>
<ul>
<li>🔑 Operating room key? Looks like every other key.</li>
<li>🔑 Medicine cabinet key? Looks like every other key.</li>
<li>🔑 Patient records room key? Looks like every other key.</li>
</ul>
<p>Sure, you <em>intend</em> to use the right key for the right door. But mistakes happen:</p>
<ul>
<li>Tired nurse grabs the wrong key ❌</li>
<li>New employee doesn't know the system ❌</li>
<li>Emergency situation, grab the nearest key ❌</li>
</ul>
<p><strong>We need keys that physically can't open the wrong doors.</strong></p>
<h2 id="the-real-world-impact"><a class="header" href="#the-real-world-impact">The Real-World Impact</a></h2>
<p>These mix-ups cause real security incidents:</p>
<ul>
<li><strong>CVE-2021-XXXXX:</strong> Web framework served user uploads from static asset handler → RCE</li>
<li><strong>CVE-2020-XXXXX:</strong> Config parser wrote user data to system directory → Privilege escalation</li>
<li><strong>CVE-2019-XXXXX:</strong> Admin dashboard mixed up user ID directories → Data leak</li>
</ul>
<p>The pattern is always the same: <strong>Path from Domain A used in Domain B</strong>.</p>
<h2 id="what-we-need"><a class="header" href="#what-we-need">What We Need</a></h2>
<p>We need the <strong>compiler</strong> to distinguish between paths from different domains:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This should compile:
serve_public_asset(&amp;public_css_file)?;      // ✅ Correct domain

// This should NOT compile:
serve_public_asset(&amp;private_user_file)?;    // ❌ Wrong domain — should be compile error!
<span class="boring">}</span></code></pre></pre>
<p>But how? <code>StrictPath</code> already gives us boundary safety. We just need a way to teach the compiler <strong>which boundary</strong> a path came from...</p>
<h2 id="the-solution-preview"><a class="header" href="#the-solution-preview">The Solution Preview</a></h2>
<p>What if we could <strong>label</strong> each boundary? Give it a <strong>name</strong> the compiler understands?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pseudocode (not real syntax yet)
let uploads: StrictPath&lt;"UserUploads"&gt; = ...;
let assets: StrictPath&lt;"PublicAssets"&gt; = ...;
let config: StrictPath&lt;"SystemConfig"&gt; = ...;

// Now the compiler can see they're different!
fn serve_public_asset(path: &amp;StrictPath&lt;"PublicAssets"&gt;) { ... }

serve_public_asset(&amp;assets)?;   // ✅ Compiles
serve_public_asset(&amp;uploads)?;  // ❌ Compiler error: expected PublicAssets, found UserUploads
<span class="boring">}</span></code></pre></pre>
<p>This is exactly what <strong>markers</strong> do. And that's what you'll learn in the next stage.</p>
<h2 id="key-takeaways-1"><a class="header" href="#key-takeaways-1">Key Takeaways</a></h2>
<p>🚨 <strong>Multiple boundaries → same type → mix-ups possible</strong><br />
🚨 <strong>Mix-ups cause security bugs</strong> (data leaks, corruption, auth bypass)<br />
🚨 <strong>Code review is fragile</strong> — humans make mistakes<br />
🚨 <strong>We need compiler enforcement</strong> — catch errors at compile time</p>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What's Next?</a></h2>
<p>You've seen the problem: multiple boundaries create confusion and risk.</p>
<p>Now you're ready for the solution: <strong>markers</strong> that make the compiler your security guard.</p>
<p><strong><a href="tutorial/./stage3_markers.html">Continue to Stage 3: Markers to the Rescue →</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-3-markers-to-the-rescue--compile-time-domain-separation"><a class="header" href="#stage-3-markers-to-the-rescue--compile-time-domain-separation">Stage 3: Markers to the Rescue — Compile-Time Domain Separation</a></h1>
<blockquote>
<p><em>"Give each boundary a name the compiler understands."</em></p>
</blockquote>
<p>In Stage 2, you saw how multiple boundaries create confusion — all <code>StrictPath</code> values look identical to the compiler. Now you'll learn how <strong>markers</strong> solve this problem by encoding domain information in the type system.</p>
<h2 id="introducing-markers"><a class="header" href="#introducing-markers">Introducing Markers</a></h2>
<p>A <strong>marker</strong> is a zero-cost compile-time label. It's like writing "THIS IS USER UPLOADS" directly on the type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

// Define markers (zero runtime cost!)
struct UserUploads;
struct PublicAssets;
struct SystemConfig;
<span class="boring">}</span></code></pre></pre>
<p>That's it! Three simple structs. But now watch what happens when we use them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct UserUploads;
struct PublicAssets;
struct SystemConfig;

fn file_server_with_markers() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Now each boundary has a distinct type
    let uploads_dir: StrictPath&lt;UserUploads&gt; = 
        StrictPath::with_boundary_create("user_uploads")?;
    
    let assets_dir: StrictPath&lt;PublicAssets&gt; = 
        StrictPath::with_boundary_create("public_assets")?;
    
    let config_dir: StrictPath&lt;SystemConfig&gt; = 
        StrictPath::with_boundary_create("system_config")?;

    // Paths inherit their marker
    let user_file = uploads_dir.strict_join("document.pdf")?;  // StrictPath&lt;UserUploads&gt;
    let css_file = assets_dir.strict_join("style.css")?;      // StrictPath&lt;PublicAssets&gt;
    let config_file = config_dir.strict_join("database.toml")?; // StrictPath&lt;SystemConfig&gt;

    // ✅ Correct usage
    serve_public_asset(&amp;css_file)?;
    save_user_upload(&amp;user_file)?;

    // ❌ Compiler errors — wrong domain!
    // serve_public_asset(&amp;user_file)?;     // Won't compile!
    // save_user_upload(&amp;config_file)?;     // Won't compile!

    Ok(())
}

// Functions now express their requirements in the type system
fn serve_public_asset(path: &amp;StrictPath&lt;PublicAssets&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    path.read()  // Guaranteed: path is in public_assets/
}

fn save_user_upload(path: &amp;StrictPath&lt;UserUploads&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.write(b"user data")  // Guaranteed: path is in user_uploads/
}
<span class="boring">}</span></code></pre></pre>
<h2 id="what-just-happened-1"><a class="header" href="#what-just-happened-1">What Just Happened?</a></h2>
<ol>
<li><strong>Zero-cost labels:</strong> <code>struct UserUploads;</code> — empty struct, <strong>no fields</strong>, no runtime overhead</li>
<li><strong>Type-level tracking:</strong> <code>StrictPath&lt;UserUploads&gt;</code> vs <code>StrictPath&lt;PublicAssets&gt;</code> are <strong>different types</strong></li>
<li><strong>Compiler enforcement:</strong> Can't pass the wrong marker to a function — <strong>compile error</strong></li>
<li><strong>Self-documenting:</strong> Function signatures show exactly what paths they accept</li>
</ol>
<p><strong>The New Guarantee:</strong> Not only is the path safe (Stage 1), but the compiler <strong>proves it's in the correct domain</strong> (Stage 3).</p>
<h2 id="the-compiler-as-security-guard"><a class="header" href="#the-compiler-as-security-guard">The Compiler as Security Guard</a></h2>
<p>Let's see the compiler catch mistakes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct SensitiveData;
struct PublicWebsite;

fn demonstrate_compiler_enforcement() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let sensitive_dir: StrictPath&lt;SensitiveData&gt; = 
        StrictPath::with_boundary_create("sensitive")?;
    
    let public_dir: StrictPath&lt;PublicWebsite&gt; = 
        StrictPath::with_boundary_create("public")?;

    let secret_file = sensitive_dir.strict_join("passwords.txt")?;
    let css_file = public_dir.strict_join("styles.css")?;

    // ✅ This compiles — correct domain
    serve_public_file(&amp;css_file)?;

    // ❌ This fails at compile time — wrong domain!
    // serve_public_file(&amp;secret_file)?;
    //                   ^^^^^^^^^^^^ 
    // ERROR: expected `&amp;StrictPath&lt;PublicWebsite&gt;`, 
    //        found `&amp;StrictPath&lt;SensitiveData&gt;`

    Ok(())
}

fn serve_public_file(path: &amp;StrictPath&lt;PublicWebsite&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Serving public file: {}", path.strictpath_display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Before markers:</strong> Mistake ships to production → security incident.<br />
<strong>After markers:</strong> Mistake caught at compile time → fix before commit.</p>
<h2 id="try-it-yourself-1"><a class="header" href="#try-it-yourself-1">Try It Yourself</a></h2>
<p>Here's a realistic example you can run:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct Documents;
struct Photos;
struct Music;

fn organize_media() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create distinct boundaries
    let docs_dir: StrictPath&lt;Documents&gt; = StrictPath::with_boundary_create("docs")?;
    let photos_dir: StrictPath&lt;Photos&gt; = StrictPath::with_boundary_create("photos")?;
    let music_dir: StrictPath&lt;Music&gt; = StrictPath::with_boundary_create("music")?;

    // Create files in each domain
    let report = docs_dir.strict_join("quarterly_report.pdf")?;
    let vacation = photos_dir.strict_join("beach_2024.jpg")?;
    let song = music_dir.strict_join("favorite_song.mp3")?;

    // Correct domain usage
    archive_document(&amp;report)?;           // ✅ Works
    backup_photo(&amp;vacation)?;             // ✅ Works
    transcode_audio(&amp;song)?;              // ✅ Works

    // Wrong domain usage — won't compile!
    // archive_document(&amp;vacation)?;      // ❌ Compile error
    // backup_photo(&amp;song)?;              // ❌ Compile error
    // transcode_audio(&amp;report)?;         // ❌ Compile error

    Ok(())
}

fn archive_document(doc: &amp;StrictPath&lt;Documents&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Archiving document: {}", doc.strictpath_display());
    Ok(())
}

fn backup_photo(photo: &amp;StrictPath&lt;Photos&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Backing up photo: {}", photo.strictpath_display());
    Ok(())
}

fn transcode_audio(audio: &amp;StrictPath&lt;Music&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Transcoding audio: {}", audio.strictpath_display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="markers-are-zero-cost"><a class="header" href="#markers-are-zero-cost">Markers Are Zero-Cost</a></h2>
<p>Let's verify that markers have <strong>zero runtime overhead</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;
use std::mem;

struct MyMarker;

fn demonstrate_zero_cost() {
    // Size of StrictPath with and without marker
    let size_without = mem::size_of::&lt;StrictPath&lt;()&gt;&gt;();
    let size_with = mem::size_of::&lt;StrictPath&lt;MyMarker&gt;&gt;();

    println!("StrictPath&lt;()&gt;: {} bytes", size_without);
    println!("StrictPath&lt;MyMarker&gt;: {} bytes", size_with);
    
    // They're identical! The marker is compile-time only.
    assert_eq!(size_without, size_with);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>The marker is erased at compile time.</strong> It exists only in the type system. No runtime memory, no runtime checks, no performance cost.</p>
<h2 id="naming-markers-best-practices"><a class="header" href="#naming-markers-best-practices">Naming Markers: Best Practices</a></h2>
<p>Markers should describe <strong>what resource is stored under the boundary</strong>, not who accesses it:</p>
<h3 id="-good-marker-names-what-is-stored"><a class="header" href="#-good-marker-names-what-is-stored">✅ Good Marker Names (What is stored)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserUploads;        // Stores: user-uploaded files
struct ProductImages;      // Stores: product catalog images
struct SystemLogs;         // Stores: application log files
struct ConfigFiles;        // Stores: configuration files
struct TempWorkspace;      // Stores: temporary processing files
<span class="boring">}</span></code></pre></pre>
<h3 id="-bad-marker-names-who-accesses-it"><a class="header" href="#-bad-marker-names-who-accesses-it">❌ Bad Marker Names (Who accesses it)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AdminMarker;        // ❌ Describes user role, not storage
struct GuestAccess;        // ❌ Describes permission, not content
struct AuthorizedPath;     // ❌ Describes state, not resource
<span class="boring">}</span></code></pre></pre>
<p><strong>Why?</strong> Markers describe <strong>boundaries</strong> (physical storage locations), not <strong>permissions</strong> (authorization levels). We'll add permissions in Stage 4.</p>
<h2 id="real-world-example-web-server"><a class="header" href="#real-world-example-web-server">Real-World Example: Web Server</a></h2>
<p>Here's how you'd structure a real web server with markers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

// Define domains
struct StaticAssets;     // CSS, JS, images served to browsers
struct UserUploads;      // Files uploaded by users
struct TemplateFiles;    // HTML templates for rendering
struct AppLogs;          // Application logs

struct WebServer {
    static_dir: StrictPath&lt;StaticAssets&gt;,
    uploads_dir: StrictPath&lt;UserUploads&gt;,
    templates_dir: StrictPath&lt;TemplateFiles&gt;,
    logs_dir: StrictPath&lt;AppLogs&gt;,
}

impl WebServer {
    fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        Ok(Self {
            static_dir: StrictPath::with_boundary_create("public/static")?,
            uploads_dir: StrictPath::with_boundary_create("data/uploads")?,
            templates_dir: StrictPath::with_boundary_create("templates")?,
            logs_dir: StrictPath::with_boundary_create("logs")?,
        })
    }

    fn serve_static(&amp;self, filename: &amp;str) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
        let asset_path = self.static_dir.strict_join(filename)?;
        serve_to_client(&amp;asset_path)  // Type-safe: only StaticAssets
    }

    fn save_upload(&amp;self, filename: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
        let upload_path = self.uploads_dir.strict_join(filename)?;
        store_user_file(&amp;upload_path, data)  // Type-safe: only UserUploads
    }

    fn render_template(&amp;self, template: &amp;str) -&gt; std::io::Result&lt;String&gt; {
        let tmpl_path = self.templates_dir.strict_join(template)?;
        load_template(&amp;tmpl_path)  // Type-safe: only TemplateFiles
    }

    fn write_log(&amp;self, entry: &amp;str) -&gt; std::io::Result&lt;()&gt; {
        let log_path = self.logs_dir.strict_join("app.log")?;
        append_log_entry(&amp;log_path, entry)  // Type-safe: only AppLogs
    }
}

// Type-safe helper functions
fn serve_to_client(asset: &amp;StrictPath&lt;StaticAssets&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    asset.read()
}

fn store_user_file(upload: &amp;StrictPath&lt;UserUploads&gt;, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    upload.write(data)
}

fn load_template(tmpl: &amp;StrictPath&lt;TemplateFiles&gt;) -&gt; std::io::Result&lt;String&gt; {
    tmpl.read_to_string()
}

fn append_log_entry(log: &amp;StrictPath&lt;AppLogs&gt;, entry: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    let mut content = log.read_to_string().unwrap_or_default();
    content.push_str(entry);
    content.push('\n');
    log.write(content.as_bytes())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="head-first-moment-1"><a class="header" href="#head-first-moment-1">Head First Moment</a></h2>
<p>Markers are like <strong>colored wristbands at a conference</strong>:</p>
<ul>
<li>🔵 Blue wristband → Speaker (can access speaker lounge)</li>
<li>🟢 Green wristband → Attendee (can access general sessions)</li>
<li>🔴 Red wristband → Staff (can access backstage)</li>
</ul>
<p><strong>The compiler checks your wristband at every function door:</strong></p>
<ul>
<li>Function requires 🔵 blue? You need <code>StrictPath&lt;Speaker&gt;</code>.</li>
<li>Try to enter with 🟢 green? Compile error: "Sorry, speakers only."</li>
<li>Wrong color? <strong>Access denied at compile time.</strong></li>
</ul>
<p>You can't fake a wristband, and you can't sneak into the wrong area. The type system physically prevents it.</p>
<h2 id="comparison-before-and-after"><a class="header" href="#comparison-before-and-after">Comparison: Before and After</a></h2>
<h3 id="before-markers-stage-2"><a class="header" href="#before-markers-stage-2">Before Markers (Stage 2)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ All paths look the same
let user_file: StrictPath = ...;
let config_file: StrictPath = ...;
let log_file: StrictPath = ...;

// ❌ Functions can't distinguish
fn process(path: &amp;StrictPath) { ... }

// ❌ Easy to mix up — compiler can't help
process(&amp;config_file);  // Oops, wrong file!
<span class="boring">}</span></code></pre></pre>
<h3 id="after-markers-stage-3"><a class="header" href="#after-markers-stage-3">After Markers (Stage 3)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Each path has its domain encoded
let user_file: StrictPath&lt;UserUploads&gt; = ...;
let config_file: StrictPath&lt;ConfigFiles&gt; = ...;
let log_file: StrictPath&lt;AppLogs&gt; = ...;

// ✅ Functions express requirements
fn process_user_file(path: &amp;StrictPath&lt;UserUploads&gt;) { ... }

// ✅ Compiler catches mistakes
process_user_file(&amp;user_file);     // ✅ Correct
process_user_file(&amp;config_file);   // ❌ Compile error!
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways-2"><a class="header" href="#key-takeaways-2">Key Takeaways</a></h2>
<p>✅ <strong>Markers = Zero-cost compile-time labels</strong><br />
✅ <strong><code>StrictPath&lt;Marker&gt;</code> = Path + domain information</strong><br />
✅ <strong>Compiler enforces domain separation</strong> — wrong marker = compile error<br />
✅ <strong>Self-documenting code</strong> — function signatures show requirements<br />
✅ <strong>No runtime overhead</strong> — markers are erased after compilation</p>
<h2 id="the-updated-guarantee"><a class="header" href="#the-updated-guarantee">The Updated Guarantee</a></h2>
<blockquote>
<p><strong>If you have a <code>StrictPath&lt;Marker&gt;</code>, the compiler guarantees:</strong></p>
<ol>
<li>✅ The path cannot escape its boundary (Stage 1)</li>
<li>✅ The path is in the correct domain (Stage 3)</li>
</ol>
</blockquote>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What's Next?</a></h2>
<p>You now know how to prevent domain mix-ups with markers. But what about <strong>authorization</strong>? How do you encode "this user is authorized to access this path" in the type system?</p>
<p>That's where things get really powerful...</p>
<p><strong><a href="tutorial/./stage4_authorization.html">Continue to Stage 4: Authorization with change_marker() →</a></strong></p>
<hr />
<p><strong>Quick Reference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define markers
struct MyDomain;

// Create typed boundary
let boundary: StrictPath&lt;MyDomain&gt; = 
    StrictPath::with_boundary_create("path")?;

// Paths inherit marker
let file = boundary.strict_join("file.txt")?;  // StrictPath&lt;MyDomain&gt;

// Functions enforce domain
fn process(path: &amp;StrictPath&lt;MyDomain&gt;) { ... }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-4-authorization-with-change_marker--compile-time-authorization-proofs"><a class="header" href="#stage-4-authorization-with-change_marker--compile-time-authorization-proofs">Stage 4: Authorization with <code>change_marker()</code> — Compile-Time Authorization Proofs</a></h1>
<blockquote>
<p><em>"The compiler can mathematically prove that authorization happened first."</em></p>
</blockquote>
<p>In Stage 3, you learned how markers prevent domain mix-ups. Now you'll learn how to <strong>encode authorization</strong> in markers using <code>change_marker()</code>, so the compiler can mathematically prove that authorization checks weren't forgotten.</p>
<h2 id="the-authorization-problem"><a class="header" href="#the-authorization-problem">The Authorization Problem</a></h2>
<p>Markers prevent domain confusion. But what about <strong>permissions</strong>? How do we encode "this user is authorized to write to this directory"?</p>
<h3 id="traditional-approach-runtime-checks-everywhere"><a class="header" href="#traditional-approach-runtime-checks-everywhere">Traditional Approach: Runtime Checks Everywhere</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct UserFiles;

// ❌ Problem: Authorization check inside every operation
fn write_user_file(path: &amp;StrictPath&lt;UserFiles&gt;, user_id: &amp;str, data: &amp;[u8]) 
    -&gt; std::io::Result&lt;()&gt; 
{
    if !is_authorized(user_id) {  // Runtime check (can forget!)
        return Err(std::io::Error::new(
            std::io::ErrorKind::PermissionDenied, 
            "Unauthorized"
        ));
    }
    path.write(data)
}

fn delete_user_file(path: &amp;StrictPath&lt;UserFiles&gt;, user_id: &amp;str) 
    -&gt; std::io::Result&lt;()&gt; 
{
    if !is_authorized(user_id) {  // Repeated check (can forget!)
        return Err(std::io::Error::new(
            std::io::ErrorKind::PermissionDenied, 
            "Unauthorized"
        ));
    }
    path.remove_file()
}

fn read_user_file(path: &amp;StrictPath&lt;UserFiles&gt;, user_id: &amp;str) 
    -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; 
{
    // Oops! Forgot the authorization check here! 🚨
    path.read()
}

fn is_authorized(user_id: &amp;str) -&gt; bool {
    user_id == "alice"
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Problems:</strong></p>
<ul>
<li>❌ Authorization checks scattered everywhere</li>
<li>❌ Easy to forget a check (see <code>read_user_file</code>)</li>
<li>❌ No compile-time guarantee that authorization happened</li>
<li>❌ Code review has to catch missing checks (humans are fallible)</li>
</ul>
<h3 id="better-approach-encode-authorization-in-the-type"><a class="header" href="#better-approach-encode-authorization-in-the-type">Better Approach: Encode Authorization in the Type</a></h3>
<p>Instead of <strong>checking</strong> authorization repeatedly, we <strong>encode</strong> it in the type once:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

// Resource marker: describes WHAT directory
struct UserFiles;

// Permission markers: describe LEVEL of access
struct ReadOnly;
struct ReadWrite;

// Authorization gate: validates token → returns authorized marker
fn authenticate_user_access(
    token: &amp;str,
    path: StrictPath&lt;(UserFiles, ReadOnly)&gt;
) -&gt; Option&lt;StrictPath&lt;(UserFiles, ReadWrite)&gt;&gt; {
    // ✅ Authorization: Token validated (checked once here!)
    if validate_token(token) {
        // Transform marker to encode proven authorization
        Some(path.change_marker::&lt;(UserFiles, ReadWrite)&gt;())
    } else {
        None
    }
}

fn validate_token(token: &amp;str) -&gt; bool {
    token == "valid-token-12345"  // Real apps: JWT validation, database lookup, etc.
}

// Functions accept paths that already prove authorization
fn write_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;, data: &amp;[u8]) 
    -&gt; std::io::Result&lt;()&gt; 
{
    // No authorization check needed! Type proves it already happened.
    path.write(data)
}

fn delete_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;) 
    -&gt; std::io::Result&lt;()&gt; 
{
    // No authorization check needed! Type proves it already happened.
    path.remove_file()
}

fn read_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadOnly)&gt;) 
    -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; 
{
    // ReadOnly access is sufficient for reading
    path.read()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="understanding-change_marker"><a class="header" href="#understanding-change_marker">Understanding <code>change_marker()</code></a></h2>
<h3 id="what-change_marker-is-not"><a class="header" href="#what-change_marker-is-not">What <code>change_marker()</code> Is NOT</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ WRONG way to think about it:
// "change_marker() grants permissions"
// "change_marker() does authorization"
<span class="boring">}</span></code></pre></pre>
<h3 id="what-change_marker-actually-does"><a class="header" href="#what-change_marker-actually-does">What <code>change_marker()</code> Actually Does</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ RIGHT way to think about it:
// "change_marker() ENCODES proven authorization in the type"
// "change_marker() transforms the marker AFTER authorization passed"
<span class="boring">}</span></code></pre></pre>
<p><strong>The pattern:</strong></p>
<ol>
<li>✅ <strong>Check authorization</strong> (token validation, capability check, etc.)</li>
<li>✅ <strong>If authorized:</strong> call <code>change_marker()</code> to encode that fact in the type</li>
<li>✅ <strong>Pass the new type</strong> to functions that require authorization</li>
<li>✅ <strong>The compiler proves</strong> authorization happened (can't get the marker any other way!)</li>
</ol>
<h2 id="using-it-complete-example"><a class="header" href="#using-it-complete-example">Using It: Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::StrictPath;

struct UserFiles;
struct ReadOnly;
struct ReadWrite;

fn handle_request(token: &amp;str, filename: &amp;str, data: Option&lt;&amp;[u8]&gt;) 
    -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; 
{
    // Start with read-only access (no authorization yet)
    let user_files_dir: StrictPath&lt;(UserFiles, ReadOnly)&gt; = 
        StrictPath::with_boundary_create("user_files")?;
    
    let file_path = user_files_dir.strict_join(filename)?;

    // Anyone can read with ReadOnly marker
    let _content = read_user_file(&amp;file_path)?;
    println!("✅ Read succeeded (no authorization needed)");

    // Try to upgrade to ReadWrite by authenticating
    if let Some(writable_path) = authenticate_user_access(token, file_path) {
        // ✅ Token validated! Now we have ReadWrite access
        println!("✅ Authorization succeeded");
        
        if let Some(data) = data {
            write_user_file(&amp;writable_path, data)?;
            println!("✅ Write succeeded (authorization proven by type)");
        }
        
        delete_user_file(&amp;writable_path)?;
        println!("✅ Delete succeeded (authorization proven by type)");
    } else {
        println!("❌ Authorization failed — cannot write or delete");
    }

    Ok(())
}

fn authenticate_user_access(
    token: &amp;str,
    path: StrictPath&lt;(UserFiles, ReadOnly)&gt;
) -&gt; Option&lt;StrictPath&lt;(UserFiles, ReadWrite)&gt;&gt; {
    if validate_token(token) {
        Some(path.change_marker())
    } else {
        None
    }
}

fn validate_token(token: &amp;str) -&gt; bool {
    token == "valid-token-12345"
}

fn read_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadOnly)&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    path.read()
}

fn write_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    path.write(data)
}

fn delete_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.remove_file()
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Valid token — authorization succeeds
    handle_request("valid-token-12345", "notes.txt", Some(b"New content"))?;
    
    // Invalid token — authorization fails
    handle_request("invalid-token", "notes.txt", Some(b"Hack attempt"))?;
    
    Ok(())
}</code></pre></pre>
<h2 id="tuple-markers-composing-resources-and-permissions"><a class="header" href="#tuple-markers-composing-resources-and-permissions">Tuple Markers: Composing Resources and Permissions</a></h2>
<p>Notice we're using <strong>tuple markers</strong>: <code>(UserFiles, ReadOnly)</code> and <code>(UserFiles, ReadWrite)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserFiles;      // First element: WHAT resource
struct ReadOnly;       // Second element: WHAT permission level
struct ReadWrite;

// Composed together:
// StrictPath&lt;(UserFiles, ReadOnly)&gt;   = User files with read-only access
// StrictPath&lt;(UserFiles, ReadWrite)&gt;  = User files with read-write access
<span class="boring">}</span></code></pre></pre>
<p><strong>Why tuples?</strong></p>
<ul>
<li>✅ <strong>Flexible composition:</strong> Mix and match resources with permissions</li>
<li>✅ <strong>Easy to transform:</strong> <code>change_marker()</code> can swap out permission levels</li>
<li>✅ <strong>Standard Rust idiom:</strong> No need to learn special syntax</li>
</ul>
<h2 id="try-it-yourself-capability-based-authorization"><a class="header" href="#try-it-yourself-capability-based-authorization">Try It Yourself: Capability-Based Authorization</a></h2>
<p>Here's a more sophisticated example with multiple capability levels:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::StrictPath;

struct ProjectFiles;
struct CanRead;
struct CanWrite;
struct CanDelete;

// Check user role and return appropriate marker
fn grant_project_access(
    user_role: &amp;str,
    path: StrictPath&lt;ProjectFiles&gt;
) -&gt; Option&lt;StrictPath&lt;(ProjectFiles, CanRead, CanWrite, CanDelete)&gt;&gt; {
    // ✅ Authorization: Role checked
    if user_role == "admin" {
        // Admin gets full access (read + write + delete)
        Some(path.change_marker::&lt;(ProjectFiles, CanRead, CanWrite, CanDelete)&gt;())
    } else {
        None
    }
}

fn grant_editor_access(
    user_role: &amp;str,
    path: StrictPath&lt;ProjectFiles&gt;
) -&gt; Option&lt;StrictPath&lt;(ProjectFiles, CanRead, CanWrite)&gt;&gt; {
    // ✅ Authorization: Role checked
    if user_role == "editor" || user_role == "admin" {
        // Editors can read and write (but not delete)
        Some(path.change_marker::&lt;(ProjectFiles, CanRead, CanWrite)&gt;())
    } else {
        None
    }
}

fn grant_readonly_access(
    user_role: &amp;str,
    path: StrictPath&lt;ProjectFiles&gt;
) -&gt; Option&lt;StrictPath&lt;(ProjectFiles, CanRead)&gt;&gt; {
    // ✅ Authorization: Role checked
    if user_role == "viewer" || user_role == "editor" || user_role == "admin" {
        Some(path.change_marker::&lt;(ProjectFiles, CanRead)&gt;())
    } else {
        None
    }
}

// Functions require specific capabilities in their signature
fn read_project(path: &amp;StrictPath&lt;(ProjectFiles, CanRead)&gt;) -&gt; std::io::Result&lt;String&gt; {
    path.read_to_string()
}

fn update_project(path: &amp;StrictPath&lt;(ProjectFiles, CanRead, CanWrite)&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.write(b"Updated project data")
}

fn delete_project(path: &amp;StrictPath&lt;(ProjectFiles, CanRead, CanWrite, CanDelete)&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.remove_file()
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let projects_dir: StrictPath&lt;ProjectFiles&gt; = 
        StrictPath::with_boundary_create("projects")?;
    
    let project = projects_dir.strict_join("proposal.md")?;

    // Viewer can only read
    if let Some(readonly_path) = grant_readonly_access("viewer", project.clone()) {
        read_project(&amp;readonly_path)?;
        println!("✅ Viewer: read succeeded");
        // update_project(&amp;readonly_path)?;  // ❌ Won't compile: missing CanWrite
    }

    // Editor can read and write
    if let Some(editor_path) = grant_editor_access("editor", project.clone()) {
        read_project(&amp;editor_path)?;      // ✅ Has CanRead
        update_project(&amp;editor_path)?;    // ✅ Has CanRead + CanWrite
        println!("✅ Editor: read and write succeeded");
        // delete_project(&amp;editor_path)?; // ❌ Won't compile: missing CanDelete
    }

    // Admin can do everything
    if let Some(admin_path) = grant_project_access("admin", project) {
        read_project(&amp;admin_path)?;      // ✅ Has CanRead
        update_project(&amp;admin_path)?;    // ✅ Has CanRead + CanWrite
        delete_project(&amp;admin_path)?;    // ✅ Has CanRead + CanWrite + CanDelete
        println!("✅ Admin: full access succeeded");
    }

    Ok(())
}</code></pre></pre>
<h2 id="head-first-moment-passport-stamps"><a class="header" href="#head-first-moment-passport-stamps">Head First Moment: Passport Stamps</a></h2>
<p>Think of <code>change_marker()</code> like <strong>stamping a passport</strong>:</p>
<ol>
<li><strong>You apply for a visa</strong> (submit token for validation)</li>
<li><strong>Visa office checks credentials</strong> (authorization function validates token)</li>
<li><strong>If approved, they stamp your passport</strong> (call <code>change_marker()</code>)</li>
<li><strong>Guards at checkpoints check your stamp</strong> (functions check marker type)</li>
</ol>
<p>The stamp doesn't grant permission — <strong>the visa office did that</strong>. The stamp just <strong>proves</strong> permission was granted.</p>
<p><strong>Functions check your stamp (marker), not your visa application (token).</strong></p>
<p>This means:</p>
<ul>
<li>✅ Authorization happens <strong>once</strong> (at the visa office)</li>
<li>✅ Every checkpoint trusts the stamp (no re-checking)</li>
<li>✅ Can't forge a stamp (only way to get marker is through auth function)</li>
<li>✅ Compiler ensures you have the right stamp for each checkpoint</li>
</ul>
<h2 id="the-authorization-pattern-summary"><a class="header" href="#the-authorization-pattern-summary">The Authorization Pattern Summary</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1️⃣ Define resource and permission markers
struct Resource;
struct ReadOnly;
struct ReadWrite;

// 2️⃣ Create authorization gate
fn authorize(token: &amp;str, path: StrictPath&lt;(Resource, ReadOnly)&gt;) 
    -&gt; Option&lt;StrictPath&lt;(Resource, ReadWrite)&gt;&gt; 
{
    if validate(token) {                        // ✅ Check authorization
        Some(path.change_marker())              // ✅ Encode in type
    } else {
        None                                    // ❌ Authorization failed
    }
}

// 3️⃣ Functions require authorized marker
fn protected_operation(path: &amp;StrictPath&lt;(Resource, ReadWrite)&gt;) {
    // No authorization check needed!
    // Type proves authorization already happened.
}
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-web-api"><a class="header" href="#real-world-example-web-api">Real-World Example: Web API</a></h2>
<p>Here's how you'd use this in a web server:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct ApiUploads;
struct AuthToken(String);
struct ReadAccess;
struct WriteAccess;

// Authorization: Validate JWT token
fn authorize_write_access(
    token: &amp;AuthToken,
    path: StrictPath&lt;(ApiUploads, ReadAccess)&gt;
) -&gt; Result&lt;StrictPath&lt;(ApiUploads, ReadAccess, WriteAccess)&gt;, AuthError&gt; {
    // ✅ Authorization: Validate JWT token
    if verify_jwt(&amp;token.0)? {
        Ok(path.change_marker())
    } else {
        Err(AuthError::InvalidToken)
    }
}

fn verify_jwt(token: &amp;str) -&gt; Result&lt;bool, AuthError&gt; {
    // Real implementation would:
    // - Verify signature
    // - Check expiration
    // - Validate claims
    Ok(token.starts_with("Bearer "))
}

// API handlers
fn handle_read(uploads: &amp;StrictPath&lt;(ApiUploads, ReadAccess)&gt;, filename: &amp;str) 
    -&gt; Result&lt;Vec&lt;u8&gt;, ApiError&gt; 
{
    let file = uploads.strict_join(filename)?;
    Ok(file.read()?)
}

fn handle_write(
    uploads: &amp;StrictPath&lt;(ApiUploads, ReadAccess, WriteAccess)&gt;, 
    filename: &amp;str,
    data: &amp;[u8]
) -&gt; Result&lt;(), ApiError&gt; 
{
    let file = uploads.strict_join(filename)?;
    Ok(file.write(data)?)
}

#[derive(Debug)]
enum AuthError {
    InvalidToken,
}

#[derive(Debug)]
enum ApiError {
    PathError(strict_path::StrictPathError),
    IoError(std::io::Error),
}

impl From&lt;strict_path::StrictPathError&gt; for ApiError {
    fn from(e: strict_path::StrictPathError) -&gt; Self {
        ApiError::PathError(e)
    }
}

impl From&lt;std::io::Error&gt; for ApiError {
    fn from(e: std::io::Error) -&gt; Self {
        ApiError::IoError(e)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways-3"><a class="header" href="#key-takeaways-3">Key Takeaways</a></h2>
<p>✅ <strong><code>change_marker()</code> encodes proven authorization</strong> (doesn't grant it)<br />
✅ <strong>Tuple markers compose resources and permissions</strong><br />
✅ <strong>Authorization happens once</strong> — type system enforces it everywhere<br />
✅ <strong>Impossible to bypass</strong> — only way to get the marker is through auth gate<br />
✅ <strong>Compiler catches missing authorization</strong> — won't compile without proper marker</p>
<h2 id="the-complete-guarantee-so-far"><a class="header" href="#the-complete-guarantee-so-far">The Complete Guarantee So Far</a></h2>
<blockquote>
<p><strong>If a function accepts <code>StrictPath&lt;(Resource, Permission)&gt;</code>, the compiler mathematically proves that:</strong></p>
<ol>
<li>✅ The path cannot escape its boundary (Stage 1)</li>
<li>✅ The path is in the correct domain (Stage 3)</li>
<li>✅ Authorization was granted for that permission level (Stage 4)</li>
</ol>
</blockquote>
<p><strong>This is compile-time authorization.</strong> Forget a check? Won't compile. Use the wrong permission level? Won't compile. Bypass authorization? Impossible.</p>
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What's Next?</a></h2>
<p>You've mastered authorization with markers. But what about <strong>user-facing applications</strong> where you want to show clean paths like <code>/documents/file.txt</code> instead of ugly system paths?</p>
<p>That's where <code>VirtualPath</code> comes in...</p>
<p><strong><a href="tutorial/./stage5_virtual_paths.html">Continue to Stage 5: Virtual Paths →</a></strong></p>
<hr />
<p><strong>Quick Reference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define markers
struct Resource;
struct ReadOnly;
struct ReadWrite;

// Authorization gate
fn authorize(token: &amp;str, path: StrictPath&lt;(Resource, ReadOnly)&gt;) 
    -&gt; Option&lt;StrictPath&lt;(Resource, ReadWrite)&gt;&gt; 
{
    if validate(token) {
        Some(path.change_marker())  // Encode authorization
    } else {
        None
    }
}

// Protected function
fn protected(path: &amp;StrictPath&lt;(Resource, ReadWrite)&gt;) {
    // No auth check needed — type proves it!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-5-virtual-paths--containment-for-sandboxes"><a class="header" href="#stage-5-virtual-paths--containment-for-sandboxes">Stage 5: Virtual Paths — Containment for Sandboxes</a></h1>
<blockquote>
<p><em>"Contain escape attempts for multi-tenant isolation and security research."</em></p>
</blockquote>
<p>In Stage 4, you learned how to encode authorization in markers. Now you'll learn how <code>VirtualPath</code> extends <code>StrictPath</code> with <strong>virtual filesystem semantics</strong> — designed for scenarios where path escapes are <strong>expected but must be controlled</strong>.</p>
<p><strong>Important</strong>: VirtualPath is opt-in via the <code>virtual-path</code> feature. Use it only when you need <strong>containment</strong> (multi-tenant systems, malware sandboxes) rather than <strong>detection</strong> (archive extraction, file uploads).</p>
<h2 id="the-problem-with-strictpath-for-user-ux"><a class="header" href="#the-problem-with-strictpath-for-user-ux">The Problem with StrictPath for User UX</a></h2>
<p><code>StrictPath</code> is perfect for system operations, but it exposes real filesystem paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn show_user_files() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads_dir = StrictPath::with_boundary_create("/var/app/users/alice/uploads")?;
    let file = uploads_dir.strict_join("documents/report.pdf")?;

    // User sees ugly system path
    println!("Your file: {}", file.strictpath_display());
    // Output: /var/app/users/alice/uploads/documents/report.pdf
    
    // User thinks: "Why do I need to know about /var/app/users/alice?"
    // "I just want to see: /documents/report.pdf"

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Problems:</strong></p>
<ul>
<li>❌ Users see internal directory structure</li>
<li>❌ Paths are long and confusing</li>
<li>❌ Exposes system architecture details</li>
<li>❌ Not user-friendly for file browsers, cloud storage UI, etc.</li>
</ul>
<h2 id="the-solution-virtualpath"><a class="header" href="#the-solution-virtualpath">The Solution: VirtualPath</a></h2>
<p><code>VirtualPath</code> provides a <strong>virtual root</strong> — users see paths starting from <code>/</code>, but the system enforces the real boundary:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

fn show_user_files_virtually() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a virtual root (system boundary: /var/app/users/alice/uploads)
    let user_vroot = VirtualPath::with_root("/var/app/users/alice/uploads")?;
    
    let file = user_vroot.virtual_join("documents/report.pdf")?;

    // User sees clean virtual path
    println!("Your file: {}", file.virtualpath_display());
    // Output: /documents/report.pdf
    
    // User thinks: "Perfect! That's my file."

    // System still operates on real path
    file.write(b"File contents")?;  
    // Actually writes to: /var/app/users/alice/uploads/documents/report.pdf

    println!("System path: {}", file.as_unvirtual().strictpath_display());
    // Output: /var/app/users/alice/uploads/documents/report.pdf

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="clamping-vs-rejecting"><a class="header" href="#clamping-vs-rejecting">Clamping vs. Rejecting</a></h2>
<p>This is the <strong>key difference</strong> between <code>VirtualPath</code> and <code>StrictPath</code>:</p>
<h3 id="strictpath-rejects-escapes"><a class="header" href="#strictpath-rejects-escapes">StrictPath: Rejects Escapes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn strict_behavior() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let boundary = StrictPath::with_boundary_create("sandbox")?;

    // Normal path works
    let file1 = boundary.strict_join("data/file.txt")?;
    println!("✅ Valid: {}", file1.strictpath_display());

    // Attack attempt: FAILS with error
    let file2 = boundary.strict_join("../../../etc/passwd");
    match file2 {
        Ok(_) =&gt; println!("✅ Valid path"),
        Err(e) =&gt; println!("❌ Error: {}", e),  // PathEscapesBoundary
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="virtualpath-clamps-escapes"><a class="header" href="#virtualpath-clamps-escapes">VirtualPath: Clamps Escapes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

fn virtual_behavior() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let vroot = VirtualPath::with_root("sandbox")?;

    // Normal path works
    let file1 = vroot.virtual_join("data/file.txt")?;
    println!("Virtual: {}", file1.virtualpath_display());  // /data/file.txt

    // Attack attempt: CLAMPED safely
    let file2 = vroot.virtual_join("../../../etc/passwd")?;  // No error!
    println!("Virtual: {}", file2.virtualpath_display());    // /etc/passwd (clamped!)
    
    // But system path is still safe:
    println!("System: {}", file2.as_unvirtual().strictpath_display());
    // Output: sandbox/etc/passwd (still inside boundary!)

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key difference:</strong></p>
<ul>
<li><strong><code>StrictPath</code>:</strong> Escape attempt → <strong>Error</strong> (explicit rejection)</li>
<li><strong><code>VirtualPath</code>:</strong> Escape attempt → <strong>Clamped to boundary</strong> (graceful containment)</li>
</ul>
<h2 id="when-to-use-which"><a class="header" href="#when-to-use-which">When to Use Which</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use</th><th>Why</th></tr></thead><tbody>
<tr><td><strong>Web API validation</strong></td><td><code>StrictPath</code></td><td>Fail fast on invalid input</td></tr>
<tr><td><strong>System config files</strong></td><td><code>StrictPath</code></td><td>Reject malformed paths explicitly</td></tr>
<tr><td><strong>User file browser</strong></td><td><code>VirtualPath</code></td><td>Show clean <code>/</code> paths, clamp escapes gracefully</td></tr>
<tr><td><strong>Archive extraction</strong></td><td><code>VirtualPath</code></td><td>Hostile archive entries can't escape</td></tr>
<tr><td><strong>Cloud storage UI</strong></td><td><code>VirtualPath</code></td><td>Users see <code>/MyFiles/</code> instead of system paths</td></tr>
<tr><td><strong>LLM file operations</strong></td><td><code>StrictPath</code></td><td>LLM-generated paths validated strictly</td></tr>
</tbody></table>
</div>
<p><strong>Rule of thumb:</strong></p>
<ul>
<li><strong>System-facing?</strong> → <code>StrictPath</code> (explicit errors)</li>
<li><strong>User-facing?</strong> → <code>VirtualPath</code> (graceful clamping)</li>
</ul>
<h2 id="try-it-yourself-per-user-sandboxes"><a class="header" href="#try-it-yourself-per-user-sandboxes">Try It Yourself: Per-User Sandboxes</a></h2>
<p>Here's a realistic example of per-user isolation:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::{VirtualPath, VirtualRoot};

struct UserFiles;

fn create_user_workspace(user_id: u64) -&gt; Result&lt;VirtualRoot&lt;UserFiles&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    // Each user gets their own virtual root
    let user_dir = format!("users/user_{}", user_id);
    Ok(VirtualRoot::try_new_create(user_dir)?)
}

fn user_file_browser(user_id: u64) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let user_workspace = create_user_workspace(user_id)?;

    // User uploads files (they see clean paths)
    let doc = user_workspace.virtual_join("Documents/report.pdf")?;
    doc.create_parent_dir_all()?;
    doc.write(b"User document content")?;

    println!("User {} sees: {}", user_id, doc.virtualpath_display());
    // Output: /Documents/report.pdf

    println!("System stores at: {}", doc.as_unvirtual().strictpath_display());
    // Output: users/user_123/Documents/report.pdf

    // Even if user tries to escape, they stay in their sandbox
    let sneaky = user_workspace.virtual_join("../../../etc/passwd")?;
    println!("Attack clamped to: {}", sneaky.virtualpath_display());
    // Output: /etc/passwd (virtual)
    
    println!("Actually safe at: {}", sneaky.as_unvirtual().strictpath_display());
    // Output: users/user_123/etc/passwd (still in their sandbox!)

    Ok(())
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    user_file_browser(123)?;
    user_file_browser(456)?;
    Ok(())
}</code></pre></pre>
<h2 id="virtualpath--strictpath--virtual-view"><a class="header" href="#virtualpath--strictpath--virtual-view">VirtualPath = StrictPath + Virtual View</a></h2>
<p>Under the hood, <code>VirtualPath</code> <strong>wraps a <code>StrictPath</code></strong> and adds a virtual display layer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

fn demonstrate_duality() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let vpath = VirtualPath::with_root("data")?.virtual_join("file.txt")?;

    // Virtual view (user-facing)
    println!("Virtual: {}", vpath.virtualpath_display());
    // Output: /file.txt

    // System view (actual filesystem path)
    println!("System: {}", vpath.as_unvirtual().strictpath_display());
    // Output: data/file.txt

    // All StrictPath operations work
    vpath.write(b"Hello, virtual world!")?;
    let content = vpath.read_to_string()?;
    println!("Content: {}", content);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>The relationship:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>VirtualPath&lt;Marker&gt; = StrictPath&lt;Marker&gt; + virtual display semantics
<span class="boring">}</span></code></pre></pre>
<h2 id="symlinks-and-virtual-paths-the-critical-difference"><a class="header" href="#symlinks-and-virtual-paths-the-critical-difference">Symlinks and Virtual Paths: The Critical Difference</a></h2>
<p>This is where <code>VirtualPath</code> truly shines as a <strong>virtual filesystem</strong>. It doesn't just clamp relative path escapes — it also <strong>clamps absolute symlink targets</strong>:</p>
<h3 id="strictpath-validates-symlink-targets"><a class="header" href="#strictpath-validates-symlink-targets">StrictPath: Validates Symlink Targets</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn strict_symlink_behavior() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let boundary = StrictPath::with_boundary_create("sandbox")?;

    // If "sandbox/config_link" symlinks to "/etc/passwd":
    let symlink_path = boundary.strict_join("config_link");
    match symlink_path {
        Ok(_) =&gt; println!("✅ Symlink target is inside boundary"),
        Err(e) =&gt; println!("❌ Symlink escapes boundary: {}", e),
    }
    
    // StrictPath follows the symlink and validates the *target* is inside boundary
    // If target is outside → Error (PathEscapesBoundary)

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="virtualpath-clamps-symlink-targets"><a class="header" href="#virtualpath-clamps-symlink-targets">VirtualPath: Clamps Symlink Targets</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

fn virtual_symlink_behavior() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let vroot = VirtualPath::with_root("sandbox")?;

    // If "sandbox/config_link" symlinks to "/etc/passwd":
    let symlink_path = vroot.virtual_join("config_link")?;  // No error!
    
    println!("Virtual view: {}", symlink_path.virtualpath_display());
    // Output: /etc/passwd (clamped to virtual root!)
    
    println!("System path: {}", symlink_path.as_unvirtual().strictpath_display());
    // Output: sandbox/etc/passwd (safely inside boundary!)

    // VirtualPath treats absolute symlink targets as *relative to the virtual root*
    // The symlink target "/etc/passwd" becomes "sandbox/etc/passwd"
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>The Key Insight:</strong></p>
<p>In a <strong>virtual filesystem</strong> (container, chroot, sandbox), absolute paths are <em>always</em> relative to the virtual root. This applies whether the absolute path comes from:</p>
<ul>
<li>User input: <code>vroot.virtual_join("/etc/passwd")</code> → clamped</li>
<li>Symlink target: <code>config_link -&gt; /etc/passwd</code> → clamped</li>
</ul>
<p><strong>Why This Matters:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>StrictPath Behavior</th><th>VirtualPath Behavior</th></tr></thead><tbody>
<tr><td>User input <code>"../../../etc/passwd"</code></td><td>❌ Error (rejected)</td><td>✅ Clamped to <code>/etc/passwd</code> in vroot</td></tr>
<tr><td>Symlink <code>link -&gt; /etc/passwd</code></td><td>❌ Error if outside</td><td>✅ Clamped to vroot <code>/etc/passwd</code></td></tr>
<tr><td>Archive entry <code>"/sensitive/data"</code></td><td>❌ Error (rejected)</td><td>✅ Clamped to vroot <code>/sensitive/data</code></td></tr>
</tbody></table>
</div>
<p><strong>Use Cases:</strong></p>
<ul>
<li><strong>Archive extraction:</strong> Malicious archives with absolute symlinks are automatically safe</li>
<li><strong>Multi-tenant storage:</strong> User A's symlink can't escape to user B's files</li>
<li><strong>Container-like semantics:</strong> Perfect for sandboxed environments where <code>/</code> means "root of this container"</li>
</ul>
<p><strong>Key point:</strong> <code>VirtualPath</code> implements <strong>true virtual filesystem semantics</strong> where absolute paths (from any source) are interpreted relative to the virtual root. This is not a "trust everything" mode — it's a mathematically consistent sandbox model.</p>
<h2 id="real-world-example-cloud-file-storage"><a class="header" href="#real-world-example-cloud-file-storage">Real-World Example: Cloud File Storage</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{VirtualPath, VirtualRoot};

struct CloudStorage;

struct UserCloudStorage {
    user_id: u64,
    vroot: VirtualRoot&lt;CloudStorage&gt;,
}

impl UserCloudStorage {
    fn new(user_id: u64) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        let storage_path = format!("cloud_storage/user_{}", user_id);
        let vroot = VirtualRoot::try_new_create(storage_path)?;
        Ok(Self { user_id, vroot })
    }

    fn upload_file(&amp;self, virtual_path: &amp;str, data: &amp;[u8]) 
        -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; 
    {
        let file = self.vroot.virtual_join(virtual_path)?;
        file.create_parent_dir_all()?;
        file.write(data)?;
        
        // Return clean virtual path for UI display
        Ok(file.virtualpath_display().to_string())
    }

    fn download_file(&amp;self, virtual_path: &amp;str) 
        -&gt; Result&lt;Vec&lt;u8&gt;, Box&lt;dyn std::error::Error&gt;&gt; 
    {
        let file = self.vroot.virtual_join(virtual_path)?;
        Ok(file.read()?)
    }

    fn list_files(&amp;self, virtual_dir: &amp;str) 
        -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; 
    {
        let dir = self.vroot.virtual_join(virtual_dir)?;
        let mut files = Vec::new();
        
        for entry in dir.read_dir()? {
            let entry = entry?;
            let vpath = self.vroot.virtual_join(entry.file_name().to_string_lossy().as_ref())?;
            files.push(vpath.virtualpath_display().to_string());
        }
        
        Ok(files)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let alice_storage = UserCloudStorage::new(1001)?;

    // Upload files (user sees clean paths)
    let path1 = alice_storage.upload_file("Photos/vacation.jpg", b"photo data")?;
    let path2 = alice_storage.upload_file("Documents/report.pdf", b"document data")?;
    
    println!("Uploaded: {}", path1);  // /Photos/vacation.jpg
    println!("Uploaded: {}", path2);  // /Documents/report.pdf

    // Download files
    let data = alice_storage.download_file("/Documents/report.pdf")?;
    println!("Downloaded {} bytes", data.len());

    // User tries to escape — safely clamped
    let evil_path = alice_storage.upload_file("../../../etc/passwd", b"attack")?;
    println!("Attack clamped to: {}", evil_path);  // /etc/passwd (in user's sandbox!)

    Ok(())
}</code></pre></pre>
<h2 id="markers-work-with-virtualpath-too"><a class="header" href="#markers-work-with-virtualpath-too">Markers Work with VirtualPath Too</a></h2>
<p>Just like <code>StrictPath</code>, you can use markers with <code>VirtualPath</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{VirtualPath, VirtualRoot};

struct UserPhotos;
struct UserDocuments;

fn organize_virtual_storage(user_id: u64) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Each domain gets its own virtual root
    let photos_vroot: VirtualRoot&lt;UserPhotos&gt; = 
        VirtualRoot::try_new_create(format!("users/user_{}/photos", user_id))?;
    
    let docs_vroot: VirtualRoot&lt;UserDocuments&gt; = 
        VirtualRoot::try_new_create(format!("users/user_{}/documents", user_id))?;

    let photo = photos_vroot.virtual_join("vacation.jpg")?;  // VirtualPath&lt;UserPhotos&gt;
    let doc = docs_vroot.virtual_join("report.pdf")?;        // VirtualPath&lt;UserDocuments&gt;

    process_photo(&amp;photo)?;              // ✅ Correct type
    process_document(&amp;doc)?;             // ✅ Correct type
    // process_photo(&amp;doc)?;             // ❌ Compile error!

    Ok(())
}

fn process_photo(photo: &amp;VirtualPath&lt;UserPhotos&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Processing photo: {}", photo.virtualpath_display());
    Ok(())
}

fn process_document(doc: &amp;VirtualPath&lt;UserDocuments&gt;) -&gt; std::io::Result&lt;()&gt; {
    println!("Processing document: {}", doc.virtualpath_display());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="head-first-moment-storefront-facade"><a class="header" href="#head-first-moment-storefront-facade">Head First Moment: Storefront Facade</a></h2>
<p><code>VirtualPath</code> is like a <strong>storefront with a clean facade</strong>:</p>
<ul>
<li><strong>Customers see:</strong> Beautiful <code>/Products/Item</code> URLs</li>
<li><strong>Behind the scenes:</strong> Files stored at <code>/var/www/store/inventory/category-5/sku-12345/item.jpg</code></li>
</ul>
<p>The facade (virtual path) makes for better UX. The real structure (strict path) handles the actual filesystem operations.</p>
<p><strong>Best of both worlds:</strong></p>
<ul>
<li>Users see clean, understandable paths</li>
<li>System operates on real, validated paths</li>
<li>Security boundary enforced throughout</li>
</ul>
<h2 id="when-to-use-virtualpath-vs-strictpath"><a class="header" href="#when-to-use-virtualpath-vs-strictpath">When to Use VirtualPath vs. StrictPath</a></h2>
<h3 id="use-virtualpath-containment-when"><a class="header" href="#use-virtualpath-containment-when">Use VirtualPath (Containment) When:</a></h3>
<ul>
<li>✅ <strong>Multi-tenant systems</strong> — each user needs isolated <code>/</code> view</li>
<li>✅ <strong>Malware sandboxes</strong> — observe behavior while containing escapes</li>
<li>✅ <strong>Archive analysis</strong> — safely study suspicious archives in research environments</li>
<li>✅ <strong>Container-like plugins</strong> — modules get their own filesystem view</li>
<li>✅ <strong>Security research</strong> — simulate contained environments</li>
<li>✅ Path escapes are <strong>expected but must be controlled</strong></li>
</ul>
<h3 id="use-strictpath-detection-when"><a class="header" href="#use-strictpath-detection-when">Use StrictPath (Detection) When:</a></h3>
<ul>
<li>✅ <strong>Production archive extraction</strong> — detect malicious paths, reject compromised archives, alert users</li>
<li>✅ <strong>File uploads</strong> — reject user paths with traversal attempts</li>
<li>✅ <strong>Config loading</strong> — fail on untrusted paths that try to escape</li>
<li>✅ <strong>System resources</strong> — logs, cache, assets with strict boundaries</li>
<li>✅ Path escapes indicate <strong>malicious intent</strong> that must be detected</li>
</ul>
<p><strong>Key Insight for Archives</strong>: Use StrictPath for <strong>production extraction</strong> (detect and reject attacks). Use VirtualPath for <strong>research/sandboxing</strong> (safely analyze suspicious archives while containing their behavior).</p>
<h2 id="key-takeaways-4"><a class="header" href="#key-takeaways-4">Key Takeaways</a></h2>
<p>✅ <strong><code>VirtualPath</code> = <code>StrictPath</code> + virtual <code>/</code> view</strong><br />
✅ <strong>Clamping behavior</strong> — escapes are contained, not rejected<br />
✅ <strong>User-friendly display</strong> — show clean paths in UIs<br />
✅ <strong>Per-user sandboxes</strong> — each user gets their own virtual root<br />
✅ <strong>Markers work</strong> — domain separation applies to virtual paths too<br />
✅ <strong>Symlinks still validated</strong> — not a "trust everything" mode<br />
✅ <strong>Opt-in feature</strong> — requires <code>virtual-path</code> in <code>Cargo.toml</code></p>
<h2 id="the-complete-guarantee"><a class="header" href="#the-complete-guarantee">The Complete Guarantee</a></h2>
<blockquote>
<p><strong>If you have a <code>VirtualPath&lt;Marker&gt;</code>, the compiler guarantees:</strong></p>
<ol>
<li>✅ The path cannot escape its boundary (Stage 1)</li>
<li>✅ The path is in the correct domain (Stage 3)</li>
<li>✅ Virtual display is always rooted at <code>/</code> (Stage 5)</li>
<li>✅ System operations use the validated real path (Stage 5)</li>
</ol>
</blockquote>
<h2 id="whats-next-5"><a class="header" href="#whats-next-5">What's Next?</a></h2>
<p>You now understand both <code>StrictPath</code> and <code>VirtualPath</code>. But how do you integrate with <strong>external ecosystem crates</strong> like OS directories, temp files, and app-specific paths?</p>
<p>That's where <strong>feature-gated constructors</strong> come in...</p>
<p><strong><a href="tutorial/./stage6_features.html">Continue to Stage 6: Feature Integration →</a></strong></p>
<hr />
<p><strong>Quick Reference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create virtual root
let vroot = VirtualPath::with_root("path")?;

// Validate and clamp
let vpath = vroot.virtual_join(untrusted_input)?;

// Display
println!("Virtual: {}", vpath.virtualpath_display());      // /file.txt
println!("System: {}", vpath.as_unvirtual().strictpath_display());  // path/file.txt

// I/O operations
vpath.write(data)?;
let content = vpath.read_to_string()?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage-6-feature-integration--ecosystem-integration-with-safe-boundaries"><a class="header" href="#stage-6-feature-integration--ecosystem-integration-with-safe-boundaries">Stage 6: Feature Integration — Ecosystem Integration with Safe Boundaries</a></h1>
<blockquote>
<p><em>"Integrate with OS directories, temp files, and app-specific paths — safely."</em></p>
</blockquote>
<p>You've mastered the core concepts: boundaries, markers, authorization, and virtual paths. Now you'll learn how to integrate strict-path with your ecosystem using <strong>feature-gated constructors</strong> that work seamlessly with popular Rust crates.</p>
<h2 id="the-problem-external-directory-apis"><a class="header" href="#the-problem-external-directory-apis">The Problem: External Directory APIs</a></h2>
<p>Your app needs to work with standard directories:</p>
<ul>
<li><strong>User config:</strong> <code>~/.config/myapp/</code> (Linux) or <code>C:\Users\Alice\AppData\Roaming\myapp\</code> (Windows)</li>
<li><strong>Temp files:</strong> System temp directory with automatic cleanup</li>
<li><strong>Downloads:</strong> User's Downloads folder</li>
<li><strong>App directories:</strong> Portable app-specific paths</li>
</ul>
<p>But you still need <strong>boundary enforcement</strong>! Otherwise, untrusted input can escape these directories too.</p>
<h2 id="the-solution-feature-gated-constructors"><a class="header" href="#the-solution-feature-gated-constructors">The Solution: Feature-Gated Constructors</a></h2>
<p>Enable features in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
strict-path = { version = "0.1.0-beta.2", features = ["dirs", "tempfile", "app-path", "serde"] }
</code></pre>
<p>Now you get special constructors that combine external crate APIs with strict-path's boundary enforcement.</p>
<h2 id="feature-dirs--os-standard-directories"><a class="header" href="#feature-dirs--os-standard-directories">Feature: <code>dirs</code> — OS Standard Directories</a></h2>
<p>The <code>dirs</code> feature adds constructors for platform-specific user directories:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

struct AppConfig;
struct UserDownloads;
struct UserDocuments;

fn use_os_directories() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Get user's config directory (platform-specific)
    let config_dir: PathBoundary&lt;AppConfig&gt; = PathBoundary::try_new_os_config("myapp")?;
    // Linux: ~/.config/myapp/
    // Windows: C:\Users\Alice\AppData\Roaming\myapp\
    // macOS: ~/Library/Application Support/myapp/

    let config_file = config_dir.strict_join("settings.toml")?;
    config_file.write(b"theme = dark\nlanguage = en")?;
    println!("Config: {}", config_file.strictpath_display());

    // Get user's downloads directory
    let downloads_dir: PathBoundary&lt;UserDownloads&gt; = PathBoundary::try_new_os_downloads()?;
    let export_file = downloads_dir.strict_join("export.csv")?;
    export_file.write(b"col1,col2\nval1,val2")?;
    println!("Export: {}", export_file.strictpath_display());

    // Get user's documents directory
    let docs_dir: PathBoundary&lt;UserDocuments&gt; = PathBoundary::try_new_os_documents()?;
    let report = docs_dir.strict_join("report.pdf")?;
    report.write(b"PDF content")?;
    println!("Report: {}", report.strictpath_display());

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="available-os-directory-constructors"><a class="header" href="#available-os-directory-constructors">Available OS Directory Constructors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Constructor</th><th>Linux</th><th>Windows</th><th>macOS</th></tr></thead><tbody>
<tr><td><code>try_new_os_config("app")</code></td><td><code>~/.config/app/</code></td><td><code>C:\Users\...\AppData\Roaming\app\</code></td><td><code>~/Library/Application Support/app/</code></td></tr>
<tr><td><code>try_new_os_data("app")</code></td><td><code>~/.local/share/app/</code></td><td><code>C:\Users\...\AppData\Roaming\app\</code></td><td><code>~/Library/Application Support/app/</code></td></tr>
<tr><td><code>try_new_os_cache("app")</code></td><td><code>~/.cache/app/</code></td><td><code>C:\Users\...\AppData\Local\app\</code></td><td><code>~/Library/Caches/app/</code></td></tr>
<tr><td><code>try_new_os_downloads()</code></td><td><code>~/Downloads/</code></td><td><code>C:\Users\...\Downloads\</code></td><td><code>~/Downloads/</code></td></tr>
<tr><td><code>try_new_os_documents()</code></td><td><code>~/Documents/</code></td><td><code>C:\Users\...\Documents\</code></td><td><code>~/Documents/</code></td></tr>
<tr><td><code>try_new_os_pictures()</code></td><td><code>~/Pictures/</code></td><td><code>C:\Users\...\Pictures\</code></td><td><code>~/Pictures/</code></td></tr>
<tr><td><code>try_new_os_videos()</code></td><td><code>~/Videos/</code></td><td><code>C:\Users\...\Videos\</code></td><td><code>~/Videos/</code></td></tr>
<tr><td><code>try_new_os_music()</code></td><td><code>~/Music/</code></td><td><code>C:\Users\...\Music\</code></td><td><code>~/Music/</code></td></tr>
</tbody></table>
</div>
<p>See the <a href="tutorial/../os_directories.html">OS Directories chapter</a> for the complete list and details.</p>
<h3 id="try-it-cross-platform-config-manager"><a class="header" href="#try-it-cross-platform-config-manager">Try It: Cross-Platform Config Manager</a></h3>
<pre><pre class="playground"><code class="language-rust">use strict_path::PathBoundary;

struct AppSettings;

fn save_user_settings(theme: &amp;str, language: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Works on Linux, Windows, and macOS automatically!
    let config_dir: PathBoundary&lt;AppSettings&gt; = 
        PathBoundary::try_new_os_config("myapp")?;

    let settings_file = config_dir.strict_join("settings.toml")?;
    let content = format!("theme = {}\nlanguage = {}\n", theme, language);
    settings_file.write(content.as_bytes())?;

    println!("Settings saved to: {}", settings_file.strictpath_display());
    Ok(())
}

fn load_user_settings() -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    let config_dir: PathBoundary&lt;AppSettings&gt; = 
        PathBoundary::try_new_os_config("myapp")?;

    let settings_file = config_dir.strict_join("settings.toml")?;
    Ok(settings_file.read_to_string()?)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    save_user_settings("dark", "en")?;
    let settings = load_user_settings()?;
    println!("Loaded settings:\n{}", settings);
    Ok(())
}</code></pre></pre>
<h2 id="feature-tempfile--automatic-cleanup-with-raii"><a class="header" href="#feature-tempfile--automatic-cleanup-with-raii">Feature: <code>tempfile</code> — Automatic Cleanup with RAII</a></h2>
<p>The <code>tempfile</code> feature works with the <code>tempfile</code> crate for automatic cleanup:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::PathBoundary;
use tempfile::TempDir;

struct WorkDir;

fn process_with_temp() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create temporary directory (cleaned up automatically when dropped)
    let temp = TempDir::new()?;
    
    println!("Created temp directory: {:?}", temp.path());

    // Wrap in PathBoundary for safe operations
    let work_dir: PathBoundary&lt;WorkDir&gt; = PathBoundary::try_new(temp.path())?;

    // Do work inside temp directory — all paths validated!
    let intermediate = work_dir.strict_join("intermediate.json")?;
    intermediate.write(b"{\"status\": \"processing\"}")?;

    let output = work_dir.strict_join("output.txt")?;
    output.write(b"Final result")?;

    // Try to escape — fails!
    match work_dir.strict_join("../../../etc/passwd") {
        Ok(_) =&gt; println!("❌ Escape succeeded (should not happen!)"),
        Err(e) =&gt; println!("✅ Escape blocked: {}", e),
    }

    println!("Work directory: {}", work_dir.strictpath_display());
    println!("Output file: {}", output.strictpath_display());

    // When this function returns, `temp` is dropped → directory deleted automatically
    Ok(())
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    process_with_temp()?;
    println!("Temp directory has been automatically cleaned up!");
    Ok(())
}</code></pre></pre>
<p><strong>Key benefits:</strong></p>
<ul>
<li>✅ <strong>RAII cleanup</strong> — temp directory deleted when <code>TempDir</code> drops</li>
<li>✅ <strong>Boundary enforcement</strong> — even in temp directories, paths can't escape</li>
<li>✅ <strong>No manual cleanup</strong> — Rust handles it for you</li>
</ul>
<h3 id="try-it-safe-archive-processing"><a class="header" href="#try-it-safe-archive-processing">Try It: Safe Archive Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;
use tempfile::TempDir;

struct ArchiveExtract;

fn extract_and_process_archive(archive_data: &amp;[u8]) 
    -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; 
{
    // Create temp directory for extraction
    let temp = TempDir::new()?;
    let extract_dir: PathBoundary&lt;ArchiveExtract&gt; = 
        PathBoundary::try_new(temp.path())?;

    // Simulate extracting files (in reality, use zip crate)
    let file1 = extract_dir.strict_join("readme.txt")?;
    file1.write(b"Archive contents...")?;

    let file2 = extract_dir.strict_join("data/values.csv")?;
    file2.create_parent_dir_all()?;
    file2.write(b"col1,col2\n1,2")?;

    // Even if archive contains hostile paths, they're validated
    match extract_dir.strict_join("../../../evil.sh") {
        Ok(_) =&gt; println!("❌ Hostile path accepted!"),
        Err(e) =&gt; println!("✅ Hostile path blocked: {}", e),
    }

    // Collect extracted files
    let mut files = Vec::new();
    files.push(file1.strictpath_display().to_string());
    files.push(file2.strictpath_display().to_string());

    // Temp directory deleted automatically when function returns
    Ok(files)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="feature-app-path--portable-application-directories"><a class="header" href="#feature-app-path--portable-application-directories">Feature: <code>app-path</code> — Portable Application Directories</a></h2>
<p>The <code>app-path</code> feature provides portable app-specific paths with environment variable overrides:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

struct AppLogs;
struct AppData;

fn setup_app_directories() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Get app-specific log directory with environment override support
    // If MYAPP_LOGS_DIR is set, uses that path
    // Otherwise, uses platform-specific app directory + "logs" subdirectory
    let logs_dir: PathBoundary&lt;AppLogs&gt; = 
        PathBoundary::try_new_app_path("logs", Some("MYAPP_LOGS_DIR"))?;
    
    let error_log = logs_dir.strict_join("errors.log")?;
    error_log.write(b"[ERROR] Example error message\n")?;

    let access_log = logs_dir.strict_join("access.log")?;
    access_log.write(b"[INFO] User accessed /api/data\n")?;

    println!("Logs directory: {}", logs_dir.strictpath_display());

    // Get app-specific data directory with environment override support
    let data_dir: PathBoundary&lt;AppData&gt; = 
        PathBoundary::try_new_app_path("data", Some("MYAPP_DATA_DIR"))?;

    let database = data_dir.strict_join("app.db")?;
    database.write(b"SQLite database content")?;

    println!("Data directory: {}", data_dir.strictpath_display());

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="environment-variable-overrides"><a class="header" href="#environment-variable-overrides">Environment Variable Overrides</a></h3>
<p>You can override the default locations using environment variables:</p>
<pre><code class="language-bash"># Override logs directory
export MYAPP_LOGS_DIR=/custom/log/path

# Override data directory
export MYAPP_DATA_DIR=/custom/data/path
</code></pre>
<p><strong>When the environment variable is set, the path is resolved to the final directory — no subdirectory append happens.</strong></p>
<p>This is useful for:</p>
<ul>
<li>✅ Testing with custom paths</li>
<li>✅ Deployment-specific configurations</li>
<li>✅ Docker container mounts</li>
<li>✅ CI/CD pipelines</li>
</ul>
<h2 id="feature-serde--safe-deserialization-with-validation"><a class="header" href="#feature-serde--safe-deserialization-with-validation">Feature: <code>serde</code> — Safe Deserialization with Validation</a></h2>
<p>The <code>serde</code> feature adds safe serialization/deserialization with automatic validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, serde_ext::WithBoundary};
use serde::{Deserialize, Serialize};

struct ConfigFiles;
struct DataFiles;

#[derive(Deserialize, Serialize)]
struct AppConfig {
    app_name: String,
    
    // Deserialize with validation through boundary
    #[serde(deserialize_with = "deserialize_log_file")]
    log_file: StrictPath&lt;ConfigFiles&gt;,
    
    #[serde(deserialize_with = "deserialize_data_file")]
    data_file: StrictPath&lt;DataFiles&gt;,
}

fn deserialize_log_file&lt;'de, D&gt;(deserializer: D) 
    -&gt; Result&lt;StrictPath&lt;ConfigFiles&gt;, D::Error&gt;
where
    D: serde::Deserializer&lt;'de&gt;,
{
    let config_dir: PathBoundary&lt;ConfigFiles&gt; = 
        PathBoundary::try_new("config").map_err(serde::de::Error::custom)?;
    
    // Use WithBoundary seed to validate during deserialization
    let seed = WithBoundary(&amp;config_dir);
    seed.deserialize(deserializer)
}

fn deserialize_data_file&lt;'de, D&gt;(deserializer: D) 
    -&gt; Result&lt;StrictPath&lt;DataFiles&gt;, D::Error&gt;
where
    D: serde::Deserializer&lt;'de&gt;,
{
    let data_dir: PathBoundary&lt;DataFiles&gt; = 
        PathBoundary::try_new("data").map_err(serde::de::Error::custom)?;
    
    let seed = WithBoundary(&amp;data_dir);
    seed.deserialize(deserializer)
}

fn load_config() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let json = r#"{
        "app_name": "MyApp",
        "log_file": "logs/app.log",
        "data_file": "db/app.db"
    }"#;

    let config: AppConfig = serde_json::from_str(json)?;
    
    println!("App: {}", config.app_name);
    println!("Log file: {}", config.log_file.strictpath_display());
    println!("Data file: {}", config.data_file.strictpath_display());

    // Try loading config with hostile paths
    let evil_json = r#"{
        "app_name": "EvilApp",
        "log_file": "../../../etc/passwd",
        "data_file": "db/app.db"
    }"#;

    match serde_json::from_str::&lt;AppConfig&gt;(evil_json) {
        Ok(_) =&gt; println!("❌ Hostile config accepted!"),
        Err(e) =&gt; println!("✅ Hostile config rejected: {}", e),
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key point:</strong> Deserialization validates paths through boundaries — <strong>untrusted config files can't escape!</strong></p>
<h2 id="combining-features-real-world-application"><a class="header" href="#combining-features-real-world-application">Combining Features: Real-World Application</a></h2>
<p>Here's how you'd combine multiple features in a real application:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, VirtualRoot};
use tempfile::TempDir;

struct AppConfig;
struct AppLogs;
struct UserFiles;
struct TempProcessing;

struct Application {
    config_dir: PathBoundary&lt;AppConfig&gt;,
    logs_dir: PathBoundary&lt;AppLogs&gt;,
    user_files_root: VirtualRoot&lt;UserFiles&gt;,
}

impl Application {
    fn new(user_id: u64) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // OS-specific config directory
        let config_dir = PathBoundary::try_new_os_config("myapp")?;
        
        // App-specific log directory (with env override support)
        let logs_dir = PathBoundary::try_new_app_path("logs", None)?;
        
        // Per-user virtual root for file isolation
        let user_storage = format!("users/user_{}", user_id);
        let user_files_root = VirtualRoot::try_new_create(user_storage)?;

        Ok(Self {
            config_dir,
            logs_dir,
            user_files_root,
        })
    }

    fn load_config(&amp;self, config_name: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let config_file = self.config_dir.strict_join(config_name)?;
        Ok(config_file.read_to_string()?)
    }

    fn log_event(&amp;self, message: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        let log_file = self.logs_dir.strict_join("app.log")?;
        let mut log = log_file.read_to_string().unwrap_or_default();
        log.push_str(message);
        log.push('\n');
        log_file.write(log.as_bytes())?;
        Ok(())
    }

    fn process_user_file(&amp;self, filename: &amp;str) 
        -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; 
    {
        // Use temp directory for processing
        let temp = TempDir::new()?;
        let temp_dir: PathBoundary&lt;TempProcessing&gt; = 
            PathBoundary::try_new(temp.path())?;

        // Get user file (virtual path)
        let user_file = self.user_files_root.virtual_join(filename)?;
        let data = user_file.read()?;

        // Process in temp directory
        let temp_file = temp_dir.strict_join("processing.tmp")?;
        temp_file.write(&amp;data)?;

        // Log the operation
        self.log_event(&amp;format!("Processed file: {}", filename))?;

        // Return result
        Ok(format!("Processed {} bytes", data.len()))
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new(123)?;
    
    // Load config from OS-specific directory
    let config = app.load_config("settings.toml").unwrap_or_default();
    println!("Config: {}", config);

    // Process user file using temp directory
    let result = app.process_user_file("documents/report.pdf")?;
    println!("Result: {}", result);

    Ok(())
}</code></pre></pre>
<h2 id="key-takeaways-5"><a class="header" href="#key-takeaways-5">Key Takeaways</a></h2>
<p>✅ <strong><code>dirs</code> feature</strong> — OS-specific user directories (config, downloads, documents, etc.)<br />
✅ <strong><code>tempfile</code> feature</strong> — RAII temp directories with boundary enforcement<br />
✅ <strong><code>app-path</code> feature</strong> — Portable app paths with env override support<br />
✅ <strong><code>serde</code> feature</strong> — Safe deserialization with automatic validation<br />
✅ <strong>Combine features</strong> — Build real-world apps with ecosystem integration<br />
✅ <strong>Boundaries everywhere</strong> — Even external directories enforce security</p>
<h2 id="the-final-complete-guarantee"><a class="header" href="#the-final-complete-guarantee">The Final Complete Guarantee</a></h2>
<blockquote>
<p><strong>By combining all stages, you achieve:</strong></p>
<ol>
<li>✅ Paths cannot escape boundaries (Stage 1)</li>
<li>✅ Paths are in the correct domain (Stage 3)</li>
<li>✅ Authorization proven by compiler (Stage 4)</li>
<li>✅ Clean virtual UX for users (Stage 5)</li>
<li>✅ Ecosystem integration with safety (Stage 6)</li>
</ol>
<p><strong>All enforced at compile time with zero runtime overhead.</strong></p>
</blockquote>
<h2 id="feature-combinations"><a class="header" href="#feature-combinations">Feature Combinations</a></h2>
<p>Features can be combined as needed:</p>
<pre><code class="language-toml">[dependencies]
strict-path = { 
    version = "0.1.0-beta.2", 
    features = ["dirs", "serde", "tempfile", "app-path"] 
}
</code></pre>
<p>All combinations work seamlessly together - choose the features your application needs.</p>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>All optional features:</p>
<ul>
<li><strong>Maintain security</strong>: Never compromise path boundary enforcement</li>
<li><strong>Zero-cost when unused</strong>: Features add no overhead if not enabled</li>
<li><strong>Composable</strong>: Features work together seamlessly</li>
<li><strong>Platform-aware</strong>: Handle platform differences gracefully</li>
<li><strong>Standards-compliant</strong>: Follow established conventions and specifications</li>
</ul>
<h2 id="congratulations-"><a class="header" href="#congratulations-">Congratulations! 🎉</a></h2>
<p>You've completed the full tutorial! You now understand:</p>
<ul>
<li>✅ How <code>StrictPath</code> prevents path escapes</li>
<li>✅ How markers prevent domain mix-ups</li>
<li>✅ How <code>change_marker()</code> encodes authorization</li>
<li>✅ How <code>VirtualPath</code> provides user-friendly sandboxing</li>
<li>✅ How features integrate with the Rust ecosystem</li>
</ul>
<h2 id="whats-next-6"><a class="header" href="#whats-next-6">What's Next?</a></h2>
<p>Explore these resources to deepen your knowledge:</p>
<ul>
<li><strong><a href="tutorial/../examples/overview.html">Real-World Examples</a></strong> — Copy-pasteable patterns for web servers, CLI tools, archives</li>
<li><strong><a href="tutorial/../best_practices.html">Best Practices</a></strong> — Decision matrices, design patterns, and guidelines</li>
<li><strong><a href="tutorial/../anti_patterns.html">Anti-Patterns</a></strong> — Common mistakes and how to fix them</li>
<li><strong><a href="tutorial/../os_directories.html">OS Directories</a></strong> — Complete API reference for all OS directory constructors</li>
<li><strong><a href="tutorial/../axum_tutorial/overview.html">Axum Tutorial</a></strong> — Build a complete web service with strict-path</li>
</ul>
<p><strong>You're ready to build secure systems!</strong> 🚀</p>
<hr />
<p><strong>Quick Reference Card:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// OS directories
let config = PathBoundary::&lt;MyConfig&gt;::try_new_os_config("app")?;
let downloads = PathBoundary::&lt;Downloads&gt;::try_new_os_downloads()?;

// Temp directories
let temp = TempDir::new()?;
let work = PathBoundary::&lt;Work&gt;::try_new(temp.path())?;

// App paths (with env override)
let logs = PathBoundary::&lt;Logs&gt;::try_new_app_path("logs", None)?;

// Serde validation
#[serde(deserialize_with = "deserialize_with_boundary")]
log_file: StrictPath&lt;ConfigFiles&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong><a href="tutorial/./overview.html">← Back to Tutorial Overview</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system-guarantees-in-signatures"><a class="header" href="#type-system-guarantees-in-signatures">Type-System Guarantees in Signatures</a></h1>
<p>One of strict-path's most powerful features is its <strong>marker type system</strong> that lets you encode domain-specific path guarantees in function signatures. This makes incorrect path usage a compile-time error rather than a runtime vulnerability.</p>
<h2 id="what-are-markers"><a class="header" href="#what-are-markers">What Are Markers?</a></h2>
<p>A marker is a zero-cost type parameter that describes what a path contains or how it should be used. Markers have no runtime representation - they exist purely to help the type system prevent mistakes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Define markers for different content domains
struct PublicAssets;   // CSS, JS, images for website
struct UserUploads;    // Documents uploaded by users  
struct TempFiles;      // Temporary processing files
struct ConfigFiles;    // Application configuration

// Use markers to create domain-specific boundaries
let public_assets_dir: PathBoundary&lt;PublicAssets&gt; = PathBoundary::try_new("static")?;
let user_uploads_dir: PathBoundary&lt;UserUploads&gt; = PathBoundary::try_new("uploads")?;
let temp_files_dir: PathBoundary&lt;TempFiles&gt; = PathBoundary::try_new("temp")?;
let app_config_dir: PathBoundary&lt;ConfigFiles&gt; = PathBoundary::try_new("config")?;

// Join paths with their appropriate markers
let css_file: StrictPath&lt;PublicAssets&gt; = public_assets_dir.strict_join("style.css")?;
let user_doc: StrictPath&lt;UserUploads&gt; = user_uploads_dir.strict_join("report.pdf")?;
let temp_file: StrictPath&lt;TempFiles&gt; = temp_files_dir.strict_join("processing.tmp")?;
let app_config: StrictPath&lt;ConfigFiles&gt; = app_config_dir.strict_join("settings.json")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="why-markers-matter"><a class="header" href="#why-markers-matter">Why Markers Matter</a></h2>
<p>Without markers, it's easy to accidentally mix up different types of paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Without markers - dangerous mix-ups are possible
fn process_user_upload(file_path: &amp;StrictPath) -&gt; io::Result&lt;()&gt; {
    // Is this a user file? Config file? Temp file? 
    // No way to know from the type!
    file_path.read_to_string()
}

// With markers - impossible to mix up domains  
fn process_user_upload(user_file: &amp;StrictPath&lt;UserUploads&gt;) -&gt; io::Result&lt;String&gt; {
    // Clear: this function ONLY processes user uploads
    user_file.read_to_string() 
}

fn load_app_config(config_file: &amp;StrictPath&lt;ConfigFiles&gt;) -&gt; io::Result&lt;AppConfig&gt; {
    // Clear: this function ONLY loads config files
    let content = config_file.read_to_string()?;
    serde_json::from_str(&amp;content)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="compile-time-safety"><a class="header" href="#compile-time-safety">Compile-Time Safety</a></h2>
<p>With markers, the compiler prevents domain mix-ups:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user_doc: StrictPath&lt;UserUploads&gt; = user_uploads_dir.strict_join("report.pdf")?;
let app_config: StrictPath&lt;ConfigFiles&gt; = app_config_dir.strict_join("settings.json")?;

// ✅ These work - correct marker types
process_user_upload(&amp;user_doc)?;
load_app_config(&amp;app_config)?;

// ❌ These are compile errors - marker type mismatch!
// process_user_upload(&amp;app_config)?;  // Can't pass ConfigFiles to UserUploads function
// load_app_config(&amp;user_doc)?;        // Can't pass UserUploads to ConfigFiles function
<span class="boring">}</span></code></pre></pre>
<p><strong>The power</strong>: If your code compiles, you know you're not accidentally processing config files as user uploads, or serving user uploads as public assets!</p>
<h2 id="function-signature-patterns"><a class="header" href="#function-signature-patterns">Function Signature Patterns</a></h2>
<h3 id="pattern-1-accept-validated-paths"><a class="header" href="#pattern-1-accept-validated-paths">Pattern 1: Accept Validated Paths</a></h3>
<p>When the caller has already validated the path, accept the typed path directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serve_public_asset(asset: &amp;StrictPath&lt;PublicAssets&gt;) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    // Caller proved this is a public asset - we can serve it safely
    asset.read()
}

fn delete_user_file(user_file: &amp;StrictPath&lt;UserUploads&gt;) -&gt; io::Result&lt;()&gt; {
    // Caller proved this is a user upload - safe to delete
    user_file.remove_file()
}

fn backup_config(config_file: &amp;StrictPath&lt;ConfigFiles&gt;, backup_dir: &amp;StrictPath&lt;BackupStorage&gt;) -&gt; io::Result&lt;()&gt; {
    let content = config_file.read()?;
    let backup_name = format!("config-{}.json", chrono::Utc::now().format("%Y%m%d"));
    let backup_path = backup_dir.strict_join(&amp;backup_name)?;
    backup_path.write(content)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-validate-inside-helper"><a class="header" href="#pattern-2-validate-inside-helper">Pattern 2: Validate Inside Helper</a></h3>
<p>When the helper needs to validate user input, accept the boundary plus untrusted segment:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_user_upload(
    uploads_dir: &amp;PathBoundary&lt;UserUploads&gt;, 
    filename: &amp;str,  // untrusted input
    content: &amp;[u8]
) -&gt; io::Result&lt;()&gt; {
    // Validate the untrusted filename
    let user_file = uploads_dir.strict_join(filename)?;
    user_file.create_parent_dir_all()?;
    user_file.write(content)
}

fn load_config_by_name(
    config_dir: &amp;PathBoundary&lt;ConfigFiles&gt;, 
    config_name: &amp;str  // untrusted input
) -&gt; io::Result&lt;serde_json::Value&gt; {
    // Validate the untrusted config name
    let config_file = config_dir.strict_join(config_name)?; 
    let content = config_file.read_to_string()?;
    serde_json::from_str(&amp;content).map_err(Into::into)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-multiple-domain-access"><a class="header" href="#pattern-3-multiple-domain-access">Pattern 3: Multiple Domain Access</a></h3>
<p>Some functions need to work with multiple domains - use multiple parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_report(
    user_data: &amp;StrictPath&lt;UserUploads&gt;,
    template: &amp;StrictPath&lt;PublicAssets&gt;, 
    temp_reports_dir: &amp;PathBoundary&lt;TempFiles&gt;
) -&gt; io::Result&lt;StrictPath&lt;TempFiles&gt;&gt; {
    let data = user_data.read_to_string()?;
    let template_content = template.read_to_string()?;
    
    // Process data with template...
    let report = process_template(&amp;template_content, &amp;data);
    
    let report_file = temp_reports_dir.strict_join("report.html")?;
    report_file.write(report)?;
    Ok(report_file)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="marker-best-practices"><a class="header" href="#marker-best-practices">Marker Best Practices</a></h2>
<h3 id="use-descriptive-domain-names"><a class="header" href="#use-descriptive-domain-names">Use Descriptive Domain Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good - describes what the paths contain
struct UserHomes;
struct ProductImages; 
struct DatabaseBackups;
struct AuditLogs;

// ❌ Avoid - generic or implementation-focused names
struct Files;
struct Directory;
struct Database;
struct Secure;
<span class="boring">}</span></code></pre></pre>
<h3 id="create-markers-for-business-domains"><a class="header" href="#create-markers-for-business-domains">Create Markers for Business Domains</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good - matches your application's business logic
struct CustomerDocuments;
struct FinancialReports;
struct ProductCatalog; 
struct EmployeeRecords;
struct MarketingAssets;

// ❌ Avoid - technical implementation details as primary markers
struct JsonFiles;
struct ReadOnlyData;
struct EncryptedStorage;
<span class="boring">}</span></code></pre></pre>
<h3 id="use-meaningful-function-names"><a class="header" href="#use-meaningful-function-names">Use Meaningful Function Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good - function names explain business intent
fn archive_customer_document(doc: &amp;StrictPath&lt;CustomerDocuments&gt;) -&gt; io::Result&lt;()&gt; { ... }
fn publish_marketing_asset(asset: &amp;StrictPath&lt;MarketingAssets&gt;) -&gt; io::Result&lt;()&gt; { ... }
fn audit_financial_report(report: &amp;StrictPath&lt;FinancialReports&gt;) -&gt; io::Result&lt;()&gt; { ... }

// ❌ Avoid - generic names that don't explain purpose  
fn process_file(path: &amp;StrictPath&lt;SomeMarker&gt;) -&gt; io::Result&lt;()&gt; { ... }
fn handle_data(path: &amp;StrictPath&lt;SomeMarker&gt;) -&gt; io::Result&lt;()&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-marker-patterns"><a class="header" href="#advanced-marker-patterns">Advanced Marker Patterns</a></h2>
<h3 id="hierarchical-markers"><a class="header" href="#hierarchical-markers">Hierarchical Markers</a></h3>
<p>You can create marker hierarchies for more sophisticated type safety:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MediaFiles;
struct Images;
struct Videos;
struct Documents;

// Use PhantomData for hierarchical relationships
struct MediaFile&lt;T&gt;(std::marker::PhantomData&lt;T&gt;);

type ImageFile = MediaFile&lt;Images&gt;;
type VideoFile = MediaFile&lt;Videos&gt;;
type DocumentFile = MediaFile&lt;Documents&gt;;

fn process_image(img: &amp;StrictPath&lt;ImageFile&gt;) -&gt; io::Result&lt;()&gt; { ... }
fn process_video(vid: &amp;StrictPath&lt;VideoFile&gt;) -&gt; io::Result&lt;()&gt; { ... }
fn process_document(doc: &amp;StrictPath&lt;DocumentFile&gt;) -&gt; io::Result&lt;()&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<h3 id="environment-specific-markers"><a class="header" href="#environment-specific-markers">Environment-Specific Markers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Production;
struct Staging;  
struct Development;

struct ConfigFile&lt;Env&gt;(std::marker::PhantomData&lt;Env&gt;);

type ProdConfig = ConfigFile&lt;Production&gt;;
type StagingConfig = ConfigFile&lt;Staging&gt;;
type DevConfig = ConfigFile&lt;Development&gt;;

fn deploy_to_production(config: &amp;StrictPath&lt;ProdConfig&gt;) -&gt; io::Result&lt;()&gt; {
    // Only production configs can be deployed to production
    apply_production_config(config)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-serde"><a class="header" href="#integration-with-serde">Integration with Serde</a></h2>
<p>When deserializing paths from configuration, you still need runtime validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Deserialize;

#[derive(Deserialize)]
struct AppConfig {
    upload_directory: String,  // Raw path from config
    static_directory: String,  // Raw path from config
}

fn load_app_config() -&gt; Result&lt;(PathBoundary&lt;UserUploads&gt;, PathBoundary&lt;PublicAssets&gt;), ConfigError&gt; {
    let config: AppConfig = serde_json::from_str(&amp;config_json)?;
    
    // Validate raw config paths into typed boundaries
    let user_uploads_dir = PathBoundary::&lt;UserUploads&gt;::try_new_create(&amp;config.upload_directory)?;
    let public_assets_dir = PathBoundary::&lt;PublicAssets&gt;::try_new_create(&amp;config.static_directory)?;
    
    Ok((user_uploads_dir, public_assets_dir))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="zero-runtime-cost"><a class="header" href="#zero-runtime-cost">Zero Runtime Cost</a></h2>
<p>It's important to understand that markers are zero-cost abstractions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These have identical runtime performance
let generic_path: StrictPath = some_root.strict_join("file.txt")?;
let typed_path: StrictPath&lt;UserUploads&gt; = user_uploads_dir.strict_join("file.txt")?;

// The marker information is erased at compile time
assert_eq!(
    std::mem::size_of::&lt;StrictPath&gt;(), 
    std::mem::size_of::&lt;StrictPath&lt;UserUploads&gt;&gt;()
);
<span class="boring">}</span></code></pre></pre>
<p>All the type safety benefits come at compile time with no runtime overhead!</p>
<h2 id="strictpath-vs-virtualpath-symlink-semantics"><a class="header" href="#strictpath-vs-virtualpath-symlink-semantics">StrictPath vs VirtualPath: Symlink Semantics</a></h2>
<p>One critical difference between <code>StrictPath</code> and <code>VirtualPath</code> is how they handle symlinks:</p>
<h3 id="strictpath-system-filesystem-semantics"><a class="header" href="#strictpath-system-filesystem-semantics">StrictPath: System Filesystem Semantics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

// StrictPath follows symlinks and validates targets
let boundary = StrictPath::with_boundary_create("system_root")?;

// If "system_root/config_link" symlinks to "/etc/app.conf":
let config = boundary.strict_join("config_link");
// ❌ Error if target is outside boundary
// ✅ OK if target resolves to path inside boundary
<span class="boring">}</span></code></pre></pre>
<p><strong>Use for:</strong> Shared system resources, config files, traditional filesystem operations</p>
<h3 id="virtualpath-virtual-filesystem-semantics"><a class="header" href="#virtualpath-virtual-filesystem-semantics">VirtualPath: Virtual Filesystem Semantics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

// VirtualPath clamps absolute symlink targets to virtual root
let vroot = VirtualPath::with_root("user_sandbox")?;

// If "user_sandbox/config_link" symlinks to "/etc/app.conf":
let config = vroot.virtual_join("config_link")?;
// ✅ Always OK - target clamped to "user_sandbox/etc/app.conf"

println!("Virtual: {}", config.virtualpath_display());
// Output: /etc/app.conf (from user's perspective)

println!("System: {}", config.as_unvirtual().strictpath_display());  
// Output: user_sandbox/etc/app.conf (actually safe!)
<span class="boring">}</span></code></pre></pre>
<p><strong>Use for:</strong> Multi-tenant systems, archive extraction, sandboxed environments, container-like semantics</p>
<p><strong>Key Insight:</strong> In a virtual filesystem, absolute paths (whether from user input or symlink targets) are <em>always</em> relative to the virtual root. This makes <code>VirtualPath</code> perfect for untrusted inputs where you want graceful containment rather than explicit rejection.</p>
<h2 id="common-patterns-summary"><a class="header" href="#common-patterns-summary">Common Patterns Summary</a></h2>
<ol>
<li><strong>Validate once, use everywhere</strong>: Create typed paths at boundaries, pass typed paths to functions</li>
<li><strong>Encode intent in signatures</strong>: Function parameters should clearly show what domains they work with</li>
<li><strong>Separate validation from business logic</strong>: Keep path validation separate from file processing</li>
<li><strong>Use meaningful marker names</strong>: Markers should describe business domains, not technical implementation</li>
<li><strong>Fail at compile time</strong>: Structure your code so domain mix-ups become type errors</li>
<li><strong>Choose the right semantics</strong>: Use <code>StrictPath</code> for system operations (validation), <code>VirtualPath</code> for sandboxing (clamping)</li>
</ol>
<p>The type system becomes your ally in preventing path-related security bugs and logic errors!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-we-achieve-security"><a class="header" href="#how-we-achieve-security">How We Achieve Security</a></h1>
<p>This chapter provides a detailed look at the multi-layered security methodology behind <code>strict-path</code>. Rather than relying on simple string validation or ad-hoc checks, we've built a comprehensive defense-in-depth approach that addresses path security from the ground up.</p>
<h2 id="1-battle-tested-foundation-soft-canonicalize"><a class="header" href="#1-battle-tested-foundation-soft-canonicalize">1. Battle-Tested Foundation: <code>soft-canonicalize</code></a></h2>
<p>Our security starts with <code>soft-canonicalize</code>—a purpose-built path resolution library that has been validated against 19+ globally known path-related CVEs. These CVEs represent years of accumulated attack patterns and edge cases discovered across the software ecosystem.</p>
<p><strong>What it handles:</strong></p>
<ul>
<li><strong>Symlink cycles and complex link chains</strong>: Prevents infinite loops and traversal through symbolic links</li>
<li><strong>Path resolution consistency</strong>: Ensures paths are resolved consistently during validation, reducing some timing-related inconsistencies in path interpretation</li>
<li><strong>Platform-specific quirks</strong>: Windows 8.3 short names (<code>PROGRA~1</code>), UNC paths, NTFS Alternate Data Streams</li>
<li><strong>Encoding tricks</strong>: Unicode normalization attacks, case sensitivity issues, and filesystem encoding edge cases</li>
<li><strong>Canonicalization edge cases</strong>: Proper handling of <code>.</code>, <code>..</code>, multiple slashes, and malformed path components</li>
</ul>
<p><strong>Why this matters:</strong> Most directory traversal vulnerabilities stem from incomplete path resolution. By building on <code>soft-canonicalize</code>, we benefit from systematic validation against years of documented attack vectors that simple string validation would miss.</p>
<h3 id="11-validated-against-real-world-cves"><a class="header" href="#11-validated-against-real-world-cves">1.1 Validated Against Real-World CVEs</a></h3>
<p>Our security is not theoretical—it's validated against actual vulnerabilities discovered in production software. Here are specific CVEs that <code>strict-path</code> protects against:</p>
<h4 id="cve-2025-8088-winrar-ntfs-alternate-data-streams-ads-bypass"><a class="header" href="#cve-2025-8088-winrar-ntfs-alternate-data-streams-ads-bypass">CVE-2025-8088: WinRAR NTFS Alternate Data Streams (ADS) Bypass</a></h4>
<p><strong>Attack:</strong> Malicious archives containing paths with NTFS Alternate Data Streams (e.g., <code>file.txt:hidden:$DATA</code>) could bypass security checks and write to arbitrary locations.</p>
<p><strong>How strict-path protects:</strong></p>
<ul>
<li>Canonicalization resolves ADS references to their actual filesystem locations</li>
<li>Boundary validation checks the <strong>resolved</strong> path, not the syntactic path</li>
<li>Virtual paths clamp even crafted ADS targets to the boundary</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Attack attempt: ../../sensitive.doc:stream
let boundary = PathBoundary::try_new("archive_extract")?;
match boundary.strict_join("../../sensitive.doc:stream") {
    Ok(_) =&gt; unreachable!("Never succeeds"),
    Err(e) =&gt; println!("🛡️ ADS attack blocked: {e}"),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="cve-2022-21658-rust-cargo-toctou-time-of-check-time-of-use"><a class="header" href="#cve-2022-21658-rust-cargo-toctou-time-of-check-time-of-use">CVE-2022-21658: Rust Cargo TOCTOU (Time-of-Check-Time-of-Use)</a></h4>
<p><strong>Attack:</strong> Race condition where a path is validated, then a symlink is created before the path is used, allowing escape.</p>
<p><strong>How strict-path protects:</strong></p>
<ul>
<li>Canonicalization resolves symlinks <strong>at validation time</strong></li>
<li>The validated <code>StrictPath</code> carries the resolved target</li>
<li>No TOCTOU window between validation and use</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Validation and resolution happen atomically
let boundary = PathBoundary::try_new("workspace")?;
let safe_path = boundary.strict_join("config.toml")?; // Resolves symlinks NOW
safe_path.read_to_string()?; // Uses already-resolved path, no race
<span class="boring">}</span></code></pre></pre>
<h4 id="cve-2019-9855-libreoffice-windows-83-short-name-bypass"><a class="header" href="#cve-2019-9855-libreoffice-windows-83-short-name-bypass">CVE-2019-9855: LibreOffice Windows 8.3 Short Name Bypass</a></h4>
<p><strong>Attack:</strong> Windows 8.3 short names (e.g., <code>PROGRA~1</code> for <code>Program Files</code>) could bypass path validation that only checked long-form names.</p>
<p><strong>How strict-path protects:</strong></p>
<ul>
<li>Canonicalization automatically expands Windows 8.3 short names to their long forms</li>
<li>Boundary checking operates on the canonical form</li>
<li>Mathematical proof: canonical path within canonical boundary = secure</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Attack attempt using short name: ../PROGRA~1/system.dll
let boundary = PathBoundary::try_new("C:/Users/Alice/Documents")?;
match boundary.strict_join("../PROGRA~1/system.dll") {
    Ok(_) =&gt; unreachable!("Short name attack blocked"),
    Err(e) =&gt; println!("🛡️ 8.3 attack blocked: {e}"),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="cve-2018-1002200-zip-slip-archive-path-traversal"><a class="header" href="#cve-2018-1002200-zip-slip-archive-path-traversal">CVE-2018-1002200: Zip Slip (Archive Path Traversal)</a></h4>
<p><strong>Attack:</strong> Malicious archives containing entries with <code>../../</code> in filenames to write outside extraction directory.</p>
<p><strong>How strict-path protects:</strong></p>
<ul>
<li>Every archive entry path must pass through <code>strict_join()</code> validation</li>
<li>Traversal attempts return <code>Err(PathEscapesBoundary)</code></li>
<li>Extraction loop fails immediately on malicious entry</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Safe archive extraction
let extract_dir = PathBoundary::try_new_create("./extracted")?;

for entry in archive.entries()? {
    let entry_path = entry.path()?;
    match extract_dir.strict_join(&amp;entry_path) {
        Ok(safe_dest) =&gt; {
            safe_dest.create_parent_dir_all()?;
            entry.extract_to(safe_dest.interop_path())?;
        },
        Err(e) =&gt; {
            eprintln!("🚨 Malicious archive entry blocked: {}", entry_path.display());
            return Err(e.into());
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="additional-cves-validated-in-soft-canonicalize-test-suite"><a class="header" href="#additional-cves-validated-in-soft-canonicalize-test-suite">Additional CVEs Validated in soft-canonicalize Test Suite</a></h4>
<p>The underlying <code>soft-canonicalize</code> library has been validated against 15+ additional CVEs covering:</p>
<ul>
<li><strong>Unicode normalization attacks</strong> - CVE-2008-2938, CVE-2009-0689 (different representations of same path)</li>
<li><strong>Null byte injection</strong> - CVE-2006-1547 (path truncation attacks)</li>
<li><strong>Symlink directory bombs</strong> - CVE-2014-8086 (infinite symlink loops)</li>
<li><strong>UNC path bypasses</strong> - CVE-2010-0442 (Windows extended-length path tricks)</li>
<li><strong>Case sensitivity exploits</strong> - Various CVEs on case-insensitive filesystems</li>
<li><strong>Trailing dot/space bypasses</strong> - CVE-2007-2446 (Windows reserved name handling)</li>
<li><strong>Device namespace abuse</strong> - CVE-2009-2692 (Windows device names like CON, PRN)</li>
</ul>
<h3 id="12-coverage-what-we-protect-against"><a class="header" href="#12-coverage-what-we-protect-against">1.2 Coverage: What We Protect Against</a></h3>
<p><strong>✅ Comprehensive Protection (99% of attacks):</strong></p>
<ul>
<li><strong>Basic traversal</strong> - <code>../../../etc/passwd</code>, <code>..\..\Windows\System32</code></li>
<li><strong>Symlink escapes</strong> - Links pointing outside boundaries</li>
<li><strong>Archive attacks</strong> - Zip Slip, TAR traversal, malicious archive extraction</li>
<li><strong>Encoding bypasses</strong> - Unicode normalization, UTF-8 vs UTF-16, null bytes</li>
<li><strong>Windows-specific</strong> - 8.3 short names (<code>PROGRA~1</code>), UNC paths (<code>\\?\C:\</code>), NTFS streams (<code>:$DATA</code>)</li>
<li><strong>Race conditions</strong> - TOCTOU during path resolution</li>
<li><strong>Symlink cycles</strong> - Infinite loop protection with bounded depth tracking</li>
<li><strong>Platform quirks</strong> - Mixed separators, case sensitivity, trailing dots/spaces</li>
<li><strong>Path length limits</strong> - Windows MAX_PATH (260) handling</li>
</ul>
<p><strong>⚠️ Requires System-Level Privileges (1% edge cases):</strong></p>
<ul>
<li><strong>Hard links</strong> - Creating hard links to files outside boundary (requires admin/root)</li>
<li><strong>Mount points</strong> - Mounting new filesystems (requires admin/root)</li>
</ul>
<p><strong>Bottom Line:</strong>
<code>strict-path</code> stops <strong>99% of practical path traversal attacks</strong> without requiring elevated privileges. The 1% that require system-level access are mitigated by OS-level security (users can't create hard links or mount points without admin rights).</p>
<h3 id="13-continuous-security-validation"><a class="header" href="#13-continuous-security-validation">1.3 Continuous Security Validation</a></h3>
<p>Our security validation is ongoing:</p>
<ul>
<li><strong>Monitor</strong> new CVE disclosures for path-related vulnerabilities</li>
<li><strong>Reproduce</strong> attacks in our test suite to verify protection</li>
<li><strong>Adapt</strong> defenses as new attack patterns emerge</li>
<li><strong>Contribute</strong> findings to <code>soft-canonicalize</code> for ecosystem-wide benefit</li>
</ul>
<p><strong>Security is not a one-time achievement—it's a continuous process of adaptation and improvement.</strong></p>
<hr />
<h2 id="2-secure-api-design"><a class="header" href="#2-secure-api-design">2. Secure API Design</a></h2>
<p>Our API design is built around the principle that <strong>security should be the easiest path forward</strong>. Every design decision prioritizes preventing misuse over convenience.</p>
<h3 id="21-llm-agent-aware-design"><a class="header" href="#21-llm-agent-aware-design">2.1 LLM Agent-Aware Design</a></h3>
<p>Modern threats include AI agents processing untrusted paths from various sources. Our API is designed specifically for this threat model:</p>
<ul>
<li><strong>Clear validation points</strong>: <code>strict_join()</code> and <code>virtual_join()</code> make validation explicit and visible</li>
<li><strong>LLM-friendly documentation</strong>: Complete parameter documentation and usage examples specifically for AI consumption</li>
<li><strong>Fail-safe defaults</strong>: Operations fail closed rather than permitting potentially dangerous paths</li>
<li><strong>Explicit interop boundaries</strong>: <code>.interop_path()</code> makes filesystem handoffs to third-party code obvious</li>
</ul>
<h3 id="22-minimal-api-surface-for-minimal-error-margin"><a class="header" href="#22-minimal-api-surface-for-minimal-error-margin">2.2 Minimal API Surface for Minimal Error Margin</a></h3>
<p>We deliberately limit our public API surface to reduce the possibility of misuse:</p>
<ul>
<li><strong>No leaky trait implementations</strong>: No <code>AsRef&lt;Path&gt;</code>, <code>Deref&lt;Target = Path&gt;</code>, or implicit conversions that bypass validation</li>
<li><strong>Controlled constructors</strong>: Only specific, well-audited entry points for creating secure path types</li>
<li><strong>Helper API restrictions</strong>: New public functions require explicit maintainer approval to prevent API drift</li>
<li><strong>Dimension separation</strong>: Strict and virtual paths have separate, non-interchangeable operations</li>
</ul>
<h3 id="23-explicit-methods-that-make-logic-errors-visible"><a class="header" href="#23-explicit-methods-that-make-logic-errors-visible">2.3 Explicit Methods That Make Logic Errors Visible</a></h3>
<p>Our method names are designed to make security-relevant operations obvious during code review:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Unclear security implications
path.join(user_input)

// ✅ Security implications clear at a glance
boundary.strict_join(user_input)?
vroot.virtual_join(user_input)?
<span class="boring">}</span></code></pre></pre>
<p><strong>Key principles:</strong></p>
<ul>
<li><strong>Verbose over clever</strong>: <code>strict_join()</code> instead of <code>join()</code> makes the security operation explicit</li>
<li><strong>Dimension-specific operations</strong>: <code>strictpath_display()</code> vs <code>virtualpath_display()</code> prevent confusion</li>
<li><strong>No hidden validation</strong>: Every path that enters the system must go through an explicit validation step</li>
</ul>
<h3 id="24-rust-type-system-for-mathematical-correctness"><a class="header" href="#24-rust-type-system-for-mathematical-correctness">2.4 Rust Type System for Mathematical Correctness</a></h3>
<p>We leverage Rust's type system to provide <strong>compile-time guarantees</strong> about path security:</p>
<ul>
<li><strong>Marker types prevent confusion</strong>: <code>StrictPath&lt;UserUploads&gt;</code> vs <code>StrictPath&lt;SystemConfig&gt;</code> prevent accidentally mixing boundaries</li>
<li><strong>Borrowing prevents mutation</strong>: Once validated, paths cannot be secretly modified</li>
<li><strong>Ownership tracking</strong>: The type system ensures validated paths aren't leaked or corrupted</li>
<li><strong>Zero-cost abstractions</strong>: Security guarantees come at compile time, not runtime</li>
</ul>
<h3 id="25-distinct-types-for-hard-to-get-wrong-approach"><a class="header" href="#25-distinct-types-for-hard-to-get-wrong-approach">2.5 Distinct Types for "Hard to Get Wrong" Approach</a></h3>
<p>Different use cases get different types with appropriate guarantees:</p>
<ul>
<li><strong><code>PathBoundary&lt;Marker&gt;</code></strong>: For creating and managing restriction policies</li>
<li><strong><code>StrictPath&lt;Marker&gt;</code></strong>: For paths that must stay within boundaries (fails on violations)</li>
<li><strong><code>VirtualRoot&lt;Marker&gt;</code></strong>: For creating virtual filesystem views</li>
<li><strong><code>VirtualPath&lt;Marker&gt;</code></strong>: For virtual paths that clamp to safe boundaries</li>
<li><strong><code>StrictPathError</code></strong>: Comprehensive error handling for all failure modes</li>
<li><strong>Safe builtin I/O operations</strong>: Direct filesystem operations that bypass the need for <code>.interop_path()</code> calls</li>
</ul>
<h3 id="26-type-system-enforced-authorization"><a class="header" href="#26-type-system-enforced-authorization">2.6 Type System-Enforced Authorization</a></h3>
<p>The marker system enables compile-time authorization guarantees:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Authorization proof required to construct the marker
struct SecureDocuments;
impl SecureDocuments {
    fn new(auth_token: ValidatedAdminToken) -&gt; Self { Self }
}

// Type system ensures authorization happened
fn access_secure_file(path: &amp;StrictPath&lt;SecureDocuments&gt;) -&gt; Result&lt;String&gt; {
    path.read_to_string() // Compiler guarantees authorization
}
<span class="boring">}</span></code></pre></pre>
<h3 id="27-safe-builtin-io-operations"><a class="header" href="#27-safe-builtin-io-operations">2.7 Safe Builtin I/O Operations</a></h3>
<p>A critical security feature is our comprehensive suite of safe I/O operations that eliminate the need to escape to unsafe <code>std::fs</code> calls for routine work. The APIs mirror the semantics and return values of the standard library while preserving boundary guarantees.</p>
<p><strong>File operations:</strong></p>
<ul>
<li><code>read_to_string()</code>, <code>read()</code> — Read file contents</li>
<li><code>write&lt;C: AsRef&lt;[u8]&gt;&gt;()</code> — Write bytes (e.g., <code>&amp;str</code>, <code>&amp;[u8]</code>)</li>
<li><code>create_file()</code>, <code>open_file()</code> — Obtain file handles</li>
<li><code>remove_file()</code> — Delete files</li>
</ul>
<p><strong>Directory operations:</strong></p>
<ul>
<li><code>create_dir()</code>, <code>create_dir_all()</code> — Create directories</li>
<li><code>read_dir()</code> — Iterate directory entries (discover names; re-join through strict/virtual APIs)</li>
<li><code>metadata()</code> — Access filesystem metadata</li>
<li><code>remove_dir()</code>, <code>remove_dir_all()</code> — Delete directories</li>
</ul>
<p><strong>Move/Copy operations (dimension-specific):</strong></p>
<ul>
<li><code>StrictPath::strict_rename(..)</code> / <code>VirtualPath::virtual_rename(..)</code> — Rename/move within the restriction</li>
<li><code>StrictPath::strict_copy(..)</code> / <code>VirtualPath::virtual_copy(..)</code> — Copy within the restriction (returns bytes copied)</li>
</ul>
<p><strong>Links (creation):</strong></p>
<ul>
<li><code>StrictPath::strict_symlink(..)</code> / <code>VirtualPath::virtual_symlink(..)</code> — Create symlinks within the same restriction</li>
<li><code>StrictPath::strict_hard_link(..)</code> / <code>VirtualPath::virtual_hard_link(..)</code> — Create hard links (subject to platform constraints)</li>
</ul>
<p>Note: We intentionally do not expose separate helpers for "symlink metadata" or standalone canonicalization. When you must interoperate with APIs that require <code>AsRef&lt;Path&gt;</code> or specific OS semantics, use <code>.interop_path()</code> to get the validated path as <code>&amp;OsStr</code> and keep such calls isolated to interop boundaries.</p>
<p><strong>Why this matters:</strong> By providing safe alternatives to common <code>std::fs</code> operations, we eliminate the need for <code>.interop_path()</code> in routine file work, keeping the API surface focused on validated operations while still enabling necessary third‑party integrations.</p>
<h2 id="3-active-cve-research-and-validation"><a class="header" href="#3-active-cve-research-and-validation">3. Active CVE Research and Validation</a></h2>
<p>We maintain a systematic approach to understanding and defending against path-related vulnerabilities:</p>
<p><strong>Research activities:</strong></p>
<ul>
<li><strong>CVE database analysis</strong>: Study of documented path-related vulnerabilities across software ecosystems</li>
<li><strong>Security advisory analysis</strong>: Analysis of how attacks work and why existing solutions failed</li>
<li><strong>Historical attack validation</strong>: Testing our defenses against known attack patterns</li>
<li><strong>Comparative analysis</strong>: Study of similar libraries and their security approaches</li>
</ul>
<p><strong>Validation process:</strong></p>
<ul>
<li>Attack patterns are tested against our validation logic during development</li>
<li>Gaps identified in research inform security improvements</li>
<li>Security enhancements are implemented with careful consideration of compatibility</li>
<li>Relevant findings contribute to the broader security community understanding</li>
</ul>
<h2 id="4-open-source-transparency-for-rapid-issue-detection"><a class="header" href="#4-open-source-transparency-for-rapid-issue-detection">4. Open-Source Transparency for Rapid Issue Detection</a></h2>
<p>Security through obscurity is not security at all. Our open-source approach enables:</p>
<p><strong>Community validation:</strong></p>
<ul>
<li><strong>Expert review</strong>: Security researchers can audit our implementation</li>
<li><strong>Diverse testing</strong>: Community members test on platforms and use cases we haven't considered</li>
<li><strong>Collaborative bug reporting</strong>: Issues are tracked and addressed openly through GitHub</li>
<li><strong>Collaborative improvement</strong>: Security enhancements come from the community as well as maintainers</li>
</ul>
<p><strong>Transparency benefits:</strong></p>
<ul>
<li><strong>No hidden vulnerabilities</strong>: All code paths are visible for audit</li>
<li><strong>Public issue tracking</strong>: Security concerns are discussed openly</li>
<li><strong>Reproducible security</strong>: Anyone can verify our claims by reading the code</li>
<li><strong>Trust through verification</strong>: Don't trust our claims—verify them yourself</li>
</ul>
<h2 id="5-pseudo-projects-for-api-effectiveness-testing"><a class="header" href="#5-pseudo-projects-for-api-effectiveness-testing">5. Pseudo Projects for API Effectiveness Testing</a></h2>
<p>We maintain a suite of realistic demo projects that test our API in real-world scenarios:</p>
<p><strong>Demo categories:</strong></p>
<ul>
<li><strong>Web servers</strong>: File upload handlers, static asset serving, user content management</li>
<li><strong>CLI tools</strong>: File processors, archive extractors, configuration managers</li>
<li><strong>LLM agents</strong>: AI-driven file operations, automated code generation</li>
<li><strong>Archive handling</strong>: ZIP extraction, tar processing, backup restoration</li>
<li><strong>Configuration systems</strong>: Multi-environment config loading, user preference handling</li>
</ul>
<p><strong>Testing methodology:</strong></p>
<ul>
<li><strong>Production authenticity</strong>: Demos use real protocols and official ecosystem crates</li>
<li><strong>Security integration patterns</strong>: Each demo shows correct validation flow</li>
<li><strong>Failure mode testing</strong>: Demos include examples of rejected hostile inputs</li>
<li><strong>Performance validation</strong>: Real-world load testing of validation logic</li>
</ul>
<p><strong>Why this matters:</strong> APIs that work perfectly in isolation often fail when integrated into real systems. Our demos catch integration issues, performance problems, and usability gaps that unit tests miss.</p>
<h2 id="6-security-testing-and-validation"><a class="header" href="#6-security-testing-and-validation">6. Security Testing and Validation</a></h2>
<p>We employ comprehensive testing methodologies to validate our security approach:</p>
<h3 id="61-black-box-testing"><a class="header" href="#61-black-box-testing">6.1 Black-Box Testing</a></h3>
<p><strong>Automated fuzzing:</strong></p>
<ul>
<li>Random path generation across all Unicode ranges</li>
<li>Platform-specific attack vectors (Windows short names, Unix special files)</li>
<li>Encoding attack patterns (mixed encodings, normalization attacks)</li>
<li>Length-based attacks (extremely long paths, empty components)</li>
</ul>
<p><strong>LLM-assisted testing:</strong></p>
<ul>
<li><strong>AI-generated attack patterns</strong>: Using advanced LLMs to generate potential bypass attempts</li>
<li><strong>Reasoning model validation</strong>: Employing reasoning models to explore attack vectors</li>
<li><strong>Multi-model consensus</strong>: Cross-validating security assumptions across different AI models</li>
<li><strong>Systematic attack exploration</strong>: Multi-step validation approaches that build complexity</li>
</ul>
<h3 id="62-white-box-testing"><a class="header" href="#62-white-box-testing">6.2 White-Box Testing</a></h3>
<p><strong>Code analysis:</strong></p>
<ul>
<li><strong>Control flow analysis</strong>: Mapping all possible execution paths through validation logic</li>
<li><strong>State space exploration</strong>: Testing all combinations of internal validation states</li>
<li><strong>Boundary condition testing</strong>: Edge cases in canonicalization, length limits, character handling</li>
<li><strong>Race condition simulation</strong>: Concurrent access patterns and filesystem state changes</li>
</ul>
<p><strong>Architecture review:</strong></p>
<ul>
<li><strong>Trust boundary analysis</strong>: Verifying that security boundaries are correctly enforced</li>
<li><strong>Assumption validation</strong>: Testing that our security assumptions hold under all conditions</li>
<li><strong>Integration point review</strong>: Ensuring third-party integrations don't introduce vulnerabilities</li>
</ul>
<h3 id="63-security-validation-process"><a class="header" href="#63-security-validation-process">6.3 Security Validation Process</a></h3>
<p>Testing results inform our ongoing development:</p>
<ul>
<li><strong>Successful attacks</strong> become test cases and drive security improvements</li>
<li><strong>Failed attacks</strong> validate our defenses and expand our test coverage</li>
<li><strong>Novel attack vectors</strong> contribute to the security community's understanding</li>
<li><strong>Performance characteristics</strong> of attacks inform our optimization decisions</li>
</ul>
<h2 id="7-comprehensive-test-suite"><a class="header" href="#7-comprehensive-test-suite">7. Comprehensive Test Suite</a></h2>
<p>Our testing strategy covers multiple layers of validation:</p>
<h3 id="71-unit-testing"><a class="header" href="#71-unit-testing">7.1 Unit Testing</a></h3>
<p><strong>Core logic validation:</strong></p>
<ul>
<li>Every public function has comprehensive test coverage</li>
<li>Edge cases and boundary conditions are explicitly tested</li>
<li>Platform-specific behavior is validated on all supported systems</li>
<li>Error conditions are tested to ensure proper failure modes</li>
</ul>
<h3 id="72-integration-testing"><a class="header" href="#72-integration-testing">7.2 Integration Testing</a></h3>
<p><strong>Real-world scenario testing:</strong></p>
<ul>
<li>Full end-to-end flows from untrusted input to filesystem operations</li>
<li>Cross-platform compatibility validation</li>
<li>Third-party integration testing with common ecosystem crates</li>
<li>Performance testing under realistic load conditions</li>
</ul>
<h3 id="73-property-based-testing"><a class="header" href="#73-property-based-testing">7.3 Property-Based Testing</a></h3>
<p><strong>Automated verification:</strong></p>
<ul>
<li>QuickCheck-style property validation for core invariants</li>
<li>Fuzzing with structured inputs to explore edge cases</li>
<li>Shrinking of failing test cases to minimal reproduction examples</li>
<li>Statistical validation of security properties across large input spaces</li>
</ul>
<h3 id="74-security-focused-testing"><a class="header" href="#74-security-focused-testing">7.4 Security-Focused Testing</a></h3>
<p><strong>Attack simulation:</strong></p>
<ul>
<li>Known CVE reproduction tests to ensure we block historical attacks</li>
<li>Platform-specific security tests (Windows short names, Unix symlinks)</li>
<li>Encoding and normalization attack tests</li>
<li>Filesystem race condition simulations</li>
</ul>
<h3 id="75-continuous-testing"><a class="header" href="#75-continuous-testing">7.5 Continuous Testing</a></h3>
<p><strong>Automated validation:</strong></p>
<ul>
<li>CI/CD pipeline runs full test suite on every change</li>
<li>Multiple platform testing (Windows, Linux, macOS)</li>
<li>MSRV (Minimum Supported Rust Version) compatibility validation</li>
<li>Performance regression detection</li>
</ul>
<h2 id="security-is-a-process-not-a-product"><a class="header" href="#security-is-a-process-not-a-product">Security Is a Process, Not a Product</a></h2>
<p>Our security methodology recognizes that security is an ongoing commitment rather than a one-time achievement. We are committed to:</p>
<ul>
<li><strong>Monitor</strong> for new attack vectors and vulnerability patterns</li>
<li><strong>Adapt</strong> our defenses as the threat landscape evolves</li>
<li><strong>Learn</strong> from security incidents in the broader ecosystem</li>
<li><strong>Improve</strong> our methods based on real-world feedback and usage</li>
<li><strong>Contribute</strong> our knowledge to the security community</li>
</ul>
<p>The result is a library designed not only to address known path security issues but to evolve and adapt as new threats emerge. By building security into every layer—from the foundational libraries through the API design to the testing methodology—we provide comprehensive protection against the entire class of path traversal vulnerabilities.</p>
<p><strong>Remember:</strong> Path security isn't just about blocking <code>../../../etc/passwd</code>. It's about creating a robust defense against all the ways that untrusted paths can be crafted to bypass your security controls. That's what <code>strict-path</code> delivers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-by-mode"><a class="header" href="#examples-by-mode">Examples by Mode</a></h1>
<blockquote>
<p><strong>Quick visual guide: When to use StrictPath vs VirtualPath vs Path/PathBuf</strong></p>
</blockquote>
<p>This page provides quick, at-a-glance examples showing when to use each path type. For detailed guidance and decision matrices, see <strong><a href="./best_practices.html#security-philosophy-detect-vs-contain">Best Practices: Security Philosophy</a></strong>.</p>
<hr />
<h2 id="-virtualpath---user-sandboxes--multi-tenant-systems"><a class="header" href="#-virtualpath---user-sandboxes--multi-tenant-systems">🌐 VirtualPath - User Sandboxes &amp; Multi-Tenant Systems</a></h2>
<p><strong>Philosophy:</strong> "Let things try to escape, but silently contain them"</p>
<p><strong>Use when:</strong> Path escapes are <strong>expected but must be controlled</strong></p>
<h3 id="archive-extraction-safe-sandboxing"><a class="header" href="#archive-extraction-safe-sandboxing">Archive Extraction (Safe Sandboxing)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

// Extract ZIP files - hostile names get clamped, not rejected
let extract_root = VirtualPath::with_root_create("./extracted")?;

for entry_name in zip_entries {
    // "../../../etc/passwd" → "/etc/passwd" (safely clamped)
    let safe_path = extract_root.virtual_join(entry_name)?;
    safe_path.create_parent_dir_all()?;
    safe_path.write(entry.data())?; // Always safe within boundary
}
<span class="boring">}</span></code></pre></pre>
<h3 id="multi-tenant-cloud-storage"><a class="header" href="#multi-tenant-cloud-storage">Multi-Tenant Cloud Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

// Each user gets their own isolated filesystem view
let user_storage = VirtualPath::with_root_create(format!("storage/user_{user_id}"))?;

// User sees: "/documents/report.pdf"
// Actually stored: "./storage/user_42/documents/report.pdf"
let user_file = user_storage.virtual_join("documents/report.pdf")?;
user_file.write(uploaded_data)?;

// Show user-friendly paths
println!("Saved: {}", user_file.virtualpath_display()); // "/documents/report.pdf"
<span class="boring">}</span></code></pre></pre>
<p><strong>Key behavior:</strong></p>
<ul>
<li>✅ Escape attempts are <strong>silently clamped</strong> to stay within boundary</li>
<li>✅ Users see clean rooted paths (<code>/file.txt</code>) hiding real system structure</li>
<li>✅ Symlinks to absolute paths are <strong>clamped</strong> to virtual root</li>
<li>🎯 Perfect for: Multi-tenant systems, sandboxes, user isolation</li>
</ul>
<p><strong>Requires feature:</strong> <code>virtual-path</code> in <code>Cargo.toml</code></p>
<hr />
<h2 id="-strictpath---security-boundaries--system-resources"><a class="header" href="#-strictpath---security-boundaries--system-resources">⚔️ StrictPath - Security Boundaries &amp; System Resources</a></h2>
<p><strong>Philosophy:</strong> "If something tries to escape, I want to know about it"</p>
<p><strong>Use when:</strong> Path escapes indicate <strong>malicious intent</strong></p>
<h3 id="llm-agent-file-operations"><a class="header" href="#llm-agent-file-operations">LLM Agent File Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

// LLM generates file operations - validate everything
let workspace = PathBoundary::try_new_create("./agent_workspace")?;

let ai_request = llm.generate_filename(); // Could be ANYTHING
match workspace.strict_join(ai_request) {
    Ok(safe_path) =&gt; {
        safe_path.write(&amp;ai_content)?;
        println!("✅ Saved: {}", safe_path.strictpath_display());
    },
    Err(e) =&gt; {
        eprintln!("🚨 Attack blocked: {e}");
        // Log the attack, alert security team
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="file-upload-validation"><a class="header" href="#file-upload-validation">File Upload Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

struct UserUploads;

// Validate user-provided filenames
fn handle_upload(
    uploads_dir: &amp;PathBoundary&lt;UserUploads&gt;,
    filename: &amp;str,
    data: &amp;[u8]
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Reject malicious filenames like "../../../etc/passwd"
    let safe_file = uploads_dir.strict_join(filename)?; // Returns Err on escape
    safe_file.write(data)?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configuration-file-loading"><a class="header" href="#configuration-file-loading">Configuration File Loading</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

// Load config files - reject traversal attempts
let config_dir = PathBoundary::try_new("./config")?;

match config_dir.strict_join(user_selected_config) {
    Ok(config_file) =&gt; {
        let content = config_file.read_to_string()?;
        // Parse and use safely
    },
    Err(_) =&gt; {
        // User tried to load "../../../etc/passwd" - reject!
        return Err("Invalid config file path");
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key behavior:</strong></p>
<ul>
<li>✅ Escape attempts return <strong><code>Err(PathEscapesBoundary)</code></strong></li>
<li>✅ Application can detect attacks, log, alert, and reject</li>
<li>✅ Symlinks outside boundary return <strong>Error</strong></li>
<li>🎯 Perfect for: Archive extraction, file uploads, config loading, system resources</li>
</ul>
<p><strong>No feature required</strong> - always available</p>
<hr />
<h2 id="-pathpathbuf---controlledknown-paths"><a class="header" href="#-pathpathbuf---controlledknown-paths">🔓 Path/PathBuf - Controlled/Known Paths</a></h2>
<p><strong>Philosophy:</strong> "I created this path, I control it"</p>
<p><strong>Use when:</strong> You <strong>control the path source</strong> (hardcoded, generated by your code)</p>
<h3 id="application-generated-paths"><a class="header" href="#application-generated-paths">Application-Generated Paths</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::{Path, PathBuf};

// ✅ SAFE - You control the timestamp
let log_file = PathBuf::from(format!("logs/app-{timestamp}.log"));
std::fs::write(&amp;log_file, log_data)?;

// ✅ SAFE - Hardcoded path
let schema_file = Path::new("config/db-schema.sql");
let schema = std::fs::read_to_string(schema_file)?;

// ✅ SAFE - Environment variable from trusted source
let config_dir = std::env::var("APP_CONFIG_DIR")?;
let config = PathBuf::from(config_dir).join("settings.toml");
<span class="boring">}</span></code></pre></pre>
<h3 id="-never-with-external-input"><a class="header" href="#-never-with-external-input">❌ NEVER with External Input</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;

// 🚨 DISASTER - User input directly to Path
let user_file = Path::new(user_input); // user_input = "../../../etc/passwd"
std::fs::write(user_file, data)?; // System compromised!

// ✅ CORRECT - Validate first with StrictPath
let uploads = PathBoundary::try_new("uploads")?;
let safe_file = uploads.strict_join(user_input)?; // Attack rejected
safe_file.write(data)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Key behavior:</strong></p>
<ul>
<li>⚠️ <strong>No validation</strong> - trusts you completely</li>
<li>⚠️ Can escape anywhere on the filesystem</li>
<li>🎯 Perfect for: Hardcoded paths, app-generated filenames, trusted environment variables</li>
</ul>
<p><strong>Golden Rule:</strong> If you didn't create the path yourself, <strong>validate it first</strong> with StrictPath or VirtualPath!</p>
<hr />
<h2 id="-quick-comparison-table"><a class="header" href="#-quick-comparison-table">📊 Quick Comparison Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th><code>Path/PathBuf</code></th><th><code>StrictPath</code></th><th><code>VirtualPath</code></th></tr></thead><tbody>
<tr><td><strong>Security</strong></td><td>None 💥</td><td>Validates &amp; rejects ✅</td><td>Clamps any input ✅</td></tr>
<tr><td><strong>Escape attempts</strong></td><td><code>../../../etc</code> → <strong>System breach</strong></td><td><code>../../../etc</code> → <strong>Error</strong></td><td><code>../../../etc</code> → <strong><code>/etc</code></strong> (safely clamped)</td></tr>
<tr><td><strong>Symlink escapes</strong></td><td><code>link -&gt; /etc</code> → <strong>System breach</strong></td><td><code>link -&gt; /etc</code> → <strong>Error</strong></td><td><code>link -&gt; /etc</code> → <strong><code>/etc</code></strong> (clamped to boundary)</td></tr>
<tr><td><strong>Display</strong></td><td>System path</td><td>System path</td><td><strong>Virtual rooted path</strong> (<code>/file.txt</code>)</td></tr>
<tr><td><strong>Use case</strong></td><td>Known-safe, controlled paths</td><td>Security boundaries, detect attacks</td><td>Multi-tenant isolation, sandboxes</td></tr>
<tr><td><strong>Feature needed</strong></td><td>Always available</td><td>Always available</td><td>Requires <code>virtual-path</code> feature</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="-decision-flowchart"><a class="header" href="#-decision-flowchart">🎯 Decision Flowchart</a></h2>
<pre><code>Is the path from external/untrusted input?
│
├─ NO (hardcoded/app-generated) ──&gt; Path/PathBuf
│
└─ YES (user/config/LLM/archive) ──&gt; Validate first!
    │
    ├─ Need to DETECT escape attempts? ──&gt; StrictPath
    │   (file uploads, config, LLM agents)
    │
    └─ Need to CONTAIN escape attempts? ──&gt; VirtualPath
        (multi-tenant, sandboxes, user isolation)
</code></pre>
<hr />
<h2 id="-learn-more"><a class="header" href="#-learn-more">📚 Learn More</a></h2>
<ul>
<li><strong><a href="./best_practices.html#pick-the-right-type">Best Practices: Full Decision Matrix</a></strong> - 15+ scenarios with detailed guidance</li>
<li><strong><a href="./best_practices.html#security-philosophy-detect-vs-contain">Security Philosophy: Detect vs Contain</a></strong> - Deep dive into the fundamental distinction</li>
<li><strong><a href="./examples/overview.html">Real-World Examples</a></strong> - Complete, production-ready implementations</li>
<li><strong><a href="./tutorial/stage5_virtual_paths.html">Tutorial: Stage 5 - Virtual Paths</a></strong> - Understanding VirtualPath semantics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h1>
<p>This section shows practical, real-world scenarios where strict-path helps secure your applications. Each example includes complete, runnable code that you can adapt to your own projects.</p>
<h2 id="-example-categories"><a class="header" href="#-example-categories">📚 Example Categories</a></h2>
<h3 id="web-applications"><a class="header" href="#web-applications">Web Applications</a></h3>
<ul>
<li><strong><a href="examples/./web_upload_service.html">Web File Upload Service</a></strong> - Build a secure file upload service with per-user isolation</li>
<li><strong><a href="examples/./multi_user_storage.html">Multi-User Document Storage</a></strong> - Implement user sandboxing where each user feels they have their own filesystem</li>
</ul>
<h3 id="application-development"><a class="header" href="#application-development">Application Development</a></h3>
<ul>
<li><strong><a href="examples/./config_manager.html">Configuration File Manager</a></strong> - Safely handle user configuration files with automatic validation</li>
<li><strong><a href="examples/./cli_tool.html">CLI Tool with Safe Paths</a></strong> - Process user-provided file paths in command-line tools</li>
</ul>
<h3 id="security-critical-operations"><a class="header" href="#security-critical-operations">Security-Critical Operations</a></h3>
<ul>
<li><strong><a href="examples/./archive_extraction.html">Archive Extraction</a></strong> - Extract ZIP files safely without zip-slip vulnerabilities</li>
<li><strong><a href="examples/./type_safe_contexts.html">Type-Safe Context Separation</a></strong> - Use marker types to prevent mixing storage contexts at compile time</li>
</ul>
<h2 id="-common-patterns"><a class="header" href="#-common-patterns">🎯 Common Patterns</a></h2>
<p>All examples follow the same security pattern:</p>
<ol>
<li><strong>Create a boundary</strong> - Define your safe area with <code>PathBoundary</code> or <code>VirtualRoot</code></li>
<li><strong>Validate external input</strong> - Always use <code>strict_join()</code> or <code>virtual_join()</code> for untrusted paths</li>
<li><strong>Use safe types</strong> - Operate through <code>StrictPath</code> or <code>VirtualPath</code> for all file operations</li>
<li><strong>Let the compiler help</strong> - Type signatures encode security guarantees</li>
</ol>
<h2 id="-what-makes-these-secure"><a class="header" href="#-what-makes-these-secure">🔐 What Makes These Secure?</a></h2>
<ul>
<li><strong>No path escapes</strong> - Users can't use <code>../</code> or absolute paths to escape boundaries</li>
<li><strong>Compile-time safety</strong> - Wrong marker types won't compile</li>
<li><strong>Clear interfaces</strong> - Function signatures document what paths they accept</li>
<li><strong>Maintainable</strong> - Security isn't something to remember, it's in the type system</li>
</ul>
<h2 id="-using-these-examples"><a class="header" href="#-using-these-examples">💡 Using These Examples</a></h2>
<p>Each example is:</p>
<ul>
<li>✅ <strong>Complete</strong> - Includes all necessary imports and error handling</li>
<li>✅ <strong>Runnable</strong> - Copy-paste and adapt to your needs</li>
<li>✅ <strong>Explained</strong> - Comments highlight security patterns and key concepts</li>
<li>✅ <strong>Battle-tested</strong> - Shows real attack vectors that are automatically blocked</li>
</ul>
<p>Choose an example that matches your use case and start building secure applications!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-file-upload-service"><a class="header" href="#web-file-upload-service">Web File Upload Service</a></h1>
<p>Let's build a simple file upload service that allows users to upload files safely. This example demonstrates per-user isolation using <code>VirtualRoot</code>.</p>
<h2 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h2>
<p>Web applications need to accept file uploads from users, but must prevent:</p>
<ul>
<li>❌ Path traversal attacks (<code>../../../etc/passwd</code>)</li>
<li>❌ Users accessing other users' files</li>
<li>❌ Absolute path injections (<code>/var/www/html/shell.php</code>)</li>
</ul>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>Use <code>VirtualRoot</code> to create isolated storage for each user. Each user operates in their own sandboxed environment.</p>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{StrictPath, VirtualPath, VirtualRoot};
use std::io;

struct FileUploadService;

impl FileUploadService {
    // Multi-user: each user operates under their own VirtualRoot
    fn upload_file(
        &amp;self,
        user_uploads_root: &amp;VirtualRoot,
        upload_file_name: &amp;str,
        upload_file_content: &amp;[u8],
    ) -&gt; Result&lt;VirtualPath, Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate the untrusted filename at the user's virtual root
        let uploaded_file: VirtualPath = user_uploads_root.virtual_join(upload_file_name)?;
        // Reuse strict-typed helper when needed
        self.save_uploaded(uploaded_file.as_unvirtual(), upload_file_content)?;
        println!("✅ File uploaded safely to: {}", uploaded_file.virtualpath_display());
        Ok(uploaded_file)
    }

    // Internal helper: signature encodes guarantee (accepts only &amp;StrictPath)
    fn save_uploaded(&amp;self, file: &amp;StrictPath, content: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
        file.create_parent_dir_all()?;
        file.write(content)
    }

    fn list_files(
        &amp;self,
        user_uploads_root: &amp;VirtualRoot,
    ) -&gt; Result&lt;Vec&lt;VirtualPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut files = Vec::new();
        for entry in user_uploads_root.read_dir()? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                let file: VirtualPath = user_uploads_root.virtual_join(entry.file_name())?;
                files.push(file);
            }
        }
        Ok(files)
    }

    fn download_file(&amp;self, file: &amp;VirtualPath) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
        // Read and return the file content — type ensures safety
        file.read()
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let service = FileUploadService;

    // Per-user virtual roots
    let alice_uploads_root: VirtualRoot = VirtualRoot::try_new_create("user_uploads/alice")?;
    let bob_uploads_root: VirtualRoot = VirtualRoot::try_new_create("user_uploads/bob")?;

    // Simulate user uploads - these are all SAFE and isolated
    service.upload_file(&amp;alice_uploads_root, "document.txt", b"Hello, world!")?;
    service.upload_file(&amp;alice_uploads_root, "reports/january.pdf", b"PDF content here")?;
    service.upload_file(&amp;bob_uploads_root, "images/photo.jpg", b"JPEG data")?;

    // These would be clamped/blocked by validation:
    // service.upload_file(&amp;alice_uploads_root, "../../../etc/passwd", b"attack")?;  // ❌ Blocked!
    // service.upload_file(&amp;alice_uploads_root, "..\\windows\\system32\\evil.exe", b"malware")?;  // ❌ Blocked!

    // List Alice's uploaded files (virtual paths)
    println!("📁 Alice's files:");
    for file in service.list_files(&amp;alice_uploads_root)? {
        println!("  - {}", file.virtualpath_display());
    }

    // Download a file using VirtualPath
    let document_file = alice_uploads_root.virtual_join("document.txt")?;
    let content = service.download_file(&amp;document_file)?;
    println!("📄 Downloaded: {}", String::from_utf8_lossy(&amp;content));

    Ok(())
}</code></pre></pre>
<h2 id="key-security-features"><a class="header" href="#key-security-features">Key Security Features</a></h2>
<h3 id="1-per-user-isolation"><a class="header" href="#1-per-user-isolation">1. Per-User Isolation</a></h3>
<p>Each user gets their own <code>VirtualRoot</code>. Alice can't access Bob's files and vice versa.</p>
<h3 id="2-automatic-path-validation"><a class="header" href="#2-automatic-path-validation">2. Automatic Path Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uploaded_file = user_uploads_root.virtual_join(upload_file_name)?;
<span class="boring">}</span></code></pre></pre>
<p>This validates the filename and ensures it stays within the user's boundary. Attacks are automatically blocked.</p>
<h3 id="3-type-safe-helpers"><a class="header" href="#3-type-safe-helpers">3. Type-Safe Helpers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_uploaded(&amp;self, file: &amp;StrictPath, content: &amp;[u8]) -&gt; io::Result&lt;()&gt;
<span class="boring">}</span></code></pre></pre>
<p>By accepting <code>&amp;StrictPath</code>, the function signature guarantees the path has been validated.</p>
<h3 id="4-virtual-path-display"><a class="header" href="#4-virtual-path-display">4. Virtual Path Display</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>uploaded_file.virtualpath_display()  // Shows "/document.txt" to the user
uploaded_file.strictpath_display()   // Shows "user_uploads/alice/document.txt" (system path)
<span class="boring">}</span></code></pre></pre>
<p>Users see clean paths starting from <code>/</code>, while the system knows the real location.</p>
<h2 id="attack-scenarios-prevented"><a class="header" href="#attack-scenarios-prevented">Attack Scenarios Prevented</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attack</th><th>Result</th></tr></thead><tbody>
<tr><td><code>../../../etc/passwd</code></td><td>❌ Clamped to user's root</td></tr>
<tr><td><code>..\\windows\\system32\\evil.exe</code></td><td>❌ Clamped to user's root</td></tr>
<tr><td><code>/var/www/html/shell.php</code></td><td>❌ Treated as relative, stays in boundary</td></tr>
<tr><td><code>alice/../bob/secret.txt</code></td><td>❌ Normalized and clamped</td></tr>
</tbody></table>
</div>
<h2 id="sharing-common-logic"><a class="header" href="#sharing-common-logic">Sharing Common Logic</a></h2>
<p>If you need to share logic between strict and virtual paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, VirtualPath, VirtualRoot};
use std::io;

// One helper that works with any marker
fn process_common&lt;M&gt;(file: &amp;StrictPath&lt;M&gt;) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    file.read()
}

// Prepare one strict file and one virtual file
let public_assets_root = PathBoundary::try_new("./assets")?;
let css_file: StrictPath = public_assets_root.strict_join("style.css")?;

let alice_uploads_root = VirtualRoot::try_new("./uploads/alice")?;
let avatar_file: VirtualPath = alice_uploads_root.virtual_join("avatar.jpg")?;

// Call with either type
let _ = process_common(&amp;css_file)?;                   // StrictPath
let _ = process_common(avatar_file.as_unvirtual())?; // Borrow strict view from VirtualPath
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-tips"><a class="header" href="#integration-tips">Integration Tips</a></h2>
<h3 id="with-web-frameworks"><a class="header" href="#with-web-frameworks">With Web Frameworks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example with axum/actix-web
async fn upload_handler(
    user_id: String,
    filename: String,
    content: Vec&lt;u8&gt;,
) -&gt; Result&lt;String, AppError&gt; {
    let user_root = get_user_root(&amp;user_id)?;
    let file = user_root.virtual_join(&amp;filename)?;
    file.write(&amp;content)?;
    Ok(file.virtualpath_display().to_string())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-async-runtimes"><a class="header" href="#with-async-runtimes">With Async Runtimes</a></h3>
<p>All file operations work with <code>tokio::fs</code> or <code>async-std</code> - just use <code>.interop_path()</code> when needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tokio::fs::write(file.interop_path(), content).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><strong>For Axum users</strong>: See the <a href="examples/../axum_tutorial/overview.html">Axum Web Service Tutorial</a> for a complete 3-chapter guide with project setup, static assets, and per-user storage</li>
<li>See <a href="examples/./multi_user_storage.html">Multi-User Document Storage</a> for a more complex user isolation example</li>
<li>See <a href="examples/./type_safe_contexts.html">Type-Safe Context Separation</a> to learn about using markers to prevent context mixing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-file-manager"><a class="header" href="#configuration-file-manager">Configuration File Manager</a></h1>
<p>Learn how to safely handle user configuration files with automatic path validation and type-safe file operations.</p>
<h2 id="the-problem-3"><a class="header" href="#the-problem-3">The Problem</a></h2>
<p>Applications need to load and save configuration files, but must prevent:</p>
<ul>
<li>❌ Users reading system configuration files (<code>../../../etc/shadow</code>)</li>
<li>❌ Writing config files outside the app's config directory</li>
<li>❌ Accidental path injections from corrupted config data</li>
</ul>
<h2 id="the-solution-1"><a class="header" href="#the-solution-1">The Solution</a></h2>
<p>Use <code>PathBoundary</code> to create a jail for configuration files. All config operations stay within the boundary.</p>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
struct AppConfig {
    theme: String,
    language: String,
    auto_save: bool,
}

impl Default for AppConfig {
    fn default() -&gt; Self {
        Self {
            theme: "dark".to_string(),
            language: "en".to_string(),
            auto_save: true,
        }
    }
}

struct ConfigManager {
    config_dir: PathBoundary,
}

impl ConfigManager {
    fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Create a jail for configuration files
        let config_dir = PathBoundary::try_new_create("app_config")?;
        Ok(Self { config_dir })
    }
    
    fn load_config(&amp;self, config_name: &amp;str) -&gt; Result&lt;AppConfig, Box&lt;dyn std::error::Error&gt;&gt; {
        // Ensure the config file name is safe
        let config_path = self.config_dir.strict_join(config_name)?;
        
        // Load config or create default
        if config_path.exists() {
            let content = config_path.read_to_string()?;
            let config: AppConfig = serde_json::from_str(&amp;content)?;
            println!("📖 Loaded config from: {}", config_path.strictpath_display());
            Ok(config)
        } else {
            println!("🆕 Creating default config at: {}", config_path.strictpath_display());
            let default_config = AppConfig::default();
            self.save_config(config_name, &amp;default_config)?;
            Ok(default_config)
        }
    }
    
    fn save_config(&amp;self, config_name: &amp;str, config: &amp;AppConfig) -&gt; Result&lt;StrictPath, Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate the config file path
        let config_path = self.config_dir.strict_join(config_name)?;
        
        // Serialize and save
        let content = serde_json::to_string_pretty(config)?;
        config_path.write(&amp;content)?;

        println!("💾 Saved config to: {}", config_path.strictpath_display());
        Ok(config_path)
    }
    
    fn list_configs(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut configs = Vec::new();
        
        for entry in self.config_dir.read_dir()? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                if let Some(name) = entry.file_name().to_str() {
                    if name.ends_with(".json") {
                        configs.push(name.to_string());
                    }
                }
            }
        }
        
        Ok(configs)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let config_manager = ConfigManager::new()?;
    
    // Load or create user config
    let mut user_config = config_manager.load_config("user.json")?;
    println!("Current config: {:#?}", user_config);
    
    // Modify and save
    user_config.theme = "light".to_string();
    user_config.auto_save = false;
    config_manager.save_config("user.json", &amp;user_config)?;
    
    // Create a different profile
    let admin_config = AppConfig {
        theme: "admin".to_string(),
        language: "en".to_string(),
        auto_save: true,
    };
    config_manager.save_config("admin.json", &amp;admin_config)?;
    
    // List all configs
    println!("📋 Available configs: {:?}", config_manager.list_configs()?);
    
    // These attempts would be blocked:
    // config_manager.load_config("../../../etc/passwd")?;  // ❌ Blocked!
    // config_manager.save_config("..\\windows\\evil.json", &amp;user_config)?;  // ❌ Blocked!
    
    Ok(())
}</code></pre></pre>
<h2 id="key-security-features-1"><a class="header" href="#key-security-features-1">Key Security Features</a></h2>
<h3 id="1-bounded-configuration-directory"><a class="header" href="#1-bounded-configuration-directory">1. Bounded Configuration Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_dir = PathBoundary::try_new_create("app_config")?;
<span class="boring">}</span></code></pre></pre>
<p>All configuration operations are restricted to this directory.</p>
<h3 id="2-validated-file-names"><a class="header" href="#2-validated-file-names">2. Validated File Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_path = self.config_dir.strict_join(config_name)?;
<span class="boring">}</span></code></pre></pre>
<p>User-provided config names are validated before any file operation.</p>
<h3 id="3-safe-returns"><a class="header" href="#3-safe-returns">3. Safe Returns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_config(&amp;self, config_name: &amp;str, config: &amp;AppConfig) -&gt; Result&lt;StrictPath, ...&gt;
<span class="boring">}</span></code></pre></pre>
<p>Returning <code>StrictPath</code> ensures callers can only operate on validated paths.</p>
<h3 id="4-automatic-parent-directory-creation"><a class="header" href="#4-automatic-parent-directory-creation">4. Automatic Parent Directory Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>config_path.write(&amp;content)?;
<span class="boring">}</span></code></pre></pre>
<p>The safe file operations handle parent directory creation automatically.</p>
<h2 id="attack-scenarios-prevented-1"><a class="header" href="#attack-scenarios-prevented-1">Attack Scenarios Prevented</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attack</th><th>Result</th></tr></thead><tbody>
<tr><td><code>load_config("../../../etc/passwd")</code></td><td>❌ Path escape blocked</td></tr>
<tr><td><code>save_config("/tmp/evil.json", ...)</code></td><td>❌ Absolute path blocked</td></tr>
<tr><td><code>load_config("..\\windows\\system.ini")</code></td><td>❌ Path escape blocked</td></tr>
</tbody></table>
</div>
<h2 id="integration-with-serde-1"><a class="header" href="#integration-with-serde-1">Integration with Serde</a></h2>
<p>For more complex deserialization scenarios, use the <code>serde</code> feature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, serde_ext::WithBoundary};
use serde::Deserialize;

#[derive(Deserialize)]
struct AppConfig {
    name: String,
    
    // Deserialize with validation through boundary
    #[serde(deserialize_with = "deserialize_config_file")]
    config_file: StrictPath&lt;ConfigFiles&gt;,
}

fn deserialize_config_file&lt;'de, D&gt;(deserializer: D) -&gt; Result&lt;StrictPath&lt;ConfigFiles&gt;, D::Error&gt;
where
    D: serde::Deserializer&lt;'de&gt;,
{
    let boundary = PathBoundary::&lt;ConfigFiles&gt;::try_new("config")?;
    let path_str = String::deserialize(deserializer)?;
    boundary.strict_join(&amp;path_str).map_err(serde::de::Error::custom)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="os-specific-config-locations"><a class="header" href="#os-specific-config-locations">OS-Specific Config Locations</a></h2>
<p>For platform-specific config directories, use the <code>dirs</code> feature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn new_with_os_config() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
    // Uses XDG on Linux, AppData on Windows, etc.
    let config_dir = PathBoundary::try_new_os_config("myapp")?;
    Ok(Self { config_dir })
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="examples/../os_directories.html">OS Standard Directories</a> chapter for more details.</p>
<h2 id="environment-variable-overrides-1"><a class="header" href="#environment-variable-overrides-1">Environment Variable Overrides</a></h2>
<p>For deployment flexibility, use the <code>app-path</code> feature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn new_with_override() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
    // Checks MYAPP_CONFIG_DIR env var first, falls back to default
    let config_dir = PathBoundary::try_new_app_path("config", Some("MYAPP_CONFIG_DIR"))?;
    Ok(Self { config_dir })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Store the boundary</strong> - Keep <code>PathBoundary</code> as a field in your manager struct</li>
<li><strong>Validate early</strong> - Use <code>strict_join()</code> immediately when receiving config names</li>
<li><strong>Return safe types</strong> - Functions should return <code>StrictPath</code> instead of raw strings</li>
<li><strong>Handle missing configs</strong> - Provide sensible defaults when configs don't exist</li>
</ol>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li>See <a href="examples/./cli_tool.html">CLI Tool</a> for handling user-provided paths in command-line applications</li>
<li>See <a href="examples/./type_safe_contexts.html">Type-Safe Context Separation</a> to learn about using markers for different config types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-user-document-storage"><a class="header" href="#multi-user-document-storage">Multi-User Document Storage</a></h1>
<p>Build a document storage system where each user feels like they have their own filesystem, complete with directory traversal prevention and user isolation.</p>
<h2 id="the-problem-4"><a class="header" href="#the-problem-4">The Problem</a></h2>
<p>Multi-user applications need to provide isolated storage where:</p>
<ul>
<li>❌ Users can't access other users' files</li>
<li>❌ Path traversal attacks don't work</li>
<li>❌ Users see clean paths (like <code>/reports/january.pdf</code>) instead of system paths</li>
</ul>
<h2 id="the-solution-2"><a class="header" href="#the-solution-2">The Solution</a></h2>
<p>Use <code>VirtualRoot</code> per user. Each user operates in their own sandboxed environment with clean virtual paths.</p>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{VirtualRoot, VirtualPath};
use std::fs;
use std::collections::HashMap;

struct DocumentStore {
    user_roots: HashMap&lt;String, VirtualRoot&gt;,
}

impl DocumentStore {
    fn new() -&gt; Self {
        Self {
            user_roots: HashMap::new(),
        }
    }
    
    fn get_user_root(&amp;mut self, username: &amp;str) -&gt; Result&lt;&amp;VirtualRoot, Box&lt;dyn std::error::Error&gt;&gt; {
        if !self.user_roots.contains_key(username) {
            // Each user gets their own isolated storage
            let user_dir = format!("user_data_{}", username);
            let vroot = VirtualRoot::try_new_create(&amp;user_dir)?;
            self.user_roots.insert(username.to_string(), vroot);
            println!("🏠 Created virtual root for user: {}", username);
        }
        
        Ok(self.user_roots.get(username).unwrap())
    }
    
    fn save_document(&amp;mut self, username: &amp;str, virtual_path: &amp;str, content: &amp;str) -&gt; Result&lt;VirtualPath, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.get_user_root(username)?;
        
        // User thinks they're saving to their own filesystem starting from "/"
        let doc_path = user_root.virtual_join(virtual_path)?;
        
        // Create parent directories and save
        doc_path.create_parent_dir_all()?;
        doc_path.write(content)?;
        
        println!("📝 User {username} saved document to: {}", doc_path.virtualpath_display());
        println!("    (Actually stored at: {})", doc_path.as_unvirtual().strictpath_display());
        
        Ok(doc_path)
    }
    
    fn load_document(&amp;mut self, username: &amp;str, virtual_path: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.get_user_root(username)?;
        let doc_path = user_root.virtual_join(virtual_path)?;
        
        let content = doc_path.read_to_string()?;
        println!("📖 User {} loaded document from: {}", username, virtual_path);
        
        Ok(content)
    }
    
    fn list_user_documents(&amp;mut self, username: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.get_user_root(username)?;
        let mut docs = Vec::new();
        
        fn collect_files(dir: impl AsRef&lt;std::path::Path&gt;, base: impl AsRef&lt;std::path::Path&gt;, docs: &amp;mut Vec&lt;String&gt;) -&gt; std::io::Result&lt;()&gt; {
            let dir = dir.as_ref();
            let base = base.as_ref();
            for entry in fs::read_dir(dir)? {
                let entry = entry?;
                let path = entry.path();
                
                if path.is_file() {
                    if let Ok(relative) = path.strip_prefix(base) {
                        if let Some(path_str) = relative.to_str() {
                            docs.push(format!("/{}", path_str.replace("\\", "/")));
                        }
                    }
                } else if path.is_dir() {
                    collect_files(&amp;path, base, docs)?;
                }
            }
            Ok(())
        }
        
        collect_files(user_root.interop_path(), user_root.interop_path(), &amp;mut docs)?;
        Ok(docs)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut store = DocumentStore::new();
    
    // Alice saves some documents
    store.save_document("alice", "/reports/quarterly.txt", "Q1 revenue was strong")?;
    store.save_document("alice", "/notes/meeting.md", "# Meeting Notes\n- Discuss new features")?;
    store.save_document("alice", "/drafts/proposal.doc", "Project proposal draft")?;
    
    // Bob saves his documents (completely separate from Alice)
    store.save_document("bob", "/code/main.rs", "fn main() { println!(\"Hello!\"); }")?;
    store.save_document("bob", "/docs/readme.txt", "My awesome project")?;
    
    // Charlie tries to access Alice's files - this is blocked at the path level
    // store.save_document("charlie", "/../alice/reports/quarterly.txt", "hacked")?;  // ❌ Blocked!
    
    // Each user can access their own files
    println!("📄 Alice's quarterly report: {}", store.load_document("alice", "/reports/quarterly.txt")?);
    println!("💻 Bob's code: {}", store.load_document("bob", "/code/main.rs")?);
    
    // List each user's documents
    println!("📁 Alice's documents: {:?}", store.list_user_documents("alice")?);
    println!("📁 Bob's documents: {:?}", store.list_user_documents("bob")?);
    
    Ok(())
}</code></pre></pre>
<h2 id="key-security-features-2"><a class="header" href="#key-security-features-2">Key Security Features</a></h2>
<h3 id="1-lazy-user-root-creation"><a class="header" href="#1-lazy-user-root-creation">1. Lazy User Root Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_user_root(&amp;mut self, username: &amp;str) -&gt; Result&lt;&amp;VirtualRoot, ...&gt;
<span class="boring">}</span></code></pre></pre>
<p>Each user gets their own <code>VirtualRoot</code> created on first access. Users are completely isolated from each other.</p>
<h3 id="2-virtual-path-display"><a class="header" href="#2-virtual-path-display">2. Virtual Path Display</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>doc_path.virtualpath_display()    // Shows: "/reports/quarterly.txt"
doc_path.strictpath_display()     // Shows: "user_data_alice/reports/quarterly.txt"
<span class="boring">}</span></code></pre></pre>
<p>Users see clean paths starting from <code>/</code>, while the system maintains real paths.</p>
<h3 id="3-automatic-isolation"><a class="header" href="#3-automatic-isolation">3. Automatic Isolation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>store.save_document("charlie", "/../alice/reports/quarterly.txt", "hacked")?;
<span class="boring">}</span></code></pre></pre>
<p>This is automatically blocked because <code>/../alice/...</code> gets clamped to Charlie's root.</p>
<h3 id="4-cross-user-access-prevention"><a class="header" href="#4-cross-user-access-prevention">4. Cross-User Access Prevention</a></h3>
<p>Even if you try:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let alice_root = store.get_user_root("alice")?;
let bob_root = store.get_user_root("bob")?;

// These are completely separate - no way to cross boundaries
let alice_doc = alice_root.virtual_join("/secret.txt")?;
let bob_doc = bob_root.virtual_join("/secret.txt")?;

// alice_doc and bob_doc point to different physical files
<span class="boring">}</span></code></pre></pre>
<h2 id="attack-scenarios-prevented-2"><a class="header" href="#attack-scenarios-prevented-2">Attack Scenarios Prevented</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attack</th><th>Result</th></tr></thead><tbody>
<tr><td><code>save_document("alice", "/../bob/data.txt", ...)</code></td><td>❌ Clamped to alice's root</td></tr>
<tr><td><code>save_document("alice", "/../../etc/passwd", ...)</code></td><td>❌ Clamped to alice's root</td></tr>
<tr><td><code>load_document("bob", "/../alice/secret.txt")</code></td><td>❌ Clamped to bob's root</td></tr>
<tr><td>Symlink to another user's directory</td><td>❌ Resolved within boundary</td></tr>
</tbody></table>
</div>
<h2 id="system-path-vs-virtual-path"><a class="header" href="#system-path-vs-virtual-path">System Path vs Virtual Path</a></h2>
<p>Understanding the difference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let alice_root = VirtualRoot::try_new_create("user_data_alice")?;
let doc = alice_root.virtual_join("/reports/january.pdf")?;

// What the user sees:
println!("{}", doc.virtualpath_display());
// Output: /reports/january.pdf

// What the system uses:
println!("{}", doc.as_unvirtual().strictpath_display());
// Output: user_data_alice/reports/january.pdf

// Both point to the same file, just different representations
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-tips-1"><a class="header" href="#integration-tips-1">Integration Tips</a></h2>
<h3 id="with-databases"><a class="header" href="#with-databases">With Databases</a></h3>
<p>Store virtual paths in the database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Document {
    id: i64,
    user_id: i64,
    virtual_path: String,  // "/reports/january.pdf"
    created_at: DateTime,
}

// When retrieving:
let user_root = get_user_root(user_id)?;
let doc_path = user_root.virtual_join(&amp;doc.virtual_path)?;
let content = doc_path.read()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="with-web-frameworks-1"><a class="header" href="#with-web-frameworks-1">With Web Frameworks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn get_document(
    user_id: String,
    path: String,
) -&gt; Result&lt;Vec&lt;u8&gt;, AppError&gt; {
    let user_root = get_user_root(&amp;user_id)?;
    let doc = user_root.virtual_join(&amp;path)?;
    Ok(doc.read()?)
}

async fn save_document(
    user_id: String,
    path: String,
    content: Vec&lt;u8&gt;,
) -&gt; Result&lt;String, AppError&gt; {
    let user_root = get_user_root(&amp;user_id)?;
    let doc = user_root.virtual_join(&amp;path)?;
    doc.create_parent_dir_all()?;
    doc.write(&amp;content)?;
    Ok(doc.virtualpath_display().to_string())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-shared-helpers"><a class="header" href="#with-shared-helpers">With Shared Helpers</a></h3>
<p>Share logic between users by accepting <code>&amp;StrictPath</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn analyze_document&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; Result&lt;DocumentStats, Error&gt; {
    let content = path.read_to_string()?;
    Ok(DocumentStats {
        lines: content.lines().count(),
        words: content.split_whitespace().count(),
    })
}

// Works for any user:
let alice_doc = alice_root.virtual_join("/report.txt")?;
let bob_doc = bob_root.virtual_join("/notes.txt")?;

let alice_stats = analyze_document(alice_doc.as_unvirtual())?;
let bob_stats = analyze_document(bob_doc.as_unvirtual())?;
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-quota-management"><a class="header" href="#advanced-quota-management">Advanced: Quota Management</a></h2>
<p>Track storage per user:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl DocumentStore {
    fn get_user_storage_size(&amp;self, username: &amp;str) -&gt; Result&lt;u64, Box&lt;dyn std::error::Error&gt;&gt; {
        let user_root = self.user_roots.get(username)
            .ok_or("User not found")?;
        
        let mut total_size = 0u64;
        for entry in walkdir::WalkDir::new(user_root.interop_path()) {
            let entry = entry?;
            if entry.file_type().is_file() {
                total_size += entry.metadata()?.len();
            }
        }
        
        Ok(total_size)
    }
    
    fn check_quota(&amp;self, username: &amp;str, quota: u64) -&gt; Result&lt;bool, Box&lt;dyn std::error::Error&gt;&gt; {
        let used = self.get_user_storage_size(username)?;
        Ok(used &lt; quota)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<ol>
<li><strong>Cache user roots</strong> - Store <code>VirtualRoot</code> instances to avoid repeated creation</li>
<li><strong>Lazy initialization</strong> - Only create directories when first accessed</li>
<li><strong>Batch operations</strong> - Group multiple file operations together</li>
<li><strong>Use async I/O</strong> - All paths work with <code>tokio::fs</code> via <code>.interop_path()</code></li>
</ol>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>One root per user</strong> - Never share <code>VirtualRoot</code> between users</li>
<li><strong>Store virtual paths</strong> - Save virtual paths in your database, not system paths</li>
<li><strong>Display virtual paths</strong> - Show users virtual paths (starting with <code>/</code>)</li>
<li><strong>Use system paths for I/O</strong> - Use <code>.as_unvirtual()</code> when calling file operations</li>
</ol>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li>See <a href="examples/./web_upload_service.html">Web Upload Service</a> for a simpler upload-only example</li>
<li>See <a href="examples/./type_safe_contexts.html">Type-Safe Context Separation</a> to learn about using markers for different document types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive-extraction-with-safety"><a class="header" href="#archive-extraction-with-safety">Archive Extraction with Safety</a></h1>
<p>Extract ZIP files and other archives safely without zip-slip vulnerabilities. This example shows how <code>PathBoundary</code> detects and rejects malicious archive entries.</p>
<h2 id="the-problem-5"><a class="header" href="#the-problem-5">The Problem</a></h2>
<p>Archive extractors are vulnerable to <strong>zip-slip attacks</strong> where malicious archives contain entries like:</p>
<ul>
<li>❌ <code>../../../etc/passwd</code> - Escapes to system files</li>
<li>❌ <code>..\\..\\windows\\system32\\evil.exe</code> - Escapes on Windows</li>
<li>❌ Symlinks pointing outside the extraction directory</li>
</ul>
<h2 id="the-solution-choose-based-on-your-use-case"><a class="header" href="#the-solution-choose-based-on-your-use-case">The Solution: Choose Based on Your Use Case</a></h2>
<h3 id="production-archive-extraction-use-pathboundary-to-detect-attacks"><a class="header" href="#production-archive-extraction-use-pathboundary-to-detect-attacks">Production Archive Extraction: Use PathBoundary to Detect Attacks</a></h3>
<p><strong>Use <code>PathBoundary</code> for production archive extraction.</strong> This detects malicious paths and allows you to:</p>
<ul>
<li>Log the attack attempt</li>
<li>Reject the entire archive as compromised</li>
<li>Alert administrators</li>
<li>Take appropriate security action</li>
</ul>
<p>When extracting archives in production:</p>
<ul>
<li>Escape attempts indicate a <strong>malicious archive</strong></li>
<li>You want to <strong>detect and reject</strong> the archive, not silently hide the attack</li>
<li>The archive should be quarantined or deleted</li>
<li>Users/admins should be alerted to the attempted attack</li>
</ul>
<p><code>PathBoundary</code> returns <code>Err(PathEscapesBoundary)</code> so you can handle the security event appropriately.</p>
<h3 id="researchsandbox-use-virtualroot-to-safely-analyze"><a class="header" href="#researchsandbox-use-virtualroot-to-safely-analyze">Research/Sandbox: Use VirtualRoot to Safely Analyze</a></h3>
<p><strong>Use <code>VirtualRoot</code> when analyzing suspicious archives in a controlled environment:</strong></p>
<ul>
<li>Malware analysis and security research</li>
<li>Safely studying attack techniques</li>
<li>Observing malicious behavior while containing it</li>
<li>Testing archive parsing without risk</li>
</ul>
<p>In research scenarios, you <strong>want</strong> to see what the malicious archive tries to do, but safely contained within a virtual boundary.</p>
<h2 id="recommended-patterns"><a class="header" href="#recommended-patterns">Recommended Patterns</a></h2>
<ul>
<li>✅ Use <code>create_parent_dir_all()</code> before writes to avoid race conditions</li>
<li>✅ Always join via <code>virtual_join()</code> or <code>strict_join()</code> - never concatenate paths manually</li>
<li>✅ Treat absolute, UNC, drive-relative, or namespace-prefixed paths as untrusted</li>
<li>✅ On Windows, NTFS Alternate Data Streams (ADS) like <code>"file.txt:stream"</code> are handled safely</li>
</ul>
<h2 id="anti-patterns-dont-do-this"><a class="header" href="#anti-patterns-dont-do-this">Anti-Patterns (Don't Do This)</a></h2>
<ul>
<li>❌ Building paths with <code>format!</code>/<code>push</code>/<code>join</code> on <code>std::path::Path</code> without validation</li>
<li>❌ Stripping <code>"../"</code> by string replacement</li>
<li>❌ Allowing absolute paths through to the OS</li>
<li>❌ Treating encoded/unicode tricks (URL-encoded, dot lookalikes) as pre-sanitized</li>
</ul>
<h2 id="complete-example-with-pathboundary"><a class="header" href="#complete-example-with-pathboundary">Complete Example with PathBoundary</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath};
use std::fs;
use std::io::Write;

struct SafeArchiveExtractor {
    extraction_dir: PathBoundary,
}

impl SafeArchiveExtractor {
    fn new(extract_to: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        let extraction_dir = PathBoundary::try_new_create(extract_to)?;
        Ok(Self { extraction_dir })
    }
    
    fn extract_entry(&amp;self, entry_path: &amp;str, content: &amp;[u8]) -&gt; Result&lt;StrictPath, Box&lt;dyn std::error::Error&gt;&gt; {
        // This automatically prevents zip-slip attacks
        let safe_path = self.extraction_dir.strict_join(entry_path)?;

        // Create parent directories and write the file
        safe_path.create_parent_dir_all()?;
        safe_path.write(content)?;

        println!("📦 Extracted: {entry_path} -&gt; {}", safe_path.strictpath_display());
        Ok(safe_path)
    }
    
    fn extract_mock_zip(&amp;self) -&gt; Result&lt;Vec&lt;StrictPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        // Simulate extracting a ZIP file with various entries
        let entries = vec![
            ("readme.txt", b"Welcome to our software!" as &amp;[u8]),
            ("src/main.rs", b"fn main() { println!(\"Hello!\"); }"),
            ("docs/api.md", b"# API Documentation"),
            ("config/settings.json", b"{ \"debug\": true }"),
            
            // These malicious entries would be automatically blocked:
            // ("../../../etc/passwd", b"hacked"),           // ❌ Blocked!
            // ("..\\windows\\system32\\evil.exe", b"malware"), // ❌ Blocked!
            // ("/absolute/path/hack.txt", b"bad"),          // ❌ Blocked!
        ];
        
        let mut extracted_files = Vec::new();
        
        for (entry_path, content) in entries {
            match self.extract_entry(entry_path, content) {
                Ok(safe_path) =&gt; extracted_files.push(safe_path),
                Err(e) =&gt; println!("⚠️  Blocked malicious entry '{}': {}", entry_path, e),
            }
        }
        
        Ok(extracted_files)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let extractor = SafeArchiveExtractor::new("extracted_files")?;
    
    println!("🗃️  Extracting archive safely...");
    let extracted = extractor.extract_mock_zip()?;
    
    println!("\n✅ Successfully extracted {} files:", extracted.len());
    for file in &amp;extracted {
        println!("   📄 {}", file.strictpath_display());
    }
    
    // Verify we can read the extracted files
    for file in &amp;extracted {
        if file.strictpath_extension().and_then(|s| s.to_str()) == Some("txt") {
            let content = file.read_to_string()?;
            println!("📖 {}: {}", file.strictpath_display(), content.trim());
        }
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="handling-malicious-archives"><a class="header" href="#handling-malicious-archives">Handling Malicious Archives</a></h2>
<p>When a malicious path is detected, you should:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extract_entry_with_security(
    extraction_dir: &amp;PathBoundary,
    entry_path: &amp;str,
    content: &amp;[u8],
) -&gt; Result&lt;StrictPath, Box&lt;dyn std::error::Error&gt;&gt; {
    match extraction_dir.strict_join(entry_path) {
        Ok(safe_path) =&gt; {
            // Valid path - extract normally
            safe_path.create_parent_dir_all()?;
            safe_path.write(content)?;
            Ok(safe_path)
        }
        Err(e) =&gt; {
            // Malicious path detected!
            eprintln!("🚨 SECURITY ALERT: Malicious archive entry detected!");
            eprintln!("   Entry path: {}", entry_path);
            eprintln!("   Error: {}", e);
            eprintln!("   Action: Rejecting entire archive as compromised");
            
            // Return error to stop extraction
            Err(format!("Archive contains malicious path: {}", entry_path).into())
        }
    }
}

// Usage
let entries = vec![
    ("readme.txt", b"Safe content" as &amp;[u8]),
    ("../../../etc/passwd", b"Malicious"), // Skipped with log
    ("docs/api.md", b"More safe content"),
];

let count = extract_all_resilient("extracted", entries)?;
println!("✅ Successfully extracted {} files", count);
<span class="boring">}</span></code></pre></pre>
<h2 id="key-security-features-3"><a class="header" href="#key-security-features-3">Key Security Features</a></h2>
<h3 id="1-bounded-extraction-directory"><a class="header" href="#1-bounded-extraction-directory">1. Bounded Extraction Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let extraction_dir = PathBoundary::try_new_create(extract_to)?;
<span class="boring">}</span></code></pre></pre>
<p>All extracted files must stay within this directory.</p>
<h3 id="2-automatic-malicious-path-detection"><a class="header" href="#2-automatic-malicious-path-detection">2. Automatic Malicious Path Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let safe_path = self.extraction_dir.strict_join(entry_path)?;
<span class="boring">}</span></code></pre></pre>
<p>This line does all the heavy lifting:</p>
<ul>
<li>Normalizes <code>../</code> sequences</li>
<li>Blocks absolute paths</li>
<li>Prevents symlink escapes</li>
<li>Returns an error for malicious paths</li>
</ul>
<h3 id="3-parent-directory-creation"><a class="header" href="#3-parent-directory-creation">3. Parent Directory Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>safe_path.create_parent_dir_all()?;
<span class="boring">}</span></code></pre></pre>
<p>Automatically creates any necessary parent directories within the boundary.</p>
<h3 id="4-type-safe-returns"><a class="header" href="#4-type-safe-returns">4. Type-Safe Returns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extract_entry(&amp;self, entry_path: &amp;str, content: &amp;[u8]) -&gt; Result&lt;StrictPath, ...&gt;
<span class="boring">}</span></code></pre></pre>
<p>Returning <code>StrictPath</code> ensures extracted paths are always validated.</p>
<h2 id="attack-scenarios-prevented-3"><a class="header" href="#attack-scenarios-prevented-3">Attack Scenarios Prevented</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Malicious Entry</th><th>StrictPath Result</th><th>VirtualPath Result</th></tr></thead><tbody>
<tr><td><code>../../../etc/passwd</code></td><td>❌ Error: path escapes boundary</td><td>✅ Clamped to vroot <code>/etc/passwd</code></td></tr>
<tr><td><code>..\\windows\\system32\\evil.exe</code></td><td>❌ Error: path escapes boundary</td><td>✅ Clamped to vroot <code>/windows/system32/evil.exe</code></td></tr>
<tr><td><code>/var/www/html/shell.php</code></td><td>❌ Error: absolute path rejected</td><td>✅ Clamped to vroot <code>/var/www/html/shell.php</code></td></tr>
<tr><td><code>legitimate/../../etc/passwd</code></td><td>❌ Normalized and blocked</td><td>✅ Normalized and clamped</td></tr>
<tr><td>Symlink to <code>/etc/passwd</code></td><td>❌ Target validated, error if outside</td><td>✅ Target clamped to vroot <code>/etc/passwd</code></td></tr>
</tbody></table>
</div>
<p><strong>Note:</strong> For archive extraction, consider using <code>VirtualPath</code> instead of <code>StrictPath</code> to gracefully clamp malicious entries rather than rejecting them. This provides defense-in-depth: even hostile archives with absolute paths or symlinks are safely contained within the extraction directory.</p>
<h2 id="real-zip-integration"><a class="header" href="#real-zip-integration">Real ZIP Integration</a></h2>
<p>With the <code>zip</code> crate:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath};
use zip::ZipArchive;
use std::fs::File;
use std::io::Read;

struct RealArchiveExtractor {
    extraction_dir: PathBoundary,
}

impl RealArchiveExtractor {
    fn new(extract_to: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        let extraction_dir = PathBoundary::try_new_create(extract_to)?;
        Ok(Self { extraction_dir })
    }
    
    fn extract_zip(&amp;self, zip_path: &amp;str) -&gt; Result&lt;Vec&lt;StrictPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let file = File::open(zip_path)?;
        let mut archive = ZipArchive::new(file)?;
        let mut extracted_files = Vec::new();
        
        for i in 0..archive.len() {
            let mut file = archive.by_index(i)?;
            let entry_path = file.name();
            
            // Validate the entry path - blocks zip-slip automatically
            let safe_path = match self.extraction_dir.strict_join(entry_path) {
                Ok(path) =&gt; path,
                Err(e) =&gt; {
                    println!("⚠️  Skipping malicious entry '{}': {}", entry_path, e);
                    continue;
                }
            };
            
            if file.is_dir() {
                safe_path.create_dir_all()?;
            } else {
                safe_path.create_parent_dir_all()?;
                let mut content = Vec::new();
                file.read_to_end(&amp;mut content)?;
                safe_path.write(&amp;content)?;
                extracted_files.push(safe_path);
                println!("📦 Extracted: {}", entry_path);
            }
        }
        
        Ok(extracted_files)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let extractor = RealArchiveExtractor::new("extracted")?;
    
    // Extract a real ZIP file safely
    let files = extractor.extract_zip("archive.zip")?;
    println!("✅ Extracted {} files", files.len());
    
    Ok(())
}</code></pre></pre>
<h2 id="tar-archives"><a class="header" href="#tar-archives">TAR Archives</a></h2>
<p>With the <code>tar</code> crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};
use tar::Archive;
use std::fs::File;

fn extract_tar(tar_path: &amp;str, extract_to: &amp;str) -&gt; Result&lt;Vec&lt;StrictPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let boundary = PathBoundary::try_new_create(extract_to)?;
    let mut extracted = Vec::new();
    
    let file = File::open(tar_path)?;
    let mut archive = Archive::new(file);
    
    for entry in archive.entries()? {
        let mut entry = entry?;
        let entry_path = entry.path()?;
        let entry_path_str = entry_path.to_string_lossy();
        
        // Validate each entry path
        let safe_path = match boundary.strict_join(&amp;*entry_path_str) {
            Ok(path) =&gt; path,
            Err(e) =&gt; {
                println!("⚠️  Skipping malicious entry '{}': {}", entry_path_str, e);
                continue;
            }
        };
        
        // Extract using the validated path
        entry.unpack(safe_path.interop_path())?;
        extracted.push(safe_path);
        println!("📦 Extracted: {}", entry_path_str);
    }
    
    Ok(extracted)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-extraction-with-filters"><a class="header" href="#advanced-extraction-with-filters">Advanced: Extraction with Filters</a></h2>
<p>Skip certain files or enforce naming patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SafeArchiveExtractor {
    fn extract_with_filter&lt;F&gt;(
        &amp;self,
        entries: Vec&lt;(&amp;str, &amp;[u8])&gt;,
        filter: F,
    ) -&gt; Result&lt;Vec&lt;StrictPath&gt;, Box&lt;dyn std::error::Error&gt;&gt;
    where
        F: Fn(&amp;str) -&gt; bool,
    {
        let mut extracted = Vec::new();
        
        for (entry_path, content) in entries {
            // Apply custom filter
            if !filter(entry_path) {
                println!("⏭️  Skipped by filter: {}", entry_path);
                continue;
            }
            
            // Validate and extract
            match self.extract_entry(entry_path, content) {
                Ok(path) =&gt; extracted.push(path),
                Err(e) =&gt; println!("⚠️  Failed to extract '{}': {}", entry_path, e),
            }
        }
        
        Ok(extracted)
    }
}

// Usage:
let extracted = extractor.extract_with_filter(entries, |path| {
    // Only allow certain file types
    path.ends_with(".txt") || path.ends_with(".md") || path.ends_with(".rs")
})?;
<span class="boring">}</span></code></pre></pre>
<h2 id="temporary-extraction"><a class="header" href="#temporary-extraction">Temporary Extraction</a></h2>
<p>Extract to a temporary directory for processing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;
use tempfile::TempDir;

fn extract_to_temp(archive_path: &amp;str) -&gt; Result&lt;(TempDir, Vec&lt;StrictPath&gt;), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create temp directory
    let temp = TempDir::new()?;
    
    // Create boundary from temp path
    let boundary = PathBoundary::try_new(temp.path())?;
    
    // Extract archive
    let extracted = extract_archive_to_boundary(&amp;boundary, archive_path)?;
    
    // Return both TempDir (to keep it alive) and extracted paths
    Ok((temp, extracted))
}

// Temp directory is automatically cleaned up when TempDir is dropped
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-advice"><a class="header" href="#testing-advice">Testing Advice</a></h2>
<p>Test your extraction code with a malicious archive corpus:</p>
<h3 id="test-cases-to-include"><a class="header" href="#test-cases-to-include">Test Cases to Include</a></h3>
<ul>
<li><strong>Directory traversal</strong>: <code>"../"</code>, <code>"..\\"</code>, <code>"legitimate/../../etc/passwd"</code></li>
<li><strong>Absolute paths</strong>: <code>"/var/www/evil"</code>, <code>"C:\\windows\\system32\\evil.exe"</code></li>
<li><strong>Windows-specific</strong>:
<ul>
<li>UNC paths: <code>"\\\\?\\C:\\windows\\evil"</code></li>
<li>Drive-relative: <code>"C:..\\foo"</code></li>
<li>ADS streams: <code>"decoy.txt:..\\..\\evil.exe"</code></li>
<li>Reserved names: <code>"CON"</code>, <code>"PRN"</code>, <code>"AUX"</code></li>
</ul>
</li>
<li><strong>Unicode tricks</strong>: Dot lookalikes, NFC vs NFD forms</li>
<li><strong>Long paths</strong>: Paths exceeding system limits</li>
</ul>
<h3 id="assertions"><a class="header" href="#assertions">Assertions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_archive_extraction_safety() {
    let boundary = PathBoundary::try_new_create("test_extract").unwrap();
    
    // Should succeed
    assert!(boundary.strict_join("safe/path.txt").is_ok());
    
    // Should fail
    assert!(boundary.strict_join("../../../etc/passwd").is_err());
    assert!(boundary.strict_join("/absolute/path").is_err());
    
    // Cleanup
    std::fs::remove_dir_all("test_extract").ok();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="behavior-notes"><a class="header" href="#behavior-notes">Behavior Notes</a></h2>
<ul>
<li><strong>Virtual joins clamp traversal</strong> lexically to the virtual root</li>
<li><strong>System-facing escapes</strong> (via symlinks/junctions) are rejected during resolution</li>
<li><strong>Unicode is not normalized</strong> - NFC and NFD forms are stored as-is, both safely contained</li>
<li><strong>Hard links and privileged mount tricks</strong> are outside path-level protections (see README limitations)</li>
</ul>
<h2 id="using-virtualpath-for-extra-safety"><a class="header" href="#using-virtualpath-for-extra-safety">Using VirtualPath for Extra Safety</a></h2>
<p>For even safer archive extraction, consider using <code>VirtualPath</code> instead of <code>StrictPath</code>. This clamps malicious entries instead of rejecting them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{VirtualRoot, VirtualPath};

struct VirtualArchiveExtractor {
    extraction_vroot: VirtualRoot,
}

impl VirtualArchiveExtractor {
    fn new(extract_to: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        let extraction_vroot = VirtualRoot::try_new_create(extract_to)?;
        Ok(Self { extraction_vroot })
    }
    
    fn extract_entry(&amp;self, entry_path: &amp;str, content: &amp;[u8]) 
        -&gt; Result&lt;VirtualPath, Box&lt;dyn std::error::Error&gt;&gt; 
    {
        // Malicious paths are CLAMPED instead of rejected
        // "../../../etc/passwd" becomes safe "vroot/etc/passwd"
        // Absolute symlink targets are also clamped to vroot
        let safe_path = self.extraction_vroot.virtual_join(entry_path)?;

        safe_path.create_parent_dir_all()?;
        safe_path.write(content)?;

        println!("📦 Extracted: {} -&gt; {}", 
                 entry_path, 
                 safe_path.virtualpath_display());
        Ok(safe_path)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why VirtualPath for archives?</strong></p>
<ul>
<li>✅ Hostile entries with <code>../../../</code> are clamped, not rejected</li>
<li>✅ Absolute symlink targets (e.g., <code>link -&gt; /etc/passwd</code>) are clamped to vroot</li>
<li>✅ Archive extraction continues even with malicious entries</li>
<li>✅ Defense-in-depth: every entry is safely contained</li>
<li>✅ Perfect for untrusted archives from the internet</li>
</ul>
<p><strong>When to use each:</strong></p>
<ul>
<li><strong><code>StrictPath</code>:</strong> Fail-fast validation — reject malicious archives immediately</li>
<li><strong><code>VirtualPath</code>:</strong> Graceful containment — clamp every entry to stay safe, continue extraction</li>
</ul>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Always validate</strong> - Never trust archive entry paths</li>
<li><strong>Log suspicious entries</strong> - Track and alert on blocked paths</li>
<li><strong>Limit extraction size</strong> - Check total extracted size to prevent zip bombs</li>
<li><strong>Filter file types</strong> - Only extract expected file types</li>
<li><strong>Use temporary storage</strong> - Extract to temp directory first, then move to final location</li>
<li><strong>Consider VirtualPath</strong> - Use for untrusted archives to clamp rather than reject malicious entries</li>
</ol>
<h2 id="integration-tips-2"><a class="header" href="#integration-tips-2">Integration Tips</a></h2>
<h3 id="with-web-uploads"><a class="header" href="#with-web-uploads">With Web Uploads</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_upload(file: UploadedFile) -&gt; Result&lt;Vec&lt;String&gt;, AppError&gt; {
    // Save uploaded file
    let temp_zip = save_upload(file).await?;
    
    // Extract safely
    let extractor = SafeArchiveExtractor::new("uploads/extracted")?;
    let files = extractor.extract_zip(&amp;temp_zip)?;
    
    // Return list of extracted files
    Ok(files.iter()
        .map(|p| p.strictpath_display().to_string())
        .collect())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-background-jobs"><a class="header" href="#with-background-jobs">With Background Jobs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn extract_job(job_id: String, archive_path: String) -&gt; Result&lt;(), JobError&gt; {
    let extract_dir = format!("jobs/{}/extracted", job_id);
    let extractor = SafeArchiveExtractor::new(&amp;extract_dir)?;
    
    let files = extractor.extract_zip(&amp;archive_path)?;
    
    // Store results in database
    for file in files {
        db_store_file(&amp;job_id, file.strictpath_display())?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li>See <a href="examples/./cli_tool.html">CLI Tool</a> for handling user-provided file paths</li>
<li>See <a href="examples/./web_upload_service.html">Web Upload Service</a> for combining uploads with safe storage</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-tool-with-safe-path-handling"><a class="header" href="#cli-tool-with-safe-path-handling">CLI Tool with Safe Path Handling</a></h1>
<p>Build command-line tools that safely process user-provided file paths. This example shows how to handle untrusted path arguments securely.</p>
<h2 id="the-problem-6"><a class="header" href="#the-problem-6">The Problem</a></h2>
<p>CLI tools accept file paths from users, but must prevent:</p>
<ul>
<li>❌ Users accessing files outside the working directory</li>
<li>❌ Path traversal attacks via command-line arguments</li>
<li>❌ Accidental exposure of sensitive files</li>
</ul>
<h2 id="the-solution-3"><a class="header" href="#the-solution-3">The Solution</a></h2>
<p>Use <code>PathBoundary</code> to create a working directory jail. All file operations are restricted to this boundary.</p>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath};
use std::env;
use std::fs;

struct SafeFileProcessor {
    working_dir: PathBoundary,
}

impl SafeFileProcessor {
    fn new(working_directory: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Create or validate the working directory
        let working_dir = PathBoundary::try_new_create(working_directory)?;
        println!("🔒 Working directory jail: {}", working_dir.strictpath_display());
        Ok(Self { working_dir })
    }
    
    fn process_file(&amp;self, relative_path: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate the user-provided path
        let safe_path = self.working_dir.strict_join(relative_path)?;
        
        if !safe_path.exists() {
            return Err(format!("File not found: {}", relative_path).into());
        }
        
        // Process the file (example: count lines)
        let content = safe_path.read_to_string()?;
        let line_count = content.lines().count();
        let word_count = content.split_whitespace().count();
        let char_count = content.chars().count();
        
        println!("📊 Statistics for {}:", relative_path);
        println!("   Lines: {}", line_count);
        println!("   Words: {}", word_count);
        println!("   Characters: {}", char_count);
        
        Ok(())
    }
    
    fn create_sample_files(&amp;self) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Create some sample files for testing
        let samples = vec![
            ("sample1.txt", "Hello world!\nThis is a test file.\nWith multiple lines."),
            ("data/sample2.txt", "Another file\nwith some content\nfor processing."),
            ("docs/readme.md", "# Sample Project\n\nThis is a sample markdown file."),
        ];
        
        for (path, content) in samples {
            let safe_path = self.working_dir.strict_join(path)?;
            safe_path.create_parent_dir_all()?;
            safe_path.write(content)?;
            println!("📝 Created: {path}");
        }
        
        Ok(())
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let args: Vec&lt;String&gt; = env::args().collect();
    
    if args.len() &lt; 2 {
        println!("Usage: {} &lt;file-path&gt;", args[0]);
        println!("       {} --create-samples", args[0]);
        return Ok(());
    }
    
    // Set up our safe processor
    let processor = SafeFileProcessor::new("workspace")?;
    
    if args[1] == "--create-samples" {
        processor.create_sample_files()?;
        println!("✅ Sample files created in workspace/");
        return Ok(());
    }
    
    // Process the user-specified file
    let file_path = &amp;args[1];
    
    match processor.process_file(file_path) {
        Ok(()) =&gt; println!("✅ File processed successfully!"),
        Err(e) =&gt; {
            println!("❌ Error processing file: {}", e);
            
            if file_path.contains("..") || file_path.starts_with('/') || file_path.contains('\\') {
                println!("💡 Tip: Use relative paths within the workspace directory only.");
                println!("   Trying to escape the workspace? That's not allowed! 🔒");
            }
        }
    }
    
    Ok(())
}

// Example usage:
// cargo run -- --create-samples
// cargo run -- sample1.txt                    # ✅ Works
// cargo run -- data/sample2.txt              # ✅ Works  
// cargo run -- ../../../etc/passwd           # ❌ Blocked!
// cargo run -- /absolute/path/hack.txt       # ❌ Blocked!</code></pre></pre>
<h2 id="key-security-features-4"><a class="header" href="#key-security-features-4">Key Security Features</a></h2>
<h3 id="1-working-directory-jail"><a class="header" href="#1-working-directory-jail">1. Working Directory Jail</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let working_dir = PathBoundary::try_new_create(working_directory)?;
<span class="boring">}</span></code></pre></pre>
<p>All file operations are restricted to this directory and its subdirectories.</p>
<h3 id="2-user-input-validation"><a class="header" href="#2-user-input-validation">2. User Input Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let safe_path = self.working_dir.strict_join(relative_path)?;
<span class="boring">}</span></code></pre></pre>
<p>User-provided paths from command-line arguments are validated before any file access.</p>
<h3 id="3-helpful-error-messages"><a class="header" href="#3-helpful-error-messages">3. Helpful Error Messages</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if file_path.contains("..") || file_path.starts_with('/') {
    println!("💡 Tip: Use relative paths within the workspace directory only.");
}
<span class="boring">}</span></code></pre></pre>
<p>Guide users toward safe usage patterns.</p>
<h3 id="4-safe-file-operations"><a class="header" href="#4-safe-file-operations">4. Safe File Operations</a></h3>
<p>All operations use the validated <code>StrictPath</code>, so security is guaranteed by the type system.</p>
<h2 id="attack-scenarios-prevented-4"><a class="header" href="#attack-scenarios-prevented-4">Attack Scenarios Prevented</a></h2>
<div class="table-wrapper"><table><thead><tr><th>User Input</th><th>Result</th></tr></thead><tbody>
<tr><td><code>sample1.txt</code></td><td>✅ Processes workspace/sample1.txt</td></tr>
<tr><td><code>data/sample2.txt</code></td><td>✅ Processes workspace/data/sample2.txt</td></tr>
<tr><td><code>../../../etc/passwd</code></td><td>❌ Error: path escapes boundary</td></tr>
<tr><td><code>/var/log/system.log</code></td><td>❌ Error: absolute paths not allowed</td></tr>
<tr><td><code>..\\..\\windows\\system32</code></td><td>❌ Error: path escapes boundary</td></tr>
</tbody></table>
</div>
<h2 id="advanced-multiple-operations"><a class="header" href="#advanced-multiple-operations">Advanced: Multiple Operations</a></h2>
<p>Process multiple files from command-line arguments:</p>
<pre><pre class="playground"><code class="language-rust">impl SafeFileProcessor {
    fn process_multiple(&amp;self, paths: &amp;[String]) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        for path in paths {
            match self.process_file(path) {
                Ok(()) =&gt; println!("✅ Processed: {}", path),
                Err(e) =&gt; println!("❌ Failed to process '{}': {}", path, e),
            }
        }
        Ok(())
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let args: Vec&lt;String&gt; = env::args().collect();
    
    if args.len() &lt; 2 {
        println!("Usage: {} &lt;file1&gt; [file2] [file3] ...", args[0]);
        return Ok(());
    }
    
    let processor = SafeFileProcessor::new("workspace")?;
    let file_paths = &amp;args[1..];
    
    processor.process_multiple(file_paths)?;
    
    Ok(())
}</code></pre></pre>
<h2 id="pattern-matching-and-filtering"><a class="header" href="#pattern-matching-and-filtering">Pattern Matching and Filtering</a></h2>
<p>Process files matching a pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SafeFileProcessor {
    fn process_pattern(&amp;self, pattern: &amp;str) -&gt; Result&lt;Vec&lt;StrictPath&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut processed = Vec::new();
        
        for entry in self.working_dir.read_dir()? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                let filename = entry.file_name();
                let filename_str = filename.to_string_lossy();
                
                // Simple pattern matching (extend with regex if needed)
                if filename_str.ends_with(pattern) {
                    let file_path = self.working_dir.strict_join(&amp;filename)?;
                    self.process_file(&amp;filename_str)?;
                    processed.push(file_path);
                }
            }
        }
        
        Ok(processed)
    }
}

// Usage:
// cargo run -- "*.txt"  // Process all .txt files
// cargo run -- "*.md"   // Process all .md files
<span class="boring">}</span></code></pre></pre>
<h2 id="interactive-mode"><a class="header" href="#interactive-mode">Interactive Mode</a></h2>
<p>Build an interactive CLI with safe path handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, BufRead};

fn interactive_mode(processor: &amp;SafeFileProcessor) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    println!("📂 Interactive mode - enter file paths to process (type 'quit' to exit)");
    println!("🔒 Working in: {}", processor.working_dir.strictpath_display());
    
    let stdin = io::stdin();
    for line in stdin.lock().lines() {
        let line = line?;
        let trimmed = line.trim();
        
        if trimmed == "quit" || trimmed == "exit" {
            break;
        }
        
        if trimmed == "list" {
            list_files(&amp;processor.working_dir)?;
            continue;
        }
        
        if trimmed.is_empty() {
            continue;
        }
        
        match processor.process_file(trimmed) {
            Ok(()) =&gt; println!("✅ Done"),
            Err(e) =&gt; println!("❌ Error: {}", e),
        }
    }
    
    println!("👋 Goodbye!");
    Ok(())
}

fn list_files(boundary: &amp;PathBoundary) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    println!("📁 Available files:");
    for entry in boundary.read_dir()? {
        let entry = entry?;
        println!("  - {}", entry.file_name().to_string_lossy());
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="output-file-handling"><a class="header" href="#output-file-handling">Output File Handling</a></h2>
<p>Write results to output files safely:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SafeFileProcessor {
    fn process_to_output(
        &amp;self,
        input_path: &amp;str,
        output_path: &amp;str,
    ) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate both input and output paths
        let input = self.working_dir.strict_join(input_path)?;
        let output = self.working_dir.strict_join(output_path)?;
        
        // Process input
        let content = input.read_to_string()?;
        let processed = content.to_uppercase(); // Example transformation
        
        // Write to output
        output.create_parent_dir_all()?;
        output.write(&amp;processed)?;
        
        println!("✅ Processed {} -&gt; {}", input_path, output_path);
        
        Ok(())
    }
}

// Usage:
// cargo run -- input.txt output.txt
<span class="boring">}</span></code></pre></pre>
<h2 id="environment-variable-configuration"><a class="header" href="#environment-variable-configuration">Environment Variable Configuration</a></h2>
<p>Allow configuration via environment variables:</p>
<pre><pre class="playground"><code class="language-rust">fn get_working_directory() -&gt; String {
    env::var("WORKSPACE_DIR")
        .unwrap_or_else(|_| "workspace".to_string())
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let work_dir = get_working_directory();
    let processor = SafeFileProcessor::new(&amp;work_dir)?;
    
    // ... rest of implementation
    Ok(())
}

// Usage:
// WORKSPACE_DIR=/path/to/data cargo run -- file.txt</code></pre></pre>
<h2 id="progress-tracking"><a class="header" href="#progress-tracking">Progress Tracking</a></h2>
<p>For processing many files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SafeFileProcessor {
    fn process_directory(&amp;self) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        let mut total = 0;
        let mut processed = 0;
        let mut failed = 0;
        
        // Count total files
        for entry in self.working_dir.read_dir()? {
            if entry?.file_type()?.is_file() {
                total += 1;
            }
        }
        
        println!("📊 Processing {} files...", total);
        
        // Process each file
        for entry in self.working_dir.read_dir()? {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                let filename = entry.file_name();
                let path_str = filename.to_string_lossy();
                
                match self.process_file(&amp;path_str) {
                    Ok(()) =&gt; {
                        processed += 1;
                        println!("[{}/{}] ✅ {}", processed + failed, total, path_str);
                    }
                    Err(e) =&gt; {
                        failed += 1;
                        println!("[{}/{}] ❌ {}: {}", processed + failed, total, path_str, e);
                    }
                }
            }
        }
        
        println!("\n📈 Summary:");
        println!("   Total: {}", total);
        println!("   Processed: {}", processed);
        println!("   Failed: {}", failed);
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li><strong>Clear boundaries</strong> - Clearly communicate the working directory to users</li>
<li><strong>Helpful errors</strong> - Explain why paths are rejected and suggest alternatives</li>
<li><strong>Relative paths only</strong> - Guide users toward using relative paths</li>
<li><strong>Validate early</strong> - Check paths before performing expensive operations</li>
<li><strong>Log rejections</strong> - Track attempted path escapes for security monitoring</li>
</ol>
<h2 id="integration-tips-3"><a class="header" href="#integration-tips-3">Integration Tips</a></h2>
<h3 id="with-clap-for-argument-parsing"><a class="header" href="#with-clap-for-argument-parsing">With <code>clap</code> for Argument Parsing</a></h3>
<pre><pre class="playground"><code class="language-rust">use clap::Parser;

#[derive(Parser)]
struct Cli {
    /// File to process (relative to workspace)
    #[arg(value_name = "FILE")]
    file_path: String,
    
    /// Working directory
    #[arg(short, long, default_value = "workspace")]
    workspace: String,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let cli = Cli::parse();
    let processor = SafeFileProcessor::new(&amp;cli.workspace)?;
    processor.process_file(&amp;cli.file_path)?;
    Ok(())
}</code></pre></pre>
<h3 id="with-glob-patterns"><a class="header" href="#with-glob-patterns">With Glob Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use glob::glob;

fn process_glob(processor: &amp;SafeFileProcessor, pattern: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let workspace = processor.working_dir.strictpath_display().to_string();
    let full_pattern = format!("{}/{}", workspace, pattern);
    
    for entry in glob(&amp;full_pattern)? {
        let path = entry?;
        if let Ok(relative) = path.strip_prefix(&amp;workspace) {
            if let Some(relative_str) = relative.to_str() {
                processor.process_file(relative_str)?;
            }
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li>See <a href="examples/./config_manager.html">Configuration Manager</a> for handling config files safely</li>
<li>See <a href="examples/./archive_extraction.html">Archive Extraction</a> for processing archives from CLI</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-safe-context-separation"><a class="header" href="#type-safe-context-separation">Type-Safe Context Separation</a></h1>
<p>Learn how to use marker types to prevent accidentally mixing different storage contexts at compile time. This is one of the most powerful features of strict-path.</p>
<h2 id="the-problem-7"><a class="header" href="#the-problem-7">The Problem</a></h2>
<p>Applications often have multiple storage areas for different purposes:</p>
<ul>
<li>🌐 Web assets (CSS, JS, images)</li>
<li>📁 User uploads (documents, photos)</li>
<li>⚙️ Configuration files</li>
<li>🔒 Sensitive data (keys, tokens)</li>
</ul>
<p><strong>Without type safety</strong>, you might accidentally:</p>
<ul>
<li>❌ Serve a user's private document as a web asset</li>
<li>❌ Write config data to the uploads directory</li>
<li>❌ Read a sensitive key file when expecting a CSS file</li>
</ul>
<h2 id="the-solution-4"><a class="header" href="#the-solution-4">The Solution</a></h2>
<p>Use marker types with <code>StrictPath&lt;Marker&gt;</code> and <code>VirtualPath&lt;Marker&gt;</code> to encode context at the type level. The compiler prevents context mixing.</p>
<h2 id="complete-example-4"><a class="header" href="#complete-example-4">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, VirtualRoot, VirtualPath};

// Define marker types for different contexts
struct WebAssets;    // CSS, JS, images
struct UserFiles;    // Uploaded documents
struct ConfigData;   // Application configuration

// Functions enforce context via type system
fn serve_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, std::io::Error&gt; {
    path.read()
}

fn process_upload(path: &amp;StrictPath&lt;UserFiles&gt;) -&gt; Result&lt;(), std::io::Error&gt; {
    // Process user-uploaded file
    let content = path.read_to_string()?;
    println!("Processing user file: {} bytes", content.len());
    Ok(())
}

fn load_config(path: &amp;StrictPath&lt;ConfigData&gt;) -&gt; Result&lt;String, std::io::Error&gt; {
    path.read_to_string()
}

fn example_type_safety() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create context-specific boundaries
    let assets_root: VirtualRoot&lt;WebAssets&gt; = VirtualRoot::try_new("public")?;
    let uploads_root: VirtualRoot&lt;UserFiles&gt; = VirtualRoot::try_new("uploads")?;
    let config_boundary: PathBoundary&lt;ConfigData&gt; = PathBoundary::try_new("config")?;

    // Create paths with proper contexts
    let css: VirtualPath&lt;WebAssets&gt; = assets_root.virtual_join("app.css")?;
    let doc: VirtualPath&lt;UserFiles&gt; = uploads_root.virtual_join("report.pdf")?;
    let cfg: StrictPath&lt;ConfigData&gt; = config_boundary.strict_join("app.toml")?;

    // Type system prevents context mixing
    serve_asset(css.as_unvirtual())?;         // ✅ Correct context
    process_upload(doc.as_unvirtual())?;      // ✅ Correct context  
    load_config(&amp;cfg)?;                       // ✅ Correct context

    // These would be compile errors:
    // serve_asset(doc.as_unvirtual())?;      // ❌ Compile error - wrong context!
    // process_upload(css.as_unvirtual())?;   // ❌ Compile error - wrong context!
    // load_config(css.as_unvirtual())?;      // ❌ Compile error - wrong context!

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-benefits"><a class="header" href="#key-benefits">Key Benefits</a></h2>
<h3 id="1-compile-time-safety"><a class="header" href="#1-compile-time-safety">1. Compile-Time Safety</a></h3>
<p>The compiler catches context mixing errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let css: VirtualPath&lt;WebAssets&gt; = assets_root.virtual_join("app.css")?;
let doc: VirtualPath&lt;UserFiles&gt; = uploads_root.virtual_join("report.pdf")?;

serve_asset(css.as_unvirtual())?;  // ✅ OK
serve_asset(doc.as_unvirtual())?;  // ❌ Compile error!
//          ^^^ expected WebAssets, found UserFiles
<span class="boring">}</span></code></pre></pre>
<h3 id="2-clear-interfaces"><a class="header" href="#2-clear-interfaces">2. Clear Interfaces</a></h3>
<p>Function signatures document what they accept:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This function ONLY accepts web assets
fn serve_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, std::io::Error&gt; {
    // No need to check if this is the right type of file
    // The type system guarantees it
    path.read()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-refactoring-safety"><a class="header" href="#3-refactoring-safety">3. Refactoring Safety</a></h3>
<p>If you change a function's context requirement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Change signature from WebAssets to ConfigData
fn serve_asset(path: &amp;StrictPath&lt;ConfigData&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, std::io::Error&gt; {
    path.read()
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler finds all call sites that need updating. Zero-cost migration!</p>
<h3 id="4-team-collaboration"><a class="header" href="#4-team-collaboration">4. Team Collaboration</a></h3>
<p>New developers can't make context mixing mistakes - the compiler teaches them the correct patterns.</p>
<h2 id="real-world-pattern-multi-context-web-server"><a class="header" href="#real-world-pattern-multi-context-web-server">Real-World Pattern: Multi-Context Web Server</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, StrictPath, VirtualRoot, VirtualPath};

struct WebAssets;
struct UserUploads;
struct ServerConfig;

struct WebServer {
    assets: VirtualRoot&lt;WebAssets&gt;,
    uploads: VirtualRoot&lt;UserUploads&gt;,
    config: PathBoundary&lt;ServerConfig&gt;,
}

impl WebServer {
    fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        Ok(Self {
            assets: VirtualRoot::try_new("public")?,
            uploads: VirtualRoot::try_new("uploads")?,
            config: PathBoundary::try_new("config")?,
        })
    }
    
    // This can ONLY serve web assets
    fn serve_static_file(&amp;self, path: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let asset: VirtualPath&lt;WebAssets&gt; = self.assets.virtual_join(path)?;
        Ok(self.read_asset(asset.as_unvirtual())?)
    }
    
    // Helper enforces WebAssets context
    fn read_asset(&amp;self, path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
        path.read()
    }
    
    // This can ONLY handle user uploads
    fn save_upload(&amp;self, filename: &amp;str, content: &amp;[u8]) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        let upload: VirtualPath&lt;UserUploads&gt; = self.uploads.virtual_join(filename)?;
        self.write_upload(upload.as_unvirtual(), content)?;
        Ok(())
    }
    
    // Helper enforces UserUploads context
    fn write_upload(&amp;self, path: &amp;StrictPath&lt;UserUploads&gt;, content: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
        path.create_parent_dir_all()?;
        path.write(content)
    }
    
    // This can ONLY read config files
    fn load_config(&amp;self, name: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let cfg: StrictPath&lt;ServerConfig&gt; = self.config.strict_join(name)?;
        Ok(self.read_config(&amp;cfg)?)
    }
    
    // Helper enforces ServerConfig context
    fn read_config(&amp;self, path: &amp;StrictPath&lt;ServerConfig&gt;) -&gt; std::io::Result&lt;String&gt; {
        path.read_to_string()
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let server = WebServer::new()?;
    
    // Each method can only access its designated context
    let css = server.serve_static_file("app.css")?;
    server.save_upload("document.pdf", b"PDF content")?;
    let config = server.load_config("server.toml")?;
    
    // These would be impossible to mess up due to type safety:
    // - Can't serve an upload as a static file
    // - Can't save a config as an upload
    // - Can't read an asset as config
    
    Ok(())
}</code></pre></pre>
<h2 id="advanced-permission-markers"><a class="header" href="#advanced-permission-markers">Advanced: Permission Markers</a></h2>
<p>Combine resource markers with permission markers using tuples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Resource markers
struct Documents;
struct DatabaseFiles;

// Permission markers
struct ReadOnly;
struct ReadWrite;

// Type-safe permission enforcement
fn read_document(path: &amp;StrictPath&lt;(Documents, ReadOnly)&gt;) -&gt; std::io::Result&lt;String&gt; {
    path.read_to_string()
}

fn write_document(
    path: &amp;StrictPath&lt;(Documents, ReadWrite)&gt;,
    content: &amp;str,
) -&gt; std::io::Result&lt;()&gt; {
    path.write(content)
}

fn backup_database(
    source: &amp;StrictPath&lt;(DatabaseFiles, ReadOnly)&gt;,
    dest: &amp;StrictPath&lt;(DatabaseFiles, ReadWrite)&gt;,
) -&gt; std::io::Result&lt;()&gt; {
    let data = source.read()?;
    dest.write(&amp;data)
}

fn example_permissions() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let docs_ro: PathBoundary&lt;(Documents, ReadOnly)&gt; = 
        PathBoundary::try_new("documents")?;
    let docs_rw: PathBoundary&lt;(Documents, ReadWrite)&gt; = 
        PathBoundary::try_new("documents")?;
    
    let file_ro = docs_ro.strict_join("report.txt")?;
    let file_rw = docs_rw.strict_join("report.txt")?;
    
    // Can read from read-only
    read_document(&amp;file_ro)?;
    
    // Can't write to read-only - compile error!
    // write_document(&amp;file_ro, "new content")?;  // ❌ Compile error!
    
    // Can write to read-write
    write_document(&amp;file_rw, "new content")?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-authorization-markers"><a class="header" href="#advanced-authorization-markers">Advanced: Authorization Markers</a></h2>
<p>Use <code>change_marker()</code> after authorization checks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

struct UserFiles;
struct ReadOnly;
struct ReadWrite;

fn authenticate_and_upgrade(
    path: StrictPath&lt;(UserFiles, ReadOnly)&gt;,
    user_has_write_access: bool,
) -&gt; Result&lt;StrictPath&lt;(UserFiles, ReadWrite)&gt;, &amp;'static str&gt; {
    if user_has_write_access {
        // Authorization succeeded - change marker to encode permission
        Ok(path.change_marker())
    } else {
        Err("Access denied")
    }
}

fn write_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;, content: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    path.write(content)
}

// Usage:
let boundary: PathBoundary&lt;(UserFiles, ReadOnly)&gt; = 
    PathBoundary::try_new("uploads")?;
let file_ro = boundary.strict_join("document.txt")?;

// Can't write yet - read-only marker
// write_file(&amp;file_ro, b"data")?;  // ❌ Compile error!

// After authorization, upgrade to read-write
if let Ok(file_rw) = authenticate_and_upgrade(file_ro, check_permissions()) {
    write_file(&amp;file_rw, b"data")?;  // ✅ Now allowed
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="examples/../authorization_security.html">Authorization &amp; Permissions</a> chapter for more details.</p>
<h2 id="shared-logic-across-contexts"><a class="header" href="#shared-logic-across-contexts">Shared Logic Across Contexts</a></h2>
<p>Use generics when logic applies to any context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generic over marker type - works with any context
fn get_file_size&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; std::io::Result&lt;u64&gt; {
    path.metadata().map(|m| m.len())
}

// Works with any marker
let asset_size = get_file_size(&amp;css_file)?;
let upload_size = get_file_size(&amp;upload_file)?;
let config_size = get_file_size(&amp;config_file)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="1-name-markers-after-resources"><a class="header" href="#1-name-markers-after-resources">1. Name Markers After Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserDocuments;   // ✅ Clear
struct Documents;       // ⚠️  Which documents?
struct MyMarker;        // ❌ Meaningless
<span class="boring">}</span></code></pre></pre>
<h3 id="2-use-tuples-for-multi-dimensional-context"><a class="header" href="#2-use-tuples-for-multi-dimensional-context">2. Use Tuples for Multi-Dimensional Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StrictPath&lt;(ResourceType, PermissionLevel)&gt;
StrictPath&lt;(UserFiles, ReadWrite)&gt;
<span class="boring">}</span></code></pre></pre>
<h3 id="3-keep-markers-simple"><a class="header" href="#3-keep-markers-simple">3. Keep Markers Simple</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Simple, zero-size
struct WebAssets;

// ❌ Don't add fields
struct WebAssets {
    size_limit: usize,  // Wrong - use runtime checks
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-document-marker-meaning"><a class="header" href="#4-document-marker-meaning">4. Document Marker Meaning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Marker for publicly-accessible web assets
/// (CSS, JavaScript, images, fonts)
struct WebAssets;

/// Marker for user-uploaded files
/// (documents, photos, videos)
struct UserUploads;
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-tips-4"><a class="header" href="#integration-tips-4">Integration Tips</a></h2>
<h3 id="with-web-frameworks-2"><a class="header" href="#with-web-frameworks-2">With Web Frameworks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Axum route handlers
async fn serve_asset(
    Path(asset_path): Path&lt;String&gt;,
) -&gt; Result&lt;Vec&lt;u8&gt;, StatusCode&gt; {
    let assets: VirtualRoot&lt;WebAssets&gt; = get_assets_root();
    let asset = assets.virtual_join(&amp;asset_path)
        .map_err(|_| StatusCode::BAD_REQUEST)?;
    
    read_asset(asset.as_unvirtual())
        .map_err(|_| StatusCode::NOT_FOUND)
}

fn read_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    path.read()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="with-async-runtimes-1"><a class="header" href="#with-async-runtimes-1">With Async Runtimes</a></h3>
<p>Type safety works with async code too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn read_asset_async(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    tokio::fs::read(path.interop_path()).await
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="pattern-1-service-with-multiple-contexts"><a class="header" href="#pattern-1-service-with-multiple-contexts">Pattern 1: Service with Multiple Contexts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AppService {
    assets: VirtualRoot&lt;WebAssets&gt;,
    uploads: VirtualRoot&lt;UserFiles&gt;,
    config: PathBoundary&lt;ConfigData&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-generic-helpers"><a class="header" href="#pattern-2-generic-helpers">Pattern 2: Generic Helpers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exists&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; bool {
    path.exists()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-marker-transformation"><a class="header" href="#pattern-3-marker-transformation">Pattern 3: Marker Transformation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn authorize&lt;R&gt;(
    path: StrictPath&lt;(R, ReadOnly)&gt;,
) -&gt; Result&lt;StrictPath&lt;(R, ReadWrite)&gt;, Error&gt; {
    // Check permissions...
    Ok(path.change_marker())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li>See <a href="examples/../authorization_security.html">Authorization &amp; Permissions</a> for advanced marker patterns</li>
<li>See <a href="examples/./web_upload_service.html">Web Upload Service</a> for practical multi-context usage</li>
<li>See <a href="examples/../tutorial/stage3_markers.html">Tutorial Stage 3</a> for marker basics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="axum-web-service-tutorial"><a class="header" href="#axum-web-service-tutorial">Axum Web Service Tutorial</a></h1>
<p>This tutorial demonstrates <strong>key security patterns</strong> for web services using <strong>Axum</strong> and <strong>strict-path</strong>. We focus on the essential integration points where path validation prevents vulnerabilities.</p>
<blockquote>
<p><strong>Quick Start</strong>: If you want a framework-agnostic example first, see <a href="axum_tutorial/../examples/web_upload_service.html">Web File Upload Service</a> for the basic concepts without web framework complexity.</p>
</blockquote>
<h2 id="what-youll-learn-1"><a class="header" href="#what-youll-learn-1">What You'll Learn</a></h2>
<p>How to integrate <code>strict-path</code> into an Axum web service:</p>
<ul>
<li><strong>Static file serving</strong> with <code>PathBoundary</code> to prevent directory traversal</li>
<li><strong>Per-user file storage</strong> with <code>VirtualRoot</code> for user isolation</li>
<li><strong>Type-safe contexts</strong> with marker types to prevent mixing boundaries</li>
</ul>
<h2 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h2>
<p>Without <code>strict-path</code>, common mistakes lead to vulnerabilities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ UNSAFE: User can access any file
let file_path = format!("./uploads/{}", user_input);
std::fs::read_to_string(file_path)?

// ✅ SAFE: Validated path, guaranteed within boundary
let file = uploads_root.virtual_join(user_input)?;
file.read_to_string()?
<span class="boring">}</span></code></pre></pre>
<h2 id="tutorial-structure"><a class="header" href="#tutorial-structure">Tutorial Structure</a></h2>
<p>Short, focused chapters showing essential patterns:</p>
<h3 id="chapter-1-project-setup"><a class="header" href="#chapter-1-project-setup"><a href="axum_tutorial/./chapter1_setup.html">Chapter 1: Project Setup</a></a></h3>
<p>Basic project structure, marker types, and boundary initialization.</p>
<h3 id="chapter-2-static-assets"><a class="header" href="#chapter-2-static-assets"><a href="axum_tutorial/./chapter2_static_assets.html">Chapter 2: Static Assets</a></a></h3>
<p>Serve static files safely with <code>StrictPath&lt;WebAssets&gt;</code>.</p>
<h3 id="chapter-3-per-user-storage"><a class="header" href="#chapter-3-per-user-storage"><a href="axum_tutorial/./chapter3_user_storage.html">Chapter 3: Per-User Storage</a></a></h3>
<p>Isolate user files with <code>VirtualRoot&lt;UserUploads&gt;</code>.</p>
<h3 id="chapter-3-user-authentication"><a class="header" href="#chapter-3-user-authentication"><a href="axum_tutorial/./chapter3_authentication.html">Chapter 3: User Authentication</a></a></h3>
<p>Add user authentication and create per-user storage isolation.</p>
<p><strong>What you'll learn:</strong></p>
<ul>
<li>Simple session-based authentication</li>
<li>Creating VirtualRoot per user</li>
<li>Authorization markers with change_marker()</li>
<li>Protecting routes with middleware</li>
</ul>
<h3 id="chapter-4-file-upload-system"><a class="header" href="#chapter-4-file-upload-system"><a href="axum_tutorial/./chapter4_uploads.html">Chapter 4: File Upload System</a></a></h3>
<p>Build a secure file upload system with per-user isolation.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><strong>Rust</strong>: 1.71.0 or later</li>
<li><strong>Basic Axum knowledge</strong>: Understanding handlers and state</li>
</ul>
<hr />
<p><strong>Ready to start?</strong> → <a href="axum_tutorial/./chapter1_setup.html">Chapter 1: Project Setup</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-project-setup-1"><a class="header" href="#chapter-1-project-setup-1">Chapter 1: Project Setup</a></h1>
<p>Let's set up our Axum web service with proper security boundaries from the start. We'll create the project structure, define our marker types, and establish path boundaries for different storage areas.</p>
<h2 id="create-the-project"><a class="header" href="#create-the-project">Create the Project</a></h2>
<pre><code class="language-bash">cargo new file-sharing-service
cd file-sharing-service
</code></pre>
<h2 id="add-dependencies"><a class="header" href="#add-dependencies">Add Dependencies</a></h2>
<p>Update your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "file-sharing-service"
version = "0.1.0"
edition = "2021"

[dependencies]
# Web framework
axum = "0.7"
tokio = { version = "1", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["fs", "trace"] }

# Security and paths
strict-path = { version = "0.1", features = ["serde"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Utilities
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
</code></pre>
<h2 id="define-security-boundaries"><a class="header" href="#define-security-boundaries">Define Security Boundaries</a></h2>
<p>Create <code>src/markers.rs</code> - this is where we define our type-safe contexts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Type-safe markers for different storage contexts.
//! 
//! These zero-cost markers prevent accidentally mixing different
//! types of files (e.g., serving user uploads as web assets).

/// Public web assets (CSS, JavaScript, images, fonts)
/// 
/// Files with this marker can be served to anyone without authentication.
pub struct WebAssets;

/// User-uploaded files (documents, photos, videos)
/// 
/// Each user has their own isolated VirtualRoot with this marker.
/// Files are private and require authentication to access.
pub struct UserUploads;

/// Application configuration files
/// 
/// Server configuration, secrets, and settings.
/// Never exposed to users.
pub struct AppConfig;

/// Read-only permission marker
pub struct ReadOnly;

/// Read-write permission marker  
pub struct ReadWrite;
<span class="boring">}</span></code></pre></pre>
<h2 id="application-state"><a class="header" href="#application-state">Application State</a></h2>
<p>Create <code>src/state.rs</code> - this holds our path boundaries and user sessions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, VirtualRoot};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

use crate::markers::{WebAssets, UserUploads, AppConfig};

/// Shared application state passed to all route handlers
#[derive(Clone)]
pub struct AppState {
    /// Path boundary for public web assets
    pub assets: Arc&lt;PathBoundary&lt;WebAssets&gt;&gt;,
    
    /// Path boundary for server configuration
    pub config: Arc&lt;PathBoundary&lt;AppConfig&gt;&gt;,
    
    /// Per-user upload roots (user_id -&gt; VirtualRoot)
    pub user_uploads: Arc&lt;RwLock&lt;HashMap&lt;Uuid, VirtualRoot&lt;UserUploads&gt;&gt;&gt;&gt;,
    
    /// Active user sessions (session_id -&gt; user_id)
    pub sessions: Arc&lt;RwLock&lt;HashMap&lt;String, Uuid&gt;&gt;&gt;,
}

impl AppState {
    /// Create new application state with initialized boundaries
    pub fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Create boundary for public assets
        let assets = PathBoundary::try_new_create("public")?;
        
        // Create boundary for config files
        let config = PathBoundary::try_new_create("config")?;
        
        Ok(Self {
            assets: Arc::new(assets),
            config: Arc::new(config),
            user_uploads: Arc::new(RwLock::new(HashMap::new())),
            sessions: Arc::new(RwLock::new(HashMap::new())),
        })
    }
    
    /// Get or create a VirtualRoot for a specific user
    pub async fn get_user_uploads(
        &amp;self,
        user_id: Uuid,
    ) -&gt; Result&lt;VirtualRoot&lt;UserUploads&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut uploads = self.user_uploads.write().await;
        
        if let Some(vroot) = uploads.get(&amp;user_id) {
            // Return existing user root
            Ok(vroot.clone())
        } else {
            // Create new isolated storage for this user
            let user_dir = format!("uploads/user_{}", user_id);
            let vroot = VirtualRoot::try_new_create(&amp;user_dir)?;
            uploads.insert(user_id, vroot.clone());
            
            tracing::info!("Created upload directory for user {}", user_id);
            Ok(vroot)
        }
    }
    
    /// Create a new user session
    pub async fn create_session(&amp;self, user_id: Uuid) -&gt; String {
        let session_id = Uuid::new_v4().to_string();
        self.sessions.write().await.insert(session_id.clone(), user_id);
        session_id
    }
    
    /// Get user ID from session ID
    pub async fn get_user_from_session(&amp;self, session_id: &amp;str) -&gt; Option&lt;Uuid&gt; {
        self.sessions.read().await.get(session_id).copied()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="main-server-setup"><a class="header" href="#main-server-setup">Main Server Setup</a></h2>
<p>Update <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use axum::{
    Router,
    routing::get,
};
use std::net::SocketAddr;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod markers;
mod state;

use state::AppState;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize tracing
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "file_sharing_service=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    // Initialize application state with security boundaries
    let state = AppState::new()?;
    
    tracing::info!("🔒 Security boundaries initialized:");
    tracing::info!("  - Public assets: {}", state.assets.strictpath_display());
    tracing::info!("  - Config files: {}", state.config.strictpath_display());
    tracing::info!("  - User uploads: uploads/user_&lt;uuid&gt;/");

    // Build our application with routes
    let app = Router::new()
        .route("/", get(root_handler))
        .route("/health", get(health_check))
        .layer(TraceLayer::new_for_http())
        .with_state(state);

    // Run the server
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    tracing::info!("🚀 Server listening on {}", addr);
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}

async fn root_handler() -&gt; &amp;'static str {
    "File Sharing Service - Use /health to check status"
}

async fn health_check() -&gt; &amp;'static str {
    "OK"
}</code></pre></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>Create the initial directory structure:</p>
<pre><code class="language-bash">mkdir -p public/{css,js,images}
mkdir -p config
mkdir -p src/routes
mkdir -p src/middleware
</code></pre>
<p>Create a sample HTML file in <code>public/index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;File Sharing Service&lt;/title&gt;
    &lt;link rel="stylesheet" href="/assets/css/style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;🔐 Secure File Sharing Service&lt;/h1&gt;
    &lt;p&gt;Protected by strict-path security boundaries.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Create <code>public/css/style.css</code>:</p>
<pre><code class="language-css">body {
    font-family: system-ui, -apple-system, sans-serif;
    max-width: 800px;
    margin: 2rem auto;
    padding: 0 1rem;
    background: #f5f5f5;
}

h1 {
    color: #2c3e50;
}
</code></pre>
<h2 id="test-the-server"><a class="header" href="#test-the-server">Test the Server</a></h2>
<p>Run the server:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see:</p>
<pre><code>🔒 Security boundaries initialized:
  - Public assets: public
  - Config files: config
  - User uploads: uploads/user_&lt;uuid&gt;/
🚀 Server listening on 127.0.0.1:3000
</code></pre>
<p>Visit <code>http://localhost:3000/health</code> - you should see "OK".</p>
<h2 id="understanding-the-security-model"><a class="header" href="#understanding-the-security-model">Understanding the Security Model</a></h2>
<p>Let's examine what we've built:</p>
<h3 id="1-separate-boundaries-for-each-context"><a class="header" href="#1-separate-boundaries-for-each-context">1. Separate Boundaries for Each Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub assets: Arc&lt;PathBoundary&lt;WebAssets&gt;&gt;,
pub config: Arc&lt;PathBoundary&lt;AppConfig&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>Each storage area has its own <code>PathBoundary</code> with a different marker type. This means:</p>
<ul>
<li>✅ You <strong>cannot</strong> accidentally serve config files as web assets</li>
<li>✅ You <strong>cannot</strong> write user uploads to the config directory</li>
<li>✅ The compiler <strong>enforces</strong> these boundaries</li>
</ul>
<h3 id="2-per-user-isolated-storage"><a class="header" href="#2-per-user-isolated-storage">2. Per-User Isolated Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub user_uploads: Arc&lt;RwLock&lt;HashMap&lt;Uuid, VirtualRoot&lt;UserUploads&gt;&gt;&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>Each user gets their own <code>VirtualRoot</code>:</p>
<ul>
<li>✅ User A <strong>cannot</strong> access User B's files</li>
<li>✅ Path traversal attacks (<code>../other-user/file.txt</code>) are automatically blocked</li>
<li>✅ Each user sees clean paths starting from <code>/</code></li>
</ul>
<h3 id="3-type-safe-state"><a class="header" href="#3-type-safe-state">3. Type-Safe State</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn get_user_uploads(
    &amp;self,
    user_id: Uuid,
) -&gt; Result&lt;VirtualRoot&lt;UserUploads&gt;, Box&lt;dyn std::error::Error&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p>Functions return typed paths:</p>
<ul>
<li>✅ You know exactly what type of storage you're working with</li>
<li>✅ Can't mix user uploads with web assets</li>
<li>✅ Refactoring is safe - compiler finds all usages</li>
</ul>
<h2 id="whats-next-7"><a class="header" href="#whats-next-7">What's Next?</a></h2>
<p>Now that we have our security boundaries established, we'll implement:</p>
<ol>
<li><strong><a href="axum_tutorial/./chapter2_static_assets.html">Chapter 2: Static Asset Serving</a></strong> - Serve CSS, JS, and images safely</li>
<li>User authentication and session management</li>
<li>File upload system with per-user isolation</li>
<li>File download and listing with authorization</li>
<li>Configuration management and deployment</li>
</ol>
<h2 id="key-takeaways-6"><a class="header" href="#key-takeaways-6">Key Takeaways</a></h2>
<p>✅ <strong>Separate boundaries</strong> - One <code>PathBoundary</code> per storage context<br />
✅ <strong>Type-safe markers</strong> - Compiler prevents context mixing<br />
✅ <strong>Per-user isolation</strong> - <code>VirtualRoot</code> for each user<br />
✅ <strong>Lazy initialization</strong> - User storage created on first access<br />
✅ <strong>Shared state</strong> - <code>Arc&lt;RwLock&lt;&gt;&gt;</code> for thread-safe access</p>
<hr />
<p><strong>Next:</strong> <a href="axum_tutorial/./chapter2_static_assets.html">Chapter 2: Static Asset Serving →</a></p>
<p><strong>Navigation:</strong><br />
← <a href="axum_tutorial/./overview.html">Tutorial Overview</a> | <a href="axum_tutorial/./chapter2_static_assets.html">Chapter 2 →</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-static-asset-serving"><a class="header" href="#chapter-2-static-asset-serving">Chapter 2: Static Asset Serving</a></h1>
<p>Now that we have our security boundaries established, let's implement secure static file serving. We'll serve CSS, JavaScript, and images while preventing path traversal attacks.</p>
<h2 id="the-security-challenge"><a class="header" href="#the-security-challenge">The Security Challenge</a></h2>
<p>Static file servers are a common attack vector:</p>
<ul>
<li>❌ <code>GET /assets/../config/secrets.json</code> - Try to escape to config</li>
<li>❌ <code>GET /assets/../../etc/passwd</code> - Try to access system files</li>
<li>❌ <code>GET /assets/../uploads/user_123/private.pdf</code> - Try to access user files</li>
</ul>
<p>With strict-path, these attacks are <strong>impossible</strong> because the type system enforces boundaries.</p>
<h2 id="create-the-assets-route-handler"><a class="header" href="#create-the-assets-route-handler">Create the Assets Route Handler</a></h2>
<p>Create <code>src/routes/assets.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    extract::{Path, State},
    http::{StatusCode, header},
    response::{IntoResponse, Response},
};
use strict_path::StrictPath;
use crate::markers::WebAssets;
use crate::state::AppState;

/// Serve a static asset file
/// 
/// Security: The PathBoundary&lt;WebAssets&gt; ensures files can ONLY
/// come from the public/ directory. Path traversal attacks are
/// automatically blocked by strict_join().
pub async fn serve_asset(
    State(state): State&lt;AppState&gt;,
    Path(asset_path): Path&lt;String&gt;,
) -&gt; Result&lt;Response, AppError&gt; {
    // Validate the requested path against the assets boundary
    // This is where security happens - strict_join() prevents escapes
    let safe_path: StrictPath&lt;WebAssets&gt; = state.assets
        .strict_join(&amp;asset_path)
        .map_err(|e| {
            tracing::warn!("❌ Blocked path traversal attempt: {}", asset_path);
            AppError::PathTraversal(e.to_string())
        })?;
    
    // Check if file exists
    if !safe_path.exists() {
        tracing::debug!("Asset not found: {}", asset_path);
        return Err(AppError::NotFound);
    }
    
    // Check if it's actually a file (not a directory)
    if !safe_path.is_file() {
        tracing::warn!("Attempted to serve directory as file: {}", asset_path);
        return Err(AppError::NotFound);
    }
    
    // Read the file - safe because path is validated
    let content = read_asset(&amp;safe_path).await?;
    
    // Determine content type from extension
    let content_type = get_content_type(&amp;safe_path);
    
    tracing::debug!("✅ Serving asset: {} ({})", asset_path, content_type);
    
    // Build response with appropriate content-type
    Ok((
        StatusCode::OK,
        [(header::CONTENT_TYPE, content_type)],
        content,
    ).into_response())
}

/// Read asset file - helper enforces WebAssets context
async fn read_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, AppError&gt; {
    tokio::fs::read(path.interop_path())
        .await
        .map_err(|e| AppError::IoError(e.to_string()))
}

/// Determine content-type from file extension
fn get_content_type(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; &amp;'static str {
    match path.strictpath_extension().and_then(|s| s.to_str()) {
        Some("html") =&gt; "text/html; charset=utf-8",
        Some("css") =&gt; "text/css; charset=utf-8",
        Some("js") =&gt; "application/javascript; charset=utf-8",
        Some("json") =&gt; "application/json",
        Some("png") =&gt; "image/png",
        Some("jpg") | Some("jpeg") =&gt; "image/jpeg",
        Some("gif") =&gt; "image/gif",
        Some("svg") =&gt; "image/svg+xml",
        Some("ico") =&gt; "image/x-icon",
        Some("woff") =&gt; "font/woff",
        Some("woff2") =&gt; "font/woff2",
        Some("ttf") =&gt; "font/ttf",
        Some("txt") =&gt; "text/plain; charset=utf-8",
        _ =&gt; "application/octet-stream",
    }
}

/// Application errors with appropriate HTTP status codes
#[derive(Debug)]
pub enum AppError {
    PathTraversal(String),
    NotFound,
    IoError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -&gt; Response {
        let (status, message) = match self {
            AppError::PathTraversal(msg) =&gt; {
                (StatusCode::BAD_REQUEST, format!("Invalid path: {}", msg))
            }
            AppError::NotFound =&gt; {
                (StatusCode::NOT_FOUND, "File not found".to_string())
            }
            AppError::IoError(msg) =&gt; {
                (StatusCode::INTERNAL_SERVER_ERROR, format!("IO error: {}", msg))
            }
        };
        
        (status, message).into_response()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="update-main-router"><a class="header" href="#update-main-router">Update Main Router</a></h2>
<p>Update <code>src/main.rs</code> to include the assets route:</p>
<pre><pre class="playground"><code class="language-rust">use axum::{
    Router,
    routing::get,
};
use std::net::SocketAddr;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod markers;
mod state;
mod routes;

use state::AppState;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize tracing
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "file_sharing_service=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    // Initialize application state with security boundaries
    let state = AppState::new()?;
    
    tracing::info!("🔒 Security boundaries initialized:");
    tracing::info!("  - Public assets: {}", state.assets.strictpath_display());
    tracing::info!("  - Config files: {}", state.config.strictpath_display());

    // Build our application with routes
    let app = Router::new()
        .route("/", get(root_handler))
        .route("/health", get(health_check))
        // Serve static assets - path parameter is validated by strict_join()
        .route("/assets/*path", get(routes::assets::serve_asset))
        .layer(TraceLayer::new_for_http())
        .with_state(state);

    // Run the server
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    tracing::info!("🚀 Server listening on {}", addr);
    
    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}

async fn root_handler() -&gt; &amp;'static str {
    "File Sharing Service - Use /health to check status"
}

async fn health_check() -&gt; &amp;'static str {
    "OK"
}</code></pre></pre>
<p>Create <code>src/routes/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod assets;
<span class="boring">}</span></code></pre></pre>
<h2 id="test-asset-serving"><a class="header" href="#test-asset-serving">Test Asset Serving</a></h2>
<p>Run the server:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="test-valid-paths"><a class="header" href="#test-valid-paths">Test Valid Paths</a></h3>
<pre><code class="language-bash"># Should work - file exists in public/
curl http://localhost:3000/assets/css/style.css

# Should work - subdirectory access
curl http://localhost:3000/assets/images/logo.png
</code></pre>
<h3 id="test-attack-scenarios"><a class="header" href="#test-attack-scenarios">Test Attack Scenarios</a></h3>
<pre><code class="language-bash"># ❌ Try to escape to parent directory
curl http://localhost:3000/assets/../config/secrets.json
# Response: 400 Bad Request - "Invalid path: ..."

# ❌ Try to access system files
curl http://localhost:3000/assets/../../etc/passwd
# Response: 400 Bad Request - "Invalid path: ..."

# ❌ Try to access user uploads
curl http://localhost:3000/assets/../uploads/user_123/file.txt
# Response: 400 Bad Request - "Invalid path: ..."

# ❌ Try absolute path
curl http://localhost:3000/assets//var/log/system.log
# Response: 400 Bad Request - "Invalid path: ..."
</code></pre>
<p>All attacks are automatically blocked! 🎉</p>
<h2 id="understanding-the-security"><a class="header" href="#understanding-the-security">Understanding the Security</a></h2>
<h3 id="1-validation-happens-at-the-boundary"><a class="header" href="#1-validation-happens-at-the-boundary">1. Validation Happens at the Boundary</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let safe_path: StrictPath&lt;WebAssets&gt; = state.assets
    .strict_join(&amp;asset_path)
    .map_err(|e| {
        tracing::warn!("❌ Blocked path traversal attempt: {}", asset_path);
        AppError::PathTraversal(e.to_string())
    })?;
<span class="boring">}</span></code></pre></pre>
<p>This single line provides complete protection:</p>
<ul>
<li><code>strict_join()</code> normalizes the path (resolves <code>..</code>, <code>.</code>, etc.)</li>
<li>Checks if the result is within the <code>public/</code> boundary</li>
<li>Returns an error if the path escapes</li>
</ul>
<h3 id="2-type-safe-helpers"><a class="header" href="#2-type-safe-helpers">2. Type-Safe Helpers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn read_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, AppError&gt; {
    tokio::fs::read(path.interop_path()).await
        .map_err(|e| AppError::IoError(e.to_string()))
}
<span class="boring">}</span></code></pre></pre>
<p>By accepting <code>&amp;StrictPath&lt;WebAssets&gt;</code>, this function:</p>
<ul>
<li>✅ Only accepts validated asset paths</li>
<li>✅ Cannot be called with user uploads or config files</li>
<li>✅ Compiler enforces the security contract</li>
</ul>
<h3 id="3-content-type-based-on-extension"><a class="header" href="#3-content-type-based-on-extension">3. Content-Type Based on Extension</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_content_type(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; &amp;'static str {
    match path.strictpath_extension().and_then(|s| s.to_str()) {
        Some("css") =&gt; "text/css; charset=utf-8",
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We safely use the validated path to determine content-type. No risk of path manipulation here.</p>
<h2 id="why-this-is-better-than-standard-approaches"><a class="header" href="#why-this-is-better-than-standard-approaches">Why This Is Better Than Standard Approaches</a></h2>
<h3 id="-unsafe-string-based-validation"><a class="header" href="#-unsafe-string-based-validation">❌ Unsafe: String-Based Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Don't do this!
async fn serve_asset_unsafe(Path(asset_path): Path&lt;String&gt;) -&gt; Response {
    // Manual validation - easy to get wrong
    if asset_path.contains("..") {
        return (StatusCode::BAD_REQUEST, "Invalid path").into_response();
    }
    
    // Still vulnerable to attacks like:
    // - Encoded paths (%2e%2e%2f)
    // - Symlinks
    // - Case sensitivity issues on Windows
    
    let full_path = format!("public/{}", asset_path);
    let content = tokio::fs::read(&amp;full_path).await.unwrap();
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-safe-type-based-validation"><a class="header" href="#-safe-type-based-validation">✅ Safe: Type-Based Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Do this!
let safe_path: StrictPath&lt;WebAssets&gt; = state.assets.strict_join(&amp;asset_path)?;
let content = read_asset(&amp;safe_path).await?;
<span class="boring">}</span></code></pre></pre>
<p>Strict-path handles:</p>
<ul>
<li>✅ Path normalization (<code>.</code>, <code>..</code>, multiple <code>/</code>)</li>
<li>✅ Symlink resolution</li>
<li>✅ Encoding issues</li>
<li>✅ Case sensitivity</li>
<li>✅ Platform differences</li>
</ul>
<h2 id="adding-more-assets"><a class="header" href="#adding-more-assets">Adding More Assets</a></h2>
<p>Create some sample files to serve:</p>
<pre><code class="language-bash"># Create a JavaScript file
cat &gt; public/js/app.js &lt;&lt; 'EOF'
console.log('File sharing service initialized');
document.addEventListener('DOMContentLoaded', () =&gt; {
    console.log('DOM loaded - ready to upload files');
});
EOF

# Create an image (placeholder)
echo "Sample image data" &gt; public/images/logo.png

# Create a robots.txt
cat &gt; public/robots.txt &lt;&lt; 'EOF'
User-agent: *
Disallow: /uploads/
EOF
</code></pre>
<p>Test them:</p>
<pre><code class="language-bash">curl http://localhost:3000/assets/js/app.js
curl http://localhost:3000/assets/robots.txt
</code></pre>
<h2 id="handling-index-files"><a class="header" href="#handling-index-files">Handling Index Files</a></h2>
<p>Want to serve <code>index.html</code> when accessing <code>/assets/</code>? Update the route handler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn serve_asset(
    State(state): State&lt;AppState&gt;,
    Path(asset_path): Path&lt;String&gt;,
) -&gt; Result&lt;Response, AppError&gt; {
    // If path ends with /, append index.html
    let request_path = if asset_path.ends_with('/') || asset_path.is_empty() {
        format!("{}index.html", asset_path)
    } else {
        asset_path
    };
    
    let safe_path: StrictPath&lt;WebAssets&gt; = state.assets
        .strict_join(&amp;request_path)
        .map_err(|e| {
            tracing::warn!("❌ Blocked path traversal attempt: {}", request_path);
            AppError::PathTraversal(e.to_string())
        })?;
    
    // ... rest of the function
}
<span class="boring">}</span></code></pre></pre>
<p>Now <code>http://localhost:3000/assets/</code> serves <code>public/index.html</code>!</p>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<p>For production, consider adding caching headers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::http::header;

pub async fn serve_asset(
    // ... parameters
) -&gt; Result&lt;Response, AppError&gt; {
    // ... validation and reading
    
    // Add cache headers for static assets
    let cache_control = if is_immutable_asset(&amp;safe_path) {
        "public, max-age=31536000, immutable"  // 1 year for versioned assets
    } else {
        "public, max-age=3600"  // 1 hour for other assets
    };
    
    Ok((
        StatusCode::OK,
        [
            (header::CONTENT_TYPE, content_type),
            (header::CACHE_CONTROL, cache_control),
        ],
        content,
    ).into_response())
}

fn is_immutable_asset(path: &amp;StrictPath&lt;WebAssets&gt;) -&gt; bool {
    // Check if filename contains hash (e.g., app-abc123.js)
    path.strictpath_file_name()
        .and_then(|n| n.to_str())
        .map(|n| n.contains('-') &amp;&amp; n.split('-').nth(1).is_some())
        .unwrap_or(false)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways-7"><a class="header" href="#key-takeaways-7">Key Takeaways</a></h2>
<p>✅ <strong>Single validation point</strong> - <code>strict_join()</code> handles all path security<br />
✅ <strong>Type-safe helpers</strong> - Functions accept <code>StrictPath&lt;WebAssets&gt;</code> only<br />
✅ <strong>Automatic attack blocking</strong> - No manual checks needed<br />
✅ <strong>Clear error handling</strong> - Failed validation returns appropriate HTTP errors<br />
✅ <strong>Content-type safety</strong> - Based on validated path extension</p>
<h2 id="whats-next-8"><a class="header" href="#whats-next-8">What's Next?</a></h2>
<p>Now that we can serve static assets securely, let's add user authentication:</p>
<p><strong><a href="axum_tutorial/./chapter3_authentication.html">Chapter 3: User Authentication →</a></strong></p>
<p>In the next chapter, we'll:</p>
<ul>
<li>Implement simple session-based authentication</li>
<li>Create per-user <code>VirtualRoot</code> instances</li>
<li>Use authorization markers with <code>change_marker()</code></li>
<li>Protect routes with middleware</li>
</ul>
<hr />
<p><strong>Navigation:</strong><br />
<a href="axum_tutorial/./chapter1_setup.html">← Chapter 1</a> | <a href="axum_tutorial/./overview.html">Tutorial Overview</a> | <a href="axum_tutorial/./chapter3_authentication.html">Chapter 3 →</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-per-user-storage-with-virtualroot"><a class="header" href="#chapter-3-per-user-storage-with-virtualroot">Chapter 3: Per-User Storage with VirtualRoot</a></h1>
<p>This chapter shows how to isolate user file storage using <code>VirtualRoot&lt;UserUploads&gt;</code>. Each user gets their own virtual filesystem that cannot access other users' files.</p>
<h2 id="the-problem-user-isolation"><a class="header" href="#the-problem-user-isolation">The Problem: User Isolation</a></h2>
<p>Without proper isolation, users could access each other's files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ UNSAFE: Users can escape their directory
let user_file = format!("./uploads/{}/{}", user_id, filename);
// User sends filename="../other_user/secret.txt"
<span class="boring">}</span></code></pre></pre>
<h2 id="the-solution-virtualroot-per-user"><a class="header" href="#the-solution-virtualroot-per-user">The Solution: VirtualRoot Per User</a></h2>
<p><code>VirtualRoot</code> creates an isolated view where paths are relative to the user's directory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ SAFE: Isolated per-user virtual filesystem
let user_root = VirtualRoot::&lt;UserUploads&gt;::try_new(
    format!("./uploads/user_{user_id}")
)?;

// User's paths are always within their root
let file = user_root.virtual_join(filename)?; // Can't escape!
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-file-upload-handler"><a class="header" href="#implementation-file-upload-handler">Implementation: File Upload Handler</a></h2>
<p>Create <code>src/routes/upload.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    extract::{Multipart, Path, State},
    http::StatusCode,
    response::IntoResponse,
};
use strict_path::VirtualRoot;
use crate::{markers::UserUploads, state::AppState, error::AppError};

/// Handle file upload for authenticated user
pub async fn upload_file(
    State(state): State&lt;AppState&gt;,
    Path(user_id): Path&lt;String&gt;,
    mut multipart: Multipart,
) -&gt; Result&lt;impl IntoResponse, AppError&gt; {
    // Get or create user's virtual root
    let user_root = state.get_user_root(&amp;user_id)?;

    while let Some(field) = multipart.next_field().await? {
        let filename = field
            .file_name()
            .ok_or(AppError::MissingFilename)?
            .to_string();

        // SECURITY: virtual_join validates filename
        // Rejects: "../", absolute paths, special chars
        let file_path = user_root
            .virtual_join(&amp;filename)
            .map_err(|_| AppError::InvalidFilename)?;

        let data = field.bytes().await?;
        
        // Safe: file_path is guaranteed within user's boundary
        file_path.write(data.as_ref())?;
    }

    Ok(StatusCode::CREATED)
}

/// List files in user's directory
pub async fn list_files(
    State(state): State&lt;AppState&gt;,
    Path(user_id): Path&lt;String&gt;,
) -&gt; Result&lt;impl IntoResponse, AppError&gt; {
    let user_root = state.get_user_root(&amp;user_id)?;
    
    // Convert to StrictPath to read directory
    let root_dir = user_root.as_unvirtual();
    let entries = root_dir.read_dir()?;

    let files: Vec&lt;String&gt; = entries
        .filter_map(|e| e.ok())
        .filter_map(|e| e.file_name().into_string().ok())
        .collect();

    Ok(axum::Json(files))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="update-appstate"><a class="header" href="#update-appstate">Update AppState</a></h2>
<p>Modify <code>src/state.rs</code> to manage per-user roots:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use strict_path::{PathBoundary, VirtualRoot};
use crate::markers::{WebAssets, UserUploads, AppConfig};

pub struct AppState {
    pub assets: PathBoundary&lt;WebAssets&gt;,
    pub config: PathBoundary&lt;AppConfig&gt;,
    uploads_base: PathBoundary&lt;UserUploads&gt;,
    // Cache of user virtual roots
    user_roots: Arc&lt;RwLock&lt;HashMap&lt;String, VirtualRoot&lt;UserUploads&gt;&gt;&gt;&gt;,
}

impl AppState {
    pub fn new() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        Ok(Self {
            assets: PathBoundary::try_new_create("./data/assets")?,
            config: PathBoundary::try_new("./data/config")?,
            uploads_base: PathBoundary::try_new_create("./data/uploads")?,
            user_roots: Arc::new(RwLock::new(HashMap::new())),
        })
    }

    /// Get or create virtual root for user
    pub fn get_user_root(
        &amp;self,
        user_id: &amp;str,
    ) -&gt; Result&lt;VirtualRoot&lt;UserUploads&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        // Check cache first
        {
            let cache = self.user_roots.read().unwrap();
            if let Some(root) = cache.get(user_id) {
                return Ok(root.clone());
            }
        }

        // Create new user directory and virtual root
        let user_dir = self.uploads_base.strict_join(user_id)?;
        user_dir.create_dir_all()?;

        let vroot = VirtualRoot::try_new(user_dir.interop_path())?;

        // Cache it
        self.user_roots.write().unwrap().insert(user_id.to_string(), vroot.clone());

        Ok(vroot)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="register-routes"><a class="header" href="#register-routes">Register Routes</a></h2>
<p>Update <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">mod routes {
    pub mod assets;
    pub mod upload;
}

use axum::{
    routing::{get, post},
    Router,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let state = AppState::new()?;

    let app = Router::new()
        .route("/assets/*path", get(routes::assets::serve_asset))
        .route("/users/:user_id/files", post(routes::upload::upload_file))
        .route("/users/:user_id/files", get(routes::upload::list_files))
        .with_state(state);

    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000").await?;
    println!("Server running on http://127.0.0.1:3000");
    
    axum::serve(listener, app).await?;
    Ok(())
}</code></pre></pre>
<h2 id="key-security-properties"><a class="header" href="#key-security-properties">Key Security Properties</a></h2>
<ol>
<li><strong>User Isolation</strong>: Each <code>VirtualRoot</code> is scoped to one user's directory</li>
<li><strong>Path Validation</strong>: <code>virtual_join()</code> prevents directory traversal</li>
<li><strong>Type Safety</strong>: <code>VirtualRoot&lt;UserUploads&gt;</code> can't mix with <code>PathBoundary&lt;WebAssets&gt;</code></li>
<li><strong>Automatic Caching</strong>: User roots are cached for performance</li>
</ol>
<h2 id="testing-the-isolation"><a class="header" href="#testing-the-isolation">Testing the Isolation</a></h2>
<pre><code class="language-bash"># Upload to user_001
curl -F "file=@test.txt" http://localhost:3000/users/user_001/files

# Try to access user_002's files (will fail)
curl -F "file=@../user_002/secret.txt" http://localhost:3000/users/user_001/files
# Returns 400: InvalidFilename

# List user_001's files (only shows their files)
curl http://localhost:3000/users/user_001/files
</code></pre>
<h2 id="what-we-learned"><a class="header" href="#what-we-learned">What We Learned</a></h2>
<ul>
<li><code>VirtualRoot</code> provides per-user filesystem isolation</li>
<li><code>virtual_join()</code> validates filenames and prevents escapes</li>
<li>AppState can manage multiple virtual roots efficiently</li>
<li>Type markers prevent accidentally mixing user storage with other boundaries</li>
</ul>
<hr />
<p><strong>Navigation:</strong><br />
<a href="axum_tutorial/./chapter2_static_assets.html">← Chapter 2</a> | <a href="axum_tutorial/./overview.html">Tutorial Overview</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os-standard-directories"><a class="header" href="#os-standard-directories">OS Standard Directories</a></h1>
<blockquote>
<p><strong>Feature</strong>: <code>dirs</code> - Enable with <code>features = ["dirs"]</code> in your <code>Cargo.toml</code></p>
</blockquote>
<p>The <code>strict-path</code> crate provides seamless integration with operating system standard directories through the <a href="https://crates.io/crates/dirs"><code>dirs</code></a> crate. This enables cross-platform applications to securely access user and system directories like configuration, data storage, cache, and user content locations.</p>
<p><strong>Quick Start:</strong></p>
<pre><code class="language-toml">[dependencies]
strict-path = { version = "0.1.0-beta.2", features = ["dirs"] }
</code></pre>
<h2 id="cross-platform-standards"><a class="header" href="#cross-platform-standards">Cross-Platform Standards</a></h2>
<p>The integration follows established cross-platform directory standards:</p>
<h3 id="linux-xdg-base-directory-specification"><a class="header" href="#linux-xdg-base-directory-specification">Linux (XDG Base Directory Specification)</a></h3>
<ul>
<li><strong>Config</strong>: <code>$XDG_CONFIG_HOME</code> or <code>~/.config</code></li>
<li><strong>Data</strong>: <code>$XDG_DATA_HOME</code> or <code>~/.local/share</code></li>
<li><strong>Cache</strong>: <code>$XDG_CACHE_HOME</code> or <code>~/.cache</code></li>
<li><strong>Runtime</strong>: <code>$XDG_RUNTIME_DIR</code> or <code>/tmp</code></li>
</ul>
<h3 id="windows-known-folder-api"><a class="header" href="#windows-known-folder-api">Windows (Known Folder API)</a></h3>
<ul>
<li><strong>Config</strong>: <code>%APPDATA%</code> (Roaming)</li>
<li><strong>Data</strong>: <code>%APPDATA%</code> (Roaming)</li>
<li><strong>Cache</strong>: <code>%LOCALAPPDATA%</code></li>
<li><strong>Local Config</strong>: <code>%LOCALAPPDATA%</code></li>
<li><strong>Local Data</strong>: <code>%LOCALAPPDATA%</code></li>
</ul>
<h3 id="macos-apple-standard-directories"><a class="header" href="#macos-apple-standard-directories">macOS (Apple Standard Directories)</a></h3>
<ul>
<li><strong>Config</strong>: <code>~/Library/Application Support</code></li>
<li><strong>Data</strong>: <code>~/Library/Application Support</code></li>
<li><strong>Cache</strong>: <code>~/Library/Caches</code></li>
</ul>
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<p>Both <code>PathBoundary</code> and <code>VirtualRoot</code> provide comprehensive OS directory constructors:</p>
<h3 id="application-directories"><a class="header" href="#application-directories">Application Directories</a></h3>
<h4 id="try_new_os_configapp_name-str"><a class="header" href="#try_new_os_configapp_name-str"><code>try_new_os_config(app_name: &amp;str)</code></a></h4>
<p>Creates a secure boundary for application configuration storage.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

let config_dir = PathBoundary::&lt;()&gt;::try_new_os_config("MyApp")?;
let config_file = config_dir.strict_join("settings.json")?;
config_file.write(r#"{"theme": "dark"}"#)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Platform paths:</strong></p>
<ul>
<li>Linux: <code>~/.config/MyApp/</code></li>
<li>Windows: <code>%APPDATA%/MyApp/</code></li>
<li>macOS: <code>~/Library/Application Support/MyApp/</code></li>
</ul>
<h4 id="try_new_os_dataapp_name-str"><a class="header" href="#try_new_os_dataapp_name-str"><code>try_new_os_data(app_name: &amp;str)</code></a></h4>
<p>Creates a secure boundary for application data storage.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data_dir = PathBoundary::&lt;()&gt;::try_new_os_data("MyApp")?;
let database = data_dir.strict_join("app.db")?;
database.write(b"SQLite database content")?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Platform paths:</strong></p>
<ul>
<li>Linux: <code>~/.local/share/MyApp/</code></li>
<li>Windows: <code>%APPDATA%/MyApp/</code></li>
<li>macOS: <code>~/Library/Application Support/MyApp/</code></li>
</ul>
<h4 id="try_new_os_cacheapp_name-str"><a class="header" href="#try_new_os_cacheapp_name-str"><code>try_new_os_cache(app_name: &amp;str)</code></a></h4>
<p>Creates a secure boundary for application cache storage.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cache_dir = PathBoundary::&lt;()&gt;::try_new_os_cache("MyApp")?;
let thumbnail_cache = cache_dir.strict_join("thumbnails/")?;
thumbnail_cache.create_dir_all()?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Platform paths:</strong></p>
<ul>
<li>Linux: <code>~/.cache/MyApp/</code></li>
<li>Windows: <code>%LOCALAPPDATA%/MyApp/</code></li>
<li>macOS: <code>~/Library/Caches/MyApp/</code></li>
</ul>
<h3 id="platform-specific-directories"><a class="header" href="#platform-specific-directories">Platform-Specific Directories</a></h3>
<h4 id="try_new_os_config_localapp_name-str-windowslinux-only"><a class="header" href="#try_new_os_config_localapp_name-str-windowslinux-only"><code>try_new_os_config_local(app_name: &amp;str)</code> (Windows/Linux only)</a></h4>
<p>Creates a local (non-roaming) config directory boundary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(any(target_os = "windows", target_os = "linux"))]
let local_config = PathBoundary::&lt;()&gt;::try_new_os_config_local("MyApp")?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Platform paths:</strong></p>
<ul>
<li>Linux: <code>~/.config/MyApp/</code> (same as config)</li>
<li>Windows: <code>%LOCALAPPDATA%/MyApp/</code> (non-roaming)</li>
<li>macOS: Not available (returns <code>Err</code>)</li>
</ul>
<h4 id="try_new_os_data_localapp_name-str-windowslinux-only"><a class="header" href="#try_new_os_data_localapp_name-str-windowslinux-only"><code>try_new_os_data_local(app_name: &amp;str)</code> (Windows/Linux only)</a></h4>
<p>Creates a local (non-roaming) data directory boundary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(any(target_os = "windows", target_os = "linux"))]
let local_data = PathBoundary::&lt;()&gt;::try_new_os_data_local("MyApp")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="user-content-directories"><a class="header" href="#user-content-directories">User Content Directories</a></h3>
<h4 id="standard-user-folders"><a class="header" href="#standard-user-folders">Standard User Folders</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// User's home directory
let home_dir = PathBoundary::&lt;()&gt;::try_new_os_home()?;

// Desktop folder
let desktop_dir = PathBoundary::&lt;()&gt;::try_new_os_desktop()?;

// Documents folder  
let documents_dir = PathBoundary::&lt;()&gt;::try_new_os_documents()?;

// Downloads folder
let downloads_dir = PathBoundary::&lt;()&gt;::try_new_os_downloads()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="media-directories"><a class="header" href="#media-directories">Media Directories</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pictures/Photos
let pictures_dir = PathBoundary::&lt;()&gt;::try_new_os_pictures()?;

// Music/Audio files
let audio_dir = PathBoundary::&lt;()&gt;::try_new_os_audio()?;

// Videos/Movies
let videos_dir = PathBoundary::&lt;()&gt;::try_new_os_videos()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="system-directories"><a class="header" href="#system-directories">System Directories</a></h3>
<h4 id="try_new_os_executables-unix-only"><a class="header" href="#try_new_os_executables-unix-only"><code>try_new_os_executables()</code> (Unix only)</a></h4>
<p>Creates a boundary for user executable binaries.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(unix)]
let bin_dir = PathBoundary::&lt;()&gt;::try_new_os_executables()?;
// Typically ~/.local/bin on Linux
<span class="boring">}</span></code></pre></pre>
<h4 id="try_new_os_runtime-unix-only"><a class="header" href="#try_new_os_runtime-unix-only"><code>try_new_os_runtime()</code> (Unix only)</a></h4>
<p>Creates a boundary for runtime files like sockets and PIDs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(unix)]
let runtime_dir = PathBoundary::&lt;()&gt;::try_new_os_runtime()?;
// Uses $XDG_RUNTIME_DIR or falls back to /tmp
<span class="boring">}</span></code></pre></pre>
<h4 id="try_new_os_state-linux-only"><a class="header" href="#try_new_os_state-linux-only"><code>try_new_os_state()</code> (Linux only)</a></h4>
<p>Creates a boundary for application state data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = "linux")]
let state_dir = PathBoundary::&lt;()&gt;::try_new_os_state("MyApp")?;
// Uses $XDG_STATE_HOME or ~/.local/state/MyApp
<span class="boring">}</span></code></pre></pre>
<h2 id="virtual-root-integration"><a class="header" href="#virtual-root-integration">Virtual Root Integration</a></h2>
<p>All OS directory constructors are available on <code>VirtualRoot</code> as well:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualRoot;

// Create virtual root for user documents
let docs_root = VirtualRoot::&lt;()&gt;::try_new_os_documents()?;

// User sees clean virtual paths, system handles real location
let project_file = docs_root.virtual_join("projects/my-app/notes.txt")?;
println!("Virtual path: {}", project_file.virtualpath_display());
// Output: "/projects/my-app/notes.txt"

println!("Real path: {}", project_file.as_unvirtual().strictpath_display());
// Output: "/home/user/Documents/projects/my-app/notes.txt" (Linux example)
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-application-example"><a class="header" href="#complete-application-example">Complete Application Example</a></h2>
<p>Here's a realistic media organizer application demonstrating the OS directories integration:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::{PathBoundary, VirtualRoot};
use std::collections::HashMap;

#[derive(Debug)]
struct MediaOrganizerApp {
    config_dir: PathBoundary&lt;()&gt;,
    data_dir: PathBoundary&lt;()&gt;,
    cache_dir: PathBoundary&lt;()&gt;,
}

impl MediaOrganizerApp {
    fn new(app_name: &amp;str) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        // Initialize with OS standard directories
        let config_dir = PathBoundary::&lt;()&gt;::try_new_os_config(app_name)?;
        let data_dir = PathBoundary::&lt;()&gt;::try_new_os_data(app_name)?;
        let cache_dir = PathBoundary::&lt;()&gt;::try_new_os_cache(app_name)?;
        
        println!("📁 Config: {}", config_dir.strictpath_display());
        println!("💾 Data: {}", data_dir.strictpath_display());
        println!("🗄️ Cache: {}", cache_dir.strictpath_display());
        
        Ok(Self { config_dir, data_dir, cache_dir })
    }
    
    fn scan_user_media(&amp;self) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Access standard user media directories securely
        let media_directories = vec![
            ("Pictures", PathBoundary::&lt;()&gt;::try_new_os_pictures()?),
            ("Music", PathBoundary::&lt;()&gt;::try_new_os_audio()?),
            ("Videos", PathBoundary::&lt;()&gt;::try_new_os_videos()?),
            ("Downloads", PathBoundary::&lt;()&gt;::try_new_os_downloads()?),
        ];
        
        for (dir_name, dir_path) in media_directories {
            println!("📂 Scanning {}: {}", dir_name, dir_path.strictpath_display());
            
            // In a real app, recursively scan for media files
            // All file operations stay within secure boundaries
            if dir_path.exists() {
                println!("   ✅ Directory accessible and secure");
            }
        }
        
        Ok(())
    }
    
    fn manage_cache(&amp;self) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // Create cache subdirectories securely
        let thumbnails_dir = self.cache_dir.strict_join("thumbnails")?;
        let metadata_dir = self.cache_dir.strict_join("metadata")?;
        
        thumbnails_dir.create_dir_all()?;
        metadata_dir.create_dir_all()?;
        
        println!("🖼️ Thumbnails: {}", thumbnails_dir.strictpath_display());
        println!("📝 Metadata: {}", metadata_dir.strictpath_display());
        
        Ok(())
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = MediaOrganizerApp::new("MediaOrganizer")?;
    app.scan_user_media()?;
    app.manage_cache()?;
    Ok(())
}</code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>OS directory functions return <code>StrictPathError</code> when:</p>
<ul>
<li>The directory doesn't exist and cannot be created</li>
<li>Permission denied accessing the directory</li>
<li>The OS doesn't support the requested directory type</li>
<li>Invalid characters in the application name</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPathError};

match PathBoundary::&lt;()&gt;::try_new_os_config("My App") {
    Ok(config_dir) =&gt; println!("Config: {}", config_dir.strictpath_display()),
    Err(StrictPathError::PathResolutionError(msg)) =&gt; {
        eprintln!("Failed to resolve config directory: {}", msg);
    }
    Err(e) =&gt; eprintln!("Other error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="platform-compatibility"><a class="header" href="#platform-compatibility">Platform Compatibility</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Linux</th><th>Windows</th><th>macOS</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>try_new_os_config</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_data</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_cache</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_config_local</code></td><td>✅</td><td>✅</td><td>❌</td><td>Returns error on macOS</td></tr>
<tr><td><code>try_new_os_data_local</code></td><td>✅</td><td>✅</td><td>❌</td><td>Returns error on macOS</td></tr>
<tr><td><code>try_new_os_home</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_desktop</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_documents</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_downloads</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_pictures</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_audio</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_videos</code></td><td>✅</td><td>✅</td><td>✅</td><td></td></tr>
<tr><td><code>try_new_os_executables</code></td><td>✅</td><td>❌</td><td>✅</td><td>Unix only</td></tr>
<tr><td><code>try_new_os_runtime</code></td><td>✅</td><td>❌</td><td>✅</td><td>Unix only</td></tr>
<tr><td><code>try_new_os_state</code></td><td>✅</td><td>❌</td><td>❌</td><td>Linux only</td></tr>
</tbody></table>
</div>
<h2 id="integration-with-dirs-crate"><a class="header" href="#integration-with-dirs-crate">Integration with <code>dirs</code> Crate</a></h2>
<p>This feature integrates with the <a href="https://github.com/dirs-dev/dirs-rs"><code>dirs</code></a> crate v6.0.0, which provides the underlying OS directory discovery. The <code>strict-path</code> crate adds:</p>
<ul>
<li><strong>Security</strong>: All directory access happens within <code>PathBoundary</code> restrictions</li>
<li><strong>Type Safety</strong>: Compile-time guarantees about directory boundaries</li>
<li><strong>Symlink Safety</strong>: Safe resolution of symbolic links and junctions</li>
<li><strong>Cross-Platform</strong>: Consistent API across Windows, macOS, and Linux</li>
<li><strong>Application Scoping</strong>: Automatic subdirectory creation for app-specific storage</li>
</ul>
<h3 id="relationship-to-dirs-functions"><a class="header" href="#relationship-to-dirs-functions">Relationship to <code>dirs</code> Functions</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>strict-path</code> Method</th><th><code>dirs</code> Function</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>try_new_os_config</code></td><td><code>dirs::config_dir()</code> + join</td><td>App config storage</td></tr>
<tr><td><code>try_new_os_data</code></td><td><code>dirs::data_dir()</code> + join</td><td>App data storage</td></tr>
<tr><td><code>try_new_os_cache</code></td><td><code>dirs::cache_dir()</code> + join</td><td>App cache storage</td></tr>
<tr><td><code>try_new_os_config_local</code></td><td><code>dirs::config_local_dir()</code> + join</td><td>Local config (non-roaming)</td></tr>
<tr><td><code>try_new_os_data_local</code></td><td><code>dirs::data_local_dir()</code> + join</td><td>Local data (non-roaming)</td></tr>
<tr><td><code>try_new_os_home</code></td><td><code>dirs::home_dir()</code></td><td>User home directory</td></tr>
<tr><td><code>try_new_os_desktop</code></td><td><code>dirs::desktop_dir()</code></td><td>Desktop folder</td></tr>
<tr><td><code>try_new_os_documents</code></td><td><code>dirs::document_dir()</code></td><td>Documents folder</td></tr>
<tr><td><code>try_new_os_downloads</code></td><td><code>dirs::download_dir()</code></td><td>Downloads folder</td></tr>
<tr><td><code>try_new_os_pictures</code></td><td><code>dirs::picture_dir()</code></td><td>Pictures folder</td></tr>
<tr><td><code>try_new_os_audio</code></td><td><code>dirs::audio_dir()</code></td><td>Music/Audio folder</td></tr>
<tr><td><code>try_new_os_videos</code></td><td><code>dirs::video_dir()</code></td><td>Videos folder</td></tr>
<tr><td><code>try_new_os_executables</code></td><td><code>dirs::executable_dir()</code></td><td>User binaries (Unix)</td></tr>
<tr><td><code>try_new_os_runtime</code></td><td><code>dirs::runtime_dir()</code></td><td>Runtime files (Unix)</td></tr>
<tr><td><code>try_new_os_state</code></td><td><code>dirs::state_dir()</code> + join</td><td>State data (Linux)</td></tr>
</tbody></table>
</div>
<p>For more details on the underlying directory locations, see the <a href="https://docs.rs/dirs/"><code>dirs</code> crate documentation</a>.</p>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="1-application-naming"><a class="header" href="#1-application-naming">1. Application Naming</a></h3>
<p>Use consistent, filesystem-safe application names:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good
let config = PathBoundary::&lt;()&gt;::try_new_os_config("MyApp")?;

// Avoid special characters that might cause issues
let config = PathBoundary::&lt;()&gt;::try_new_os_config("My App &amp; Tools")?; // Risky
<span class="boring">}</span></code></pre></pre>
<h3 id="2-graceful-fallbacks"><a class="header" href="#2-graceful-fallbacks">2. Graceful Fallbacks</a></h3>
<p>Handle platform-specific directories gracefully:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Try platform-specific first, fall back to generic
let data_dir = PathBoundary::&lt;()&gt;::try_new_os_data_local("MyApp")
    .or_else(|_| PathBoundary::&lt;()&gt;::try_new_os_data("MyApp"))?;
<span class="boring">}</span></code></pre></pre>
<h3 id="3-directory-creation"><a class="header" href="#3-directory-creation">3. Directory Creation</a></h3>
<p>Create application subdirectories as needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_dir = PathBoundary::&lt;()&gt;::try_new_os_config("MyApp")?;
let themes_dir = config_dir.strict_join("themes")?;
themes_dir.create_dir_all()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="4-cross-platform-testing"><a class="header" href="#4-cross-platform-testing">4. Cross-Platform Testing</a></h3>
<p>Test your application on all target platforms to verify directory behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_config_directory_creation() {
        let config_dir = PathBoundary::&lt;()&gt;::try_new_os_config("TestApp").unwrap();
        assert!(config_dir.exists() || config_dir.create_dir_all().is_ok());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="./examples.html">Real-World Examples</a> - Complete application examples</li>
<li><a href="./chapter_1.html">Getting Started</a> - Basic <code>strict-path</code> concepts</li>
<li><a href="https://crates.io/crates/dirs"><code>dirs</code> crate</a> - Underlying OS directory library</li>
<li><a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG Base Directory Specification</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid">Windows Known Folder API</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices--guidelines"><a class="header" href="#best-practices--guidelines">Best Practices &amp; Guidelines</a></h1>
<blockquote>
<p><em>Your complete guide to using strict-path correctly and ergonomically.</em></p>
</blockquote>
<p>This page provides the <strong>essential decision matrices, core principles, and quick references</strong> for daily use. For deeper dives, we've split detailed content into focused chaptersâ€”each covering a single topic so you can digest one concept at a time.</p>
<hr />
<h2 id="ðŸš-focused-chapters-deep-dives"><a class="header" href="#ðŸš-focused-chapters-deep-dives">ðŸ“š Focused Chapters (Deep Dives)</a></h2>
<p>For detailed explanations and comprehensive examples, see these focused chapters:</p>
<ul>
<li><strong><a href="./best_practices/why_naive_approaches_fail.html">Why Naive Approaches Fail â†’</a></strong> - The 5 broken approaches and why path security is hard</li>
<li><strong><a href="./best_practices/real_world_patterns.html">Real-World Patterns â†’</a></strong> - Production-ready examples you can copy-paste (LLM agents, archives, web servers, config, multi-tenant)</li>
<li><strong><a href="./best_practices/common_operations.html">Common Operations â†’</a></strong> - Complete reference for joins, parents, renames, deletion, metadata, copy operations</li>
<li><strong><a href="./best_practices/policy_and_reuse.html">Policy &amp; Reuse â†’</a></strong> - When to use VirtualRoot/PathBoundary types vs sugar constructors (performance, testing, serde)</li>
<li><strong><a href="./best_practices/authorization_architecture.html">Authorization Architecture â†’</a></strong> - Compile-time authorization with marker types (basic auth, permissions, dynamic elevation)</li>
</ul>
<p><strong>Start here for fundamentals, then jump to focused chapters when you need details.</strong></p>
<hr />
<h2 id="why-strict-path-exists-tldr"><a class="header" href="#why-strict-path-exists-tldr">Why strict-path Exists (TL;DR)</a></h2>
<p><strong>Path security isn't one problemâ€”it's a class of interacting problems.</strong> Every "simple" approach (check for <code>../</code>, canonicalize then check, normalize, allowlist chars, combine checks) creates new attack surface:</p>
<ul>
<li>Encoding bypasses (URL encoding, double encoding, Unicode normalization)</li>
<li>Race conditions (TOCTOU with symlinks: CVE-2022-21658)</li>
<li>Platform gaps (Windows 8.3 names, UNC paths, ADS: CVE-2019-9855, CVE-2017-17793)</li>
<li>Performance costs (repeated filesystem calls)</li>
<li>Future CVEs (new attack vectors require updating every check)</li>
</ul>
<p><strong>strict-path solved this problem class once, correctly, so you don't have to.</strong></p>
<p>â†’ <strong><a href="./best_practices/why_naive_approaches_fail.html">Full analysis with CVE examples â†’</a></strong></p>
<hr />
<h2 id="pick-the-right-type-quick-reference"><a class="header" href="#pick-the-right-type-quick-reference">Pick The Right Type (Quick Reference)</a></h2>
<h3 id="30-second-decision-guide"><a class="header" href="#30-second-decision-guide">30-Second Decision Guide</a></h3>
<p><strong>External/untrusted segments</strong> (HTTP, DB, manifests, LLM output, archive entries):</p>
<ul>
<li><strong>Detection (90% of cases):</strong> <code>StrictPath::with_boundary(..).strict_join(..)</code> â€” detects escapes, rejects attacks</li>
<li><strong>Containment (10% of cases):</strong> <code>VirtualPath::with_root(..).virtual_join(..)</code> â€” silently clamps escapes, isolates users</li>
</ul>
<p><strong>Internal/trusted paths</strong> (hardcoded, CLI, env): Use <code>Path</code>/<code>PathBuf</code>; only validate when combining with untrusted segments.</p>
<p><strong>For policy reuse across many joins:</strong> Keep a <code>PathBoundary</code> or <code>VirtualRoot</code> and call <code>strict_join(..)</code>/<code>virtual_join(..)</code> repeatedly.</p>
<h3 id="decision-matrix-by-source"><a class="header" href="#decision-matrix-by-source">Decision Matrix by Source</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Source</th><th>Typical Input</th><th>Default Choice</th><th>Notes</th></tr></thead><tbody>
<tr><td>ðŸŒ <strong>HTTP/Web</strong></td><td>URL segments, form fields</td><td>VirtualPath or StrictPath</td><td>VirtualPath for UI display, StrictPath for system I/O</td></tr>
<tr><td>âš™ï¸ <strong>Config/DB</strong></td><td>Paths in config/database</td><td>StrictPath</td><td>Storage â‰  safety; validate on use</td></tr>
<tr><td>ðŸ“‚ <strong>CLI/External APIs</strong></td><td>Args, webhooks, payloads</td><td>StrictPath</td><td>Never trust external input</td></tr>
<tr><td>ðŸ¤– <strong>LLM/AI</strong></td><td>Generated paths/filenames</td><td>StrictPath</td><td>LLM output is untrusted by default</td></tr>
<tr><td>ðŸ“¦ <strong>Archives</strong></td><td>ZIP/TAR entry names</td><td><strong>StrictPath ONLY</strong></td><td>Detect malicious paths, reject bad archives</td></tr>
<tr><td>ðŸ¢ <strong>Multi-tenant</strong></td><td>Per-user file operations</td><td>VirtualPath</td><td>Isolate users with virtual roots</td></tr>
</tbody></table>
</div>
<h3 id="security-philosophy-detect-vs-contain"><a class="header" href="#security-philosophy-detect-vs-contain">Security Philosophy: Detect vs. Contain</a></h3>
<p><strong>The fundamental distinction: Are path escapes attacks or expected behavior?</strong></p>
<h4 id="strictpath-â-detect--reject-default-90"><a class="header" href="#strictpath-â-detect--reject-default-90">StrictPath â€” Detect &amp; Reject (Default, 90%)</a></h4>
<ul>
<li><strong>Philosophy</strong>: "If it tries to escape, I want to know"</li>
<li><strong>Returns:</strong> <code>Err(PathEscapesBoundary)</code> on escape attempts</li>
<li><strong>Use for:</strong> Archives, file uploads, config loading, security boundaries</li>
<li><strong>Always available</strong> (no feature flag)</li>
</ul>
<h4 id="virtualpath-â-contain--redirect-opt-in-10"><a class="header" href="#virtualpath-â-contain--redirect-opt-in-10">VirtualPath â€” Contain &amp; Redirect (Opt-in, 10%)</a></h4>
<ul>
<li><strong>Philosophy</strong>: "Let it try to escape, but silently contain it"</li>
<li><strong>Behavior:</strong> Silently clamps escapes within boundary</li>
<li><strong>Use for:</strong> Multi-tenant systems, malware sandboxes, security research, user isolation</li>
<li><strong>Requires:</strong> <code>virtual-path</code> feature in <code>Cargo.toml</code></li>
</ul>
<h4 id="how-they-differ"><a class="header" href="#how-they-differ">How They Differ</a></h4>
<p>Attempting <code>../../../etc/passwd</code>:</p>
<ul>
<li><strong>StrictPath</strong>: <code>Err(PathEscapesBoundary)</code> â†’ log, alert, reject</li>
<li><strong>VirtualPath</strong>: Silently clamped to boundary â†’ contained, not reported</li>
</ul>
<p>Symlink to <code>/etc/passwd</code>:</p>
<ul>
<li><strong>StrictPath</strong>: Follows, validates target â†’ <strong>Error</strong> if outside boundary</li>
<li><strong>VirtualPath</strong>: Treats as relative â†’ clamped to <code>vroot/etc/passwd</code></li>
</ul>
<p><strong>Critical Rule</strong>: Use <strong>StrictPath for archives</strong> to detect attacks. VirtualPath hides them.</p>
<p><strong>Golden Rule</strong>: If you didn't create the path yourself, secure it first.</p>
<p>â†’ <strong><a href="./best_practices/real_world_patterns.html#archive-extraction-detect-vs-contain">Full comparison with examples â†’</a></strong></p>
<hr />
<h2 id="when-to-use-policy-types-vs-sugar"><a class="header" href="#when-to-use-policy-types-vs-sugar">When to Use Policy Types vs. Sugar</a></h2>
<p><strong>Sugar constructors</strong> (<code>StrictPath::with_boundary(..)</code>, <code>VirtualPath::with_root(..)</code>) are great for simple, one-off operations.</p>
<p><strong>Policy types</strong> (<code>PathBoundary</code>, <code>VirtualRoot</code>) matter when you need:</p>
<ul>
<li><strong>Policy reuse</strong> (canonicalize once, join many times)</li>
<li><strong>Performance</strong> (1 canonicalization vs 1000 in loops)</li>
<li><strong>Testability</strong> (inject test boundaries)</li>
<li><strong>Serde integration</strong> (contextual deserialization)</li>
<li><strong>Clear signatures</strong> (encode guarantees in types)</li>
</ul>
<p><strong>Quick Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

// âŒ SLOW: 1000 canonicalizations
for name in files {
    let boundary = PathBoundary::try_new(base)?;
    boundary.strict_join(name)?;
}

// âœ… FAST: 1 canonicalization
let boundary = PathBoundary::try_new(base)?;
for name in files {
    boundary.strict_join(name)?; // Reuses canonical state
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rule of thumb</strong>: Start with sugar; upgrade to policy types when you need reuse, performance, or testing.</p>
<p>â†’ <strong><a href="./best_practices/policy_and_reuse.html">Full guide with benchmarks, serde patterns, and testing examples â†’</a></strong></p>
<hr />
<h2 id="encode-guarantees-in-function-signatures"><a class="header" href="#encode-guarantees-in-function-signatures">Encode Guarantees In Function Signatures</a></h2>
<p>Helpers that touch the filesystem must encode safety in their signatures:</p>
<p><strong>Two canonical patterns:</strong></p>
<ol>
<li><strong>Accept validated path</strong> when validation already happened: <code>fn save(p: &amp;StrictPath) -&gt; io::Result&lt;()&gt;</code></li>
<li><strong>Accept boundary + segment</strong> when validation happens inside: <code>fn load(b: &amp;PathBoundary, name: &amp;str) -&gt; io::Result&lt;String&gt;</code></li>
</ol>
<p><strong>Don't construct boundaries/roots inside helpers</strong> â€” boundary choice is policy; make it explicit at call sites.</p>
<p>â†’ <strong><a href="./best_practices/policy_and_reuse.html#clear-function-signatures-stronger-guarantees">Full patterns with examples â†’</a></strong></p>
<hr />
<h2 id="multiâuser-isolation-virtualpath"><a class="header" href="#multiâuser-isolation-virtualpath">Multiâ€‘User Isolation (VirtualPath)</a></h2>
<p><strong>VirtualPath</strong> (opt-in via <code>virtual-path</code> feature) is for <strong>containment scenarios</strong>: multi-tenant systems, malware sandboxes, security research.</p>
<ul>
<li><strong>Per-user</strong>: Create <code>VirtualRoot</code> per user, call <code>virtual_join(..)</code> for all operations</li>
<li><strong>Share helpers</strong>: Borrow strict view with <code>vpath.as_unvirtual()</code></li>
<li><strong>Use for</strong>: Multi-tenant isolation, observing malicious behavior safely</li>
</ul>
<p><strong>NOT for</strong>: Archive extraction (use StrictPath to detect attacks, not hide them)</p>
<p>â†’ <strong><a href="./best_practices/real_world_patterns.html#multi-tenant-cloud-storage">Full multi-tenant example â†’</a></strong></p>
<hr />
<h2 id="interop--display"><a class="header" href="#interop--display">Interop &amp; Display</a></h2>
<p><strong>Interop</strong> (pass to <code>AsRef&lt;Path&gt;</code> APIs): <code>path.interop_path()</code> â€” no allocations</p>
<p><strong>Display:</strong></p>
<ul>
<li>System paths: <code>strictpath_display()</code> on <code>PathBoundary</code>/<code>StrictPath</code></li>
<li>User-facing: <code>virtualpath_display()</code> on <code>VirtualPath</code></li>
</ul>
<p><strong>Never</strong>: <code>interop_path().to_string_lossy()</code> for display</p>
<hr />
<h2 id="directory-discovery-vs-validation"><a class="header" href="#directory-discovery-vs-validation">Directory Discovery vs Validation</a></h2>
<p><strong>Discovery</strong> (walking): Use <code>.read_dir()</code>, collect names via <code>entry.file_name()</code></p>
<p><strong>Validation</strong>: Re-join discovered names through <code>strict_join</code>/<code>virtual_join</code> before I/O</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for entry in boundary.read_dir()? {
    let name = entry?.file_name();
    let validated = boundary.strict_join(&amp;name.to_string_lossy())?; // Validate!
    // Now safe to use validated path
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Don't validate constants</strong> like <code>"."</code> â€” only validate untrusted segments.</p>
<hr />
<h2 id="multiâuser-isolation-virtualpath-for-containment"><a class="header" href="#multiâuser-isolation-virtualpath-for-containment">Multiâ€‘User Isolation (VirtualPath for Containment)</a></h2>
<p><strong>Note</strong>: VirtualPath is opt-in via the <code>virtual-path</code> feature. Use it when you need <strong>containment</strong> (multi-tenant isolation, sandboxes) rather than <strong>detection</strong> (security boundaries).</p>
<ul>
<li>Perâ€‘user/tenant: for small flows, construct a root via <code>VirtualPath::with_root(..)</code> and join untrusted names with <code>virtual_join(..)</code>. For larger flows and reuse, create a <code>VirtualRoot</code> per user and call <code>virtual_join(..)</code>.</li>
<li>Share strict helpers by borrowing the strict view: <code>vpath.as_unvirtual()</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn upload(user_root: &amp;VirtualRoot, filename: &amp;str, bytes: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
  let vpath = user_root.virtual_join(filename)?;
  vpath.create_parent_dir_all()?;
  vpath.write(bytes)
}

// Sugar-first call site (one-off):
// let vroot = VirtualPath::with_root(format!("./cloud/user_{user_id}"))?;
// let vpath = vroot.virtual_join(filename)?; // same guarantees; keep VirtualRoot for reuse
<span class="boring">}</span></code></pre></pre>
<p><strong>When to use each for archives</strong>:</p>
<ul>
<li><strong>StrictPath for production archive extraction</strong> â€” detect malicious paths, reject compromised archives, alert users</li>
<li><strong>VirtualPath for sandbox/research</strong> â€” safely analyze suspicious archives by containing escapes while observing behavior</li>
<li><strong>StrictPath for file uploads to shared storage</strong> â€” reject attacks at the security boundary</li>
<li><strong>StrictPath for config loading</strong> â€” fail explicitly on untrusted paths that try to escape</li>
</ul>
<p>The key: use <strong>StrictPath to detect attacks</strong> in production; use <strong>VirtualPath to contain behavior</strong> in research/analysis scenarios.</p>
<h2 id="interop--display-1"><a class="header" href="#interop--display-1">Interop &amp; Display</a></h2>
<ul>
<li>Interop (pass into <code>AsRef&lt;Path&gt;</code> APIs): <code>path.interop_path()</code> (no allocations).</li>
<li>Display:
<ul>
<li>Systemâ€‘facing: <code>strictpath_display()</code> on <code>PathBoundary</code>/<code>StrictPath</code></li>
<li>Userâ€‘facing: <code>virtualpath_display()</code> on <code>VirtualPath</code></li>
</ul>
</li>
<li>Never use <code>interop_path().to_string_lossy()</code> for display.</li>
</ul>
<h2 id="directory-discovery-vs-validation-1"><a class="header" href="#directory-discovery-vs-validation-1">Directory Discovery vs Validation</a></h2>
<ul>
<li>Discovery (walking): call <code>boundary.read_dir()</code> (or <code>vroot.read_dir()</code>), collect names via <code>entry.file_name()</code>, then reâ€‘join with <code>strict_join</code>/<code>virtual_join</code> to validate before I/O.</li>
<li>Validation: join those relatives via <code>boundary.strict_join(..)</code> or <code>vroot.virtual_join(..)</code> before I/O. For small flows without a reusable root, you can construct via <code>StrictPath::with_boundary(..)</code> or <code>VirtualPath::with_root(..)</code> and then join.</li>
<li>Donâ€™t validate constants like <code>"."</code>; only validate untrusted segments.</li>
</ul>
<h2 id="common-operations-quick-reference"><a class="header" href="#common-operations-quick-reference">Common Operations (Quick Reference)</a></h2>
<p>Always use <strong>dimension-specific methods</strong> (<code>strict_*</code> / <code>virtualpath_*</code>). Never use <code>std::path</code> methods on leaked paths.</p>
<p><strong>Available operations:</strong></p>
<ul>
<li><strong>Joins</strong>: <code>strict_join(..)</code> / <code>virtual_join(..)</code> â€” validate and combine paths</li>
<li><strong>Parents</strong>: <code>strictpath_parent()</code> / <code>virtualpath_parent()</code> â€” navigate up directory tree</li>
<li><strong>Filenames</strong>: <code>strictpath_with_file_name(..)</code> / <code>strictpath_with_extension(..)</code> â€” modify names/extensions</li>
<li><strong>Rename</strong>: <code>strict_rename(..)</code> / <code>virtual_rename(..)</code> â€” move/rename within boundary</li>
<li><strong>Deletion</strong>: <code>.remove_file()</code>, <code>.remove_dir()</code>, <code>.remove_dir_all()</code> â€” safe deletion</li>
<li><strong>Metadata</strong>: <code>.metadata()</code>, <code>.exists()</code>, <code>.is_file()</code>, <code>.is_dir()</code> â€” inspect properties</li>
<li><strong>Copy</strong>: <code>.copy(&amp;dest)</code> â€” duplicate files</li>
<li><strong>I/O</strong>: <code>.read()</code>, <code>.read_to_string()</code>, <code>.write()</code>, <code>.create_file()</code> â€” file operations</li>
</ul>
<p>â†’ <strong><a href="./best_practices/common_operations.html">Complete operations guide with examples â†’</a></strong></p>
<h2 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h2>
<p><strong>Variables reflect domain, not type:</strong></p>
<ul>
<li>âœ… Good: <code>config_dir</code>, <code>uploads_root</code>, <code>archive_src</code>, <code>tenant_vroot</code></li>
<li>âŒ Bad: <code>boundary</code>, <code>jail</code>, <code>source_</code> prefix, <code>_path</code> suffix</li>
</ul>
<p><strong>Keep names consistent</strong> with the directory they represent.</p>
<hr />
<h2 id="do--donât"><a class="header" href="#do--donât">Do / Donâ€™t</a></h2>
<ul>
<li>Do: validate once at the boundary, pass types through helpers.</li>
<li>Do: use <code>VirtualRoot</code> for perâ€‘user isolation; borrow strict view for shared helpers.</li>
<li>Do: prefer <code>impl AsRef&lt;Path&gt;</code> in helper params where you forward to validation.</li>
<li>Donâ€™t: wrap secure types in <code>Path::new</code>/<code>PathBuf::from</code>.</li>
<li>Donâ€™t: use <code>interop_path().as_ref()</code> or <code>as_unvirtual().interop_path()</code> (use <code>interop_path()</code> directly).</li>
<li>Donâ€™t: use lossy strings for display or comparisons.</li>
</ul>
<h2 id="testing--doctests"><a class="header" href="#testing--doctests">Testing &amp; Doctests</a></h2>
<ul>
<li>Encode guarantees in function signatures</li>
<li>Use <code>*_create</code> constructors for temp directories in tests</li>
<li>Prefer offline simulations with deterministic inputs</li>
<li>Clean up test directories after tests</li>
</ul>
<hr />
<h2 id="learn-more"><a class="header" href="#learn-more">Learn More</a></h2>
<p>All detailed content has been moved to focused chapters for digestibility:</p>
<p><strong>Core Concepts:</strong></p>
<ul>
<li><strong><a href="./best_practices/why_naive_approaches_fail.html">Why Naive Approaches Fail â†’</a></strong> - 5 broken approaches with CVE examples</li>
<li><strong><a href="./best_practices/real_world_patterns.html">Real-World Patterns â†’</a></strong> - Production-ready examples:
<ul>
<li>LLM Agent File Manager</li>
<li>Archive Extraction (detect vs contain patterns)</li>
<li>Web File Server with marker types</li>
<li>Configuration Manager</li>
<li>Multi-Tenant Cloud Storage</li>
</ul>
</li>
</ul>
<p><strong>Practical Guides:</strong></p>
<ul>
<li><strong><a href="./best_practices/common_operations.html">Common Operations â†’</a></strong> - Complete reference for joins, parents, rename, delete, metadata, copy</li>
<li><strong><a href="./best_practices/policy_and_reuse.html">Policy &amp; Reuse â†’</a></strong> - When to use VirtualRoot/PathBoundary vs sugar (performance, testing, serde)</li>
</ul>
<p><strong>Advanced Topics:</strong></p>
<ul>
<li><strong><a href="./best_practices/authorization_architecture.html">Authorization Architecture â†’</a></strong> - Compile-time authorization with marker types</li>
</ul>
<hr />
<h2 id="quick-reference-card"><a class="header" href="#quick-reference-card">Quick Reference Card</a></h2>
<h3 id="type-selection-30-seconds"><a class="header" href="#type-selection-30-seconds">Type Selection (30 seconds)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Input Source</th><th>Default Choice</th><th>Notes</th></tr></thead><tbody>
<tr><td>HTTP/Web/LLM/Archives</td><td><code>StrictPath</code></td><td>Detect attacks, reject bad input</td></tr>
<tr><td>Multi-tenant isolation</td><td><code>VirtualPath</code></td><td>Contain per-user, clean UI paths</td></tr>
<tr><td>Trusted/hardcoded</td><td><code>Path/PathBuf</code></td><td>Only validate when mixing untrusted</td></tr>
</tbody></table>
</div>
<h3 id="sugar-vs-policy-types"><a class="header" href="#sugar-vs-policy-types">Sugar vs Policy Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Need</th><th>Use</th></tr></thead><tbody>
<tr><td>One-off operation</td><td>Sugar: <code>with_boundary(..)</code> / <code>with_root(..)</code></td></tr>
<tr><td>Reuse, performance, test</td><td>Policy: <code>PathBoundary</code> / <code>VirtualRoot</code></td></tr>
</tbody></table>
</div>
<h3 id="core-operations"><a class="header" href="#core-operations">Core Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Validate
let file = boundary.strict_join("path")?;

// I/O
file.write(b"data")?;
let content = file.read_to_string()?;

// Metadata
if file.exists() &amp;&amp; file.metadata()?.len() &gt; 0 { }

// Rename/Move
let renamed = file.strict_rename("newpath")?;

// Display
println!("System: {}", file.strictpath_display());
println!("User: {}", vpath.virtualpath_display()); // VirtualPath only
<span class="boring">}</span></code></pre></pre>
<h3 id="do--dont-checklist"><a class="header" href="#do--dont-checklist">Do / Don't Checklist</a></h3>
<p>âœ… <strong>DO:</strong></p>
<ul>
<li>Validate untrusted segments before I/O</li>
<li>Pass <code>&amp;StrictPath</code> / <code>&amp;VirtualPath</code> to encode guarantees</li>
<li>Use dimension-specific methods (<code>strict_*</code> / <code>virtualpath_*</code>)</li>
<li>Call <code>interop_path()</code> only for <code>AsRef&lt;Path&gt;</code> APIs</li>
<li>Name variables by domain (<code>uploads_root</code>, <code>config_dir</code>)</li>
</ul>
<p>âŒ <strong>DON'T:</strong></p>
<ul>
<li>Wrap secure types in <code>Path::new()</code> / <code>PathBuf::from()</code></li>
<li>Use <code>std::path</code> methods on leaked paths</li>
<li>Use <code>interop_path()</code> for display (use <code>*_display()</code>)</li>
<li>Construct boundaries inside helpers</li>
<li>Validate constants like <code>"."</code> (only untrusted segments)</li>
</ul>
<hr />
<h2 id="anti-patterns-reference"><a class="header" href="#anti-patterns-reference">Anti-Patterns Reference</a></h2>
<p>For detailed anti-patterns and fixes, see: <strong><a href="../anti_patterns.html">Anti-Patterns Guide â†’</a></strong></p>
<hr />
<p>That's it! This page is your quick reference. Dive into the focused chapters when you need details.</p>
<p>For source-level API documentation: <strong><a href="../../strict_path/index.html">API Reference (strict-path crate docs) â†’</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-every-simple-solution-fails"><a class="header" href="#why-every-simple-solution-fails">Why Every "Simple" Solution Fails</a></h1>
<blockquote>
<p><em>The path security rabbit hole is deeper than you think.</em></p>
</blockquote>
<p>Every developer's first instinct: "I'll just validate the path with a simple check." But path security isn't simple—it's a problem class with dozens of interacting edge cases. Here's why every naive approach creates new vulnerabilities.</p>
<hr />
<h2 id="approach-1-just-check-for-"><a class="header" href="#approach-1-just-check-for-">Approach 1: "Just check for <code>../</code>"</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if path.contains("../") { 
    return Err("Invalid path"); 
}
<span class="boring">}</span></code></pre></pre>
<p><strong>What it blocks:</strong></p>
<ul>
<li>✅ Basic traversal: <code>"../../../etc/passwd"</code></li>
</ul>
<p><strong>What bypasses it:</strong></p>
<ul>
<li>❌ URL encoding: <code>"..%2F..%2F..%2Fetc%2Fpasswd"</code></li>
<li>❌ Double encoding: <code>"....//....//etc//passwd"</code> → <code>"..//..//etc//passwd"</code> after one replacement</li>
<li>❌ Windows separators: <code>"..\\..\\..\etc\passwd"</code></li>
<li>❌ Mixed separators: <code>"../\\../etc/passwd"</code></li>
</ul>
<p><strong>Verdict:</strong> String matching is insufficient. Attackers use encoding tricks.</p>
<hr />
<h2 id="approach-2-use-canonicalize-then-check"><a class="header" href="#approach-2-use-canonicalize-then-check">Approach 2: "Use canonicalize() then check"</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let canonical = fs::canonicalize(path)?;
if !canonical.starts_with("/safe/") { 
    return Err("Escape attempt"); 
}
<span class="boring">}</span></code></pre></pre>
<p><strong>What it blocks:</strong></p>
<ul>
<li>✅ Most directory traversal attempts</li>
<li>✅ Resolves symlinks correctly</li>
</ul>
<p><strong>What it misses:</strong></p>
<ul>
<li>❌ <strong>CVE-2022-21658</strong>: Race condition (TOCTOU) - symlink created between <code>canonicalize()</code> and the check</li>
<li>❌ <strong>CVE-2019-9855</strong>: Windows 8.3 short names (<code>"PROGRA~1"</code> → <code>"Program Files"</code>) bypass string checks</li>
<li>❌ Fails on non-existent files (can't canonicalize paths that don't exist yet)</li>
<li>❌ Requires filesystem access for every validation (performance cost)</li>
</ul>
<p><strong>Verdict:</strong> Race conditions and platform quirks make this dangerous.</p>
<hr />
<h2 id="approach-3-normalize-the-path-first"><a class="header" href="#approach-3-normalize-the-path-first">Approach 3: "Normalize the path first"</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let normalized = path.replace("\\", "/").replace("../", "");
<span class="boring">}</span></code></pre></pre>
<p><strong>What it blocks:</strong></p>
<ul>
<li>✅ Basic traversal patterns</li>
</ul>
<p><strong>What bypasses it:</strong></p>
<ul>
<li>❌ Recursive patterns: <code>"....//....//etc//passwd"</code> → <code>"..\\..\\etc\\passwd"</code> after one replacement</li>
<li>❌ <strong>CVE-2020-12279</strong>: Unicode normalization attacks (<code>"..∕..∕etc∕passwd"</code> - different Unicode slashes)</li>
<li>❌ <strong>CVE-2017-17793</strong>: NTFS Alternate Data Streams (<code>"file.txt:hidden:$DATA"</code>)</li>
<li>❌ Absolute path replacement: <code>"/etc/passwd"</code> completely replaces the base path</li>
<li>❌ UNC paths on Windows: <code>"\\\\?\\C:\\Windows\\..\\..\\.."</code></li>
</ul>
<p><strong>Verdict:</strong> String replacement creates new attack vectors.</p>
<hr />
<h2 id="approach-4-use-an-allowlist-of-safe-characters"><a class="header" href="#approach-4-use-an-allowlist-of-safe-characters">Approach 4: "Use an allowlist of safe characters"</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !path.chars().all(|c| c.is_alphanumeric() || c == '/') { 
    return Err("Invalid"); 
}
<span class="boring">}</span></code></pre></pre>
<p><strong>What it blocks:</strong></p>
<ul>
<li>✅ Most special characters and encoding tricks</li>
</ul>
<p><strong>What it misses:</strong></p>
<ul>
<li>❌ Absolute path replacement: <code>"/etc/passwd"</code> (all valid chars!)</li>
<li>❌ Too restrictive: blocks legitimate files like <code>"report-2025.pdf"</code>, <code>"user_data.json"</code></li>
<li>❌ <strong>CVE-2025-8088</strong>: Misses platform-specific issues (Windows device names: <code>"CON"</code>, <code>"PRN"</code>, <code>"NUL"</code>)</li>
<li>❌ Doesn't handle Unicode properly (internationalized filenames)</li>
</ul>
<p><strong>Verdict:</strong> Either too restrictive (breaks legitimate use) or still vulnerable.</p>
<hr />
<h2 id="approach-5-combine-multiple-checks"><a class="header" href="#approach-5-combine-multiple-checks">Approach 5: "Combine multiple checks"</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check for ../, canonicalize, validate prefix, sanitize chars, check length...
fn validate_path(path: &amp;str) -&gt; Result&lt;PathBuf, Error&gt; {
    if path.contains("../") { return Err("traversal"); }
    if path.contains("\\") { return Err("backslash"); }
    if path.starts_with("/") { return Err("absolute"); }
    // ... 20 more checks ...
    let canonical = fs::canonicalize(path)?;
    if !canonical.starts_with("/safe/") { return Err("escape"); }
    Ok(canonical)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>What it blocks:</strong></p>
<ul>
<li>✅ Many known attack vectors</li>
<li>✅ Shows defensive programming</li>
</ul>
<p><strong>What it misses:</strong></p>
<ul>
<li>❌ <strong>Complexity = Bugs</strong>: 20+ edge cases means maintenance nightmare</li>
<li>❌ <strong>Platform gaps</strong>: Windows behavior ≠ Unix behavior ≠ Web behavior</li>
<li>❌ <strong>Performance cost</strong>: Multiple filesystem calls per validation</li>
<li>❌ <strong>Future CVEs</strong>: New attack vectors require updating every check</li>
<li>❌ <strong>False sense of security</strong>: Hard to verify you've covered everything</li>
</ul>
<p><strong>Verdict:</strong> Complex validation logic is error-prone and incomplete.</p>
<hr />
<h2 id="the-fundamental-problem"><a class="header" href="#the-fundamental-problem">The Fundamental Problem</a></h2>
<blockquote>
<p><strong>Each "fix" creates new attack surface.</strong></p>
</blockquote>
<p>Path security isn't a single problem—it's a <strong>problem class</strong> with complex interactions:</p>
<h3 id="the-5-core-challenges"><a class="header" href="#the-5-core-challenges">The 5 Core Challenges</a></h3>
<ol>
<li>
<p><strong>Encoding Normalization</strong></p>
<ul>
<li>Must handle URL encoding, Unicode, platform-specific encodings</li>
<li>Can't break legitimate international filenames</li>
<li>Attackers exploit normalization edge cases</li>
</ul>
</li>
<li>
<p><strong>Symlink Resolution</strong></p>
<ul>
<li>Must follow symlinks safely</li>
<li>Prevent race conditions (TOCTOU attacks)</li>
<li>Handle symlink cycles and bombs</li>
<li>Validate symlink targets stay within boundaries</li>
</ul>
</li>
<li>
<p><strong>Platform Consistency</strong></p>
<ul>
<li>Windows ≠ Unix ≠ Web</li>
<li>Case sensitivity differences</li>
<li>Path separator differences</li>
<li>Platform-specific features (8.3 names, UNC paths, Alternate Data Streams, device names)</li>
</ul>
</li>
<li>
<p><strong>Boundary Enforcement</strong></p>
<ul>
<li>Must be mathematical, not string-based</li>
<li>Resist all encoding and normalization tricks</li>
<li>Work for both existing and non-existent paths</li>
<li>Handle absolute vs. relative path semantics correctly</li>
</ul>
</li>
<li>
<p><strong>Future-Proof Design</strong></p>
<ul>
<li>Resistant to new attack vectors</li>
<li>Doesn't require updating for every new CVE</li>
<li>Compositional security properties</li>
<li>No "clever hacks" that break later</li>
</ul>
</li>
</ol>
<h3 id="why-this-is-hard"><a class="header" href="#why-this-is-hard">Why This Is Hard</a></h3>
<p>Each validation approach fixes one or two challenges while introducing new vulnerabilities in the others. You'd need:</p>
<ul>
<li>Deep filesystem expertise across all platforms</li>
<li>Knowledge of dozens of path-related CVEs</li>
<li>Months of testing edge cases</li>
<li>Ongoing maintenance as new attacks emerge</li>
</ul>
<p><strong>This is why strict-path exists.</strong></p>
<hr />
<h2 id="the-solution-solve-the-problem-class-once"><a class="header" href="#the-solution-solve-the-problem-class-once">The Solution: Solve the Problem Class Once</a></h2>
<p>Instead of patching individual vulnerabilities, <strong>strict-path solves the entire problem class</strong>:</p>
<ul>
<li><strong>Built on <code>soft-canonicalize</code></strong>: Battle-tested against 19+ real CVEs</li>
<li><strong>Mathematical boundary proofs</strong>: Type system guarantees paths stay within bounds</li>
<li><strong>Platform-aware</strong>: Handles Windows 8.3 names, UNC paths, symlinks, junctions</li>
<li><strong>Future-proof</strong>: Architectural design resists entire classes of attacks</li>
<li><strong>Composable</strong>: Safe by construction, not by validation</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

// One line replaces all the complexity above
let boundary = PathBoundary::try_new("./safe")?;
let safe_path = boundary.strict_join(user_input)?; // ✅ All attacks blocked
<span class="boring">}</span></code></pre></pre>
<p><strong>The trade-off</strong>: Learn one crate's API vs. implementing (and maintaining) dozens of validation checks.</p>
<hr />
<h2 id="learn-more-1"><a class="header" href="#learn-more-1">Learn More</a></h2>
<ul>
<li><strong><a href="best_practices/../best_practices.html">Best Practices Overview →</a></strong> - How to use strict-path correctly</li>
<li><strong><a href="best_practices/../security_methodology.html">Security Methodology →</a></strong> - Our complete security approach</li>
<li><strong><a href="best_practices/./real_world_patterns.html">Real-World Patterns →</a></strong> - Production-ready examples</li>
<li><strong><a href="best_practices/./common_operations.html">Common Operations →</a></strong> - How to use validated paths safely</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-world-patterns"><a class="header" href="#real-world-patterns">Real-World Patterns</a></h1>
<blockquote>
<p><em>Production-ready examples showing how to use strict-path in common scenarios.</em></p>
</blockquote>
<p>This chapter provides complete, copy-pasteable examples for typical use cases. Each pattern includes error handling, best practices, and explanations.</p>
<hr />
<h2 id="llm-agent-file-manager"><a class="header" href="#llm-agent-file-manager">LLM Agent File Manager</a></h2>
<p><strong>Challenge</strong>: LLM-generated paths are untrusted by definition—they could suggest anything from legitimate filenames to sophisticated traversal attacks.</p>
<p><strong>Solution</strong>: Use <code>StrictPath</code> to detect and reject escape attempts explicitly.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

// Encode guarantees in signature: pass workspace directory boundary and untrusted request
async fn llm_file_operation(
    workspace_dir: &amp;PathBoundary,
    request: &amp;LlmRequest
) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    // LLM could suggest anything: "../../../etc/passwd", "C:/Windows/System32", etc.
    let safe_path = workspace_dir.strict_join(&amp;request.filename)?; // ✅ Attack = Error

    match request.operation.as_str() {
        "write" =&gt; {
            safe_path.create_parent_dir_all()?;
            safe_path.write(&amp;request.content)?;
        },
        "read" =&gt; {
            return Ok(safe_path.read_to_string()?);
        },
        "delete" =&gt; {
            safe_path.remove_file()?;
        },
        _ =&gt; return Err("Invalid operation".into()),
    }
    Ok(format!("File {} processed safely", safe_path.strictpath_display()))
}

// Stub types
struct LlmRequest {
    filename: String,
    operation: String,
    content: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key points:</strong></p>
<ul>
<li>Pass <code>&amp;PathBoundary</code> into the helper—boundary choice is policy</li>
<li>Reject escape attempts explicitly with <code>?</code> operator</li>
<li>Use <code>strictpath_display()</code> for system-facing output</li>
<li>Create parent directories explicitly when needed</li>
</ul>
<hr />
<h2 id="archive-extraction-detect-vs-contain"><a class="header" href="#archive-extraction-detect-vs-contain">Archive Extraction: Detect vs. Contain</a></h2>
<p><strong>Critical distinction</strong>: Choose the right tool based on whether escapes are attacks or expected behavior.</p>
<h3 id="pattern-1-detect-malicious-archives-production"><a class="header" href="#pattern-1-detect-malicious-archives-production">Pattern 1: Detect Malicious Archives (Production)</a></h3>
<p><strong>When to use</strong>: Production archive extraction where malicious paths indicate a compromised archive.</p>
<p><strong>Solution</strong>: Use <code>StrictPath</code> to detect and reject compromised archives:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn extract_zip_strict(
    zip_entries: impl IntoIterator&lt;Item = (String, Vec&lt;u8&gt;)&gt;
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let extract_dir = PathBoundary::try_new_create("./extracted")?;
    
    for (name, data) in zip_entries {
        // Malicious names like "../../../etc/passwd" return Error
        match extract_dir.strict_join(&amp;name) {
            Ok(safe_path) =&gt; {
                safe_path.create_parent_dir_all()?;
                safe_path.write(&amp;data)?;
            },
            Err(e) =&gt; {
                eprintln!("🚨 Malicious path detected: {name}");
                eprintln!("Error: {e}");
                return Err(format!("Archive contains malicious path: {name}").into());
            }
        }
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Detects compromised archives immediately</li>
<li>Allows logging and alerting on attacks</li>
<li>Fails fast—doesn't partially extract malicious content</li>
<li>Users know their archive was rejected</li>
</ul>
<h3 id="pattern-2-sandbox-suspicious-archives-researchanalysis"><a class="header" href="#pattern-2-sandbox-suspicious-archives-researchanalysis">Pattern 2: Sandbox Suspicious Archives (Research/Analysis)</a></h3>
<p><strong>When to use</strong>: Malware analysis, security research, or safely inspecting untrusted archives.</p>
<p><strong>Solution</strong>: Use <code>VirtualPath</code> to contain escape attempts while observing behavior:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "virtual-path")]
use strict_path::VirtualPath;

#[cfg(feature = "virtual-path")]
fn extract_zip_sandbox(
    zip_entries: impl IntoIterator&lt;Item = (String, Vec&lt;u8&gt;)&gt;
) -&gt; std::io::Result&lt;()&gt; {
    let extract_root = VirtualPath::with_root_create("./sandbox")?;
    
    for (name, data) in zip_entries {
        // Hostile names like "../../../etc/passwd" → "/etc/passwd" (safely clamped)
        let vpath = extract_root.virtual_join(&amp;name)?;
        
        println!("Entry: {name}");
        println!("  Virtual path: {}", vpath.virtualpath_display());
        println!("  System path: {}", vpath.as_unvirtual().strictpath_display());
        
        vpath.create_parent_dir_all()?;
        vpath.write(&amp;data)?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Escapes are contained—observe malicious behavior safely</li>
<li>See what paths the archive <em>tried</em> to write</li>
<li>Perfect for forensic analysis</li>
<li>No partial extraction issues</li>
</ul>
<h3 id="when-to-use-which-1"><a class="header" href="#when-to-use-which-1">When to Use Which</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use Pattern 1 (StrictPath)</th><th>Use Pattern 2 (VirtualPath)</th></tr></thead><tbody>
<tr><td><strong>Production extraction</strong></td><td>✅ Detect attacks</td><td>❌ Hides attacks</td></tr>
<tr><td><strong>File uploads</strong></td><td>✅ Reject at boundary</td><td>❌ Hides attacks</td></tr>
<tr><td><strong>Malware analysis</strong></td><td>❌ Can't observe behavior</td><td>✅ Safe observation</td></tr>
<tr><td><strong>Security research</strong></td><td>❌ Escapes prevent analysis</td><td>✅ Contained escapes</td></tr>
<tr><td><strong>User-facing services</strong></td><td>✅ Users know it's malicious</td><td>❌ Silently "fixes" it</td></tr>
</tbody></table>
</div>
<p><strong>Rule of thumb</strong>: Use <code>StrictPath</code> (detect) for production; use <code>VirtualPath</code> (contain) for research/analysis.</p>
<hr />
<h2 id="web-file-server"><a class="header" href="#web-file-server">Web File Server</a></h2>
<p><strong>Challenge</strong>: Prevent directory traversal attacks while serving static files, and ensure user uploads can't be served as static assets.</p>
<p><strong>Solution</strong>: Use marker types to enforce domain separation at compile time.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

struct StaticFiles;    // CSS, JS, images
struct UserUploads;    // User documents

async fn serve_static(
    static_dir: &amp;PathBoundary&lt;StaticFiles&gt;,
    path: &amp;str
) -&gt; Result&lt;Response, Box&lt;dyn std::error::Error&gt;&gt; {
    let safe_path = static_dir.strict_join(path)?; // ✅ "../../../" → Error
    Ok(Response::new(safe_path.read()?))
}

// Function signature prevents bypass - no validation needed inside!
async fn serve_file(safe_path: &amp;StrictPath&lt;StaticFiles&gt;) -&gt; Response {
    Response::new(safe_path.read().unwrap_or_default())
}

// This function CANNOT accept UserUploads paths - compile error!
fn handle_request(
    static_files_dir: &amp;PathBoundary&lt;StaticFiles&gt;,
    user_uploads_dir: &amp;PathBoundary&lt;UserUploads&gt;,
    request_path: &amp;str
) -&gt; Result&lt;Response, Box&lt;dyn std::error::Error&gt;&gt; {
    let static_file = static_files_dir.strict_join(request_path)?;
    let _response = serve_file(&amp;static_file); // ✅ Works
    
    let user_file = user_uploads_dir.strict_join(request_path)?;
    // serve_file(&amp;user_file); // ❌ Compile error: wrong domain!
    
    Ok(Response::new(Vec::new()))
}

// Stub types
struct Response { data: Vec&lt;u8&gt; }
impl Response {
    fn new(data: Vec&lt;u8&gt;) -&gt; Self { Response { data } }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key benefits:</strong></p>
<ul>
<li>Marker types prevent cross-domain mix-ups at compile time</li>
<li>Function signatures encode security requirements</li>
<li>No runtime validation needed when types guarantee safety</li>
<li>Refactoring changes propagate through type system</li>
</ul>
<hr />
<h2 id="configuration-manager"><a class="header" href="#configuration-manager">Configuration Manager</a></h2>
<p><strong>Challenge</strong>: Load configuration files safely when the filename comes from user input or external sources.</p>
<p><strong>Solution</strong>: Validate config file paths before loading; encode validation state in function signatures.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

struct UserConfigs;

fn load_user_config(
    config_dir: &amp;PathBoundary&lt;UserConfigs&gt;,
    config_name: &amp;str
) -&gt; Result&lt;Config, Box&lt;dyn std::error::Error&gt;&gt; {
    let config_file = config_dir.strict_join(config_name)?;
    
    // Use built-in I/O helpers
    let content = config_file.read_to_string()?;
    Ok(serde_json::from_str(&amp;content)?)
}

fn save_user_config(
    config_file: &amp;StrictPath&lt;UserConfigs&gt;,
    config: &amp;Config
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Function signature guarantees path is already validated
    let json = serde_json::to_string_pretty(config)?;
    config_file.write(json.as_bytes())?;
    Ok(())
}

// Stub types
struct Config { setting: String }
<span class="boring">}</span></code></pre></pre>
<p><strong>Pattern notes:</strong></p>
<ul>
<li>Pass <code>&amp;PathBoundary</code> when validation is needed in the helper</li>
<li>Pass <code>&amp;StrictPath</code> when validation already happened at call site</li>
<li>Use built-in I/O methods to avoid <code>.interop_path()</code> calls</li>
<li>Marker types document which config directory is being accessed</li>
</ul>
<hr />
<h2 id="multi-tenant-cloud-storage-1"><a class="header" href="#multi-tenant-cloud-storage-1">Multi-Tenant Cloud Storage</a></h2>
<p><strong>Challenge</strong>: Each user needs isolated storage where they can't access other users' files, and paths should look clean (no system paths exposed).</p>
<p><strong>Solution</strong>: Use <code>VirtualPath</code> to create per-user isolated filesystems with clean rooted paths.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "virtual-path")]
use strict_path::{VirtualRoot, VirtualPath};

#[cfg(feature = "virtual-path")]
async fn handle_upload(
    user_root: &amp;VirtualRoot,
    filename: &amp;str,
    bytes: &amp;[u8]
) -&gt; std::io::Result&lt;()&gt; {
    // User can request ANY path - always safely contained
    let vpath = user_root.virtual_join(filename)?;
    
    vpath.create_parent_dir_all()?;
    vpath.write(bytes)?;
    
    // Show user-friendly path
    println!("Saved: {}", vpath.virtualpath_display());
    // Output: "Saved: /documents/report.pdf"
    // (Real path: storage/user_42/documents/report.pdf)
    
    Ok(())
}

#[cfg(feature = "virtual-path")]
async fn handle_download(
    user_root: &amp;VirtualRoot,
    filename: &amp;str
) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    let vpath = user_root.virtual_join(filename)?;
    
    // Share strict helper logic by borrowing
    vpath.as_unvirtual().read()
}

#[cfg(feature = "virtual-path")]
fn setup_user_storage(user_id: u64) -&gt; Result&lt;VirtualRoot, Box&lt;dyn std::error::Error&gt;&gt; {
    let user_root = VirtualRoot::try_new_create(format!("storage/user_{user_id}"))?;
    Ok(user_root)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Isolation benefits:</strong></p>
<ul>
<li>Users see clean paths like <code>/documents/report.pdf</code></li>
<li>Real path hidden: <code>storage/user_42/documents/report.pdf</code></li>
<li>Escape attempts silently contained within user's boundary</li>
<li>Each user's <code>/</code> is their own root—complete isolation</li>
<li>Share strict helpers with <code>as_unvirtual()</code> borrowing</li>
</ul>
<hr />
<h2 id="common-quick-patterns"><a class="header" href="#common-quick-patterns">Common Quick Patterns</a></h2>
<h3 id="validate--write"><a class="header" href="#validate--write">Validate + Write</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn write_file(boundary: &amp;PathBoundary, name: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    let safe_path = boundary.strict_join(name)?;
    safe_path.create_parent_dir_all()?;
    safe_path.write(data)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="validate--read"><a class="header" href="#validate--read">Validate + Read</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn read_file(boundary: &amp;PathBoundary, name: &amp;str) -&gt; std::io::Result&lt;String&gt; {
    boundary.strict_join(name)?.read_to_string()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="directory-walking-with-validation"><a class="header" href="#directory-walking-with-validation">Directory Walking with Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

fn process_directory(base_dir: &amp;PathBoundary) -&gt; std::io::Result&lt;Vec&lt;StrictPath&gt;&gt; {
    let mut paths = Vec::new();
    
    // Walk the directory
    for entry in base_dir.read_dir()? {
        let entry = entry?;
        let name = entry.file_name();
        
        // Re-validate each discovered name before use
        let safe_path = base_dir.strict_join(&amp;name.to_string_lossy())?;
        paths.push(safe_path);
    }
    
    Ok(paths)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-with-security-logging"><a class="header" href="#error-handling-with-security-logging">Error Handling with Security Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPathError};

fn robust_file_access(
    boundary: &amp;PathBoundary,
    filename: &amp;str
) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    match boundary.strict_join(filename) {
        Ok(safe_path) =&gt; {
            match safe_path.read_to_string() {
                Ok(content) =&gt; Ok(content),
                Err(e) if e.kind() == std::io::ErrorKind::NotFound =&gt; {
                    // File doesn't exist - create default
                    safe_path.write(b"default content")?;
                    Ok("default content".to_string())
                },
                Err(e) =&gt; Err(e.into()),
            }
        },
        Err(StrictPathError::PathEscapesBoundary { .. }) =&gt; {
            // Log security incident
            eprintln!("🚨 Path escape attempt: {filename}");
            Err("Invalid path".into())
        },
        Err(e) =&gt; Err(e.into()),
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="learn-more-2"><a class="header" href="#learn-more-2">Learn More</a></h2>
<ul>
<li><strong><a href="best_practices/../best_practices.html">Best Practices Overview →</a></strong> - Core guidelines and decision matrices</li>
<li><strong><a href="best_practices/./common_operations.html">Common Operations →</a></strong> - Complete operation examples (joins, rename, delete, etc.)</li>
<li><strong><a href="best_practices/./policy_and_reuse.html">Policy &amp; Reuse →</a></strong> - When and why to use VirtualRoot/PathBoundary</li>
<li><strong><a href="best_practices/./authorization_architecture.html">Authorization Patterns →</a></strong> - Compile-time authorization with markers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-operations-guide"><a class="header" href="#common-operations-guide">Common Operations Guide</a></h1>
<blockquote>
<p><em>Complete reference for all path operations with strict-path.</em></p>
</blockquote>
<p>This chapter provides comprehensive examples for every operation you'll need when working with validated paths. Always use dimension-specific methods—never use <code>std::path</code> methods on leaked paths.</p>
<hr />
<h2 id="joins"><a class="header" href="#joins">Joins</a></h2>
<p><strong>Purpose</strong>: Combine a boundary/root with an untrusted segment to create a validated path.</p>
<h3 id="basic-joins"><a class="header" href="#basic-joins">Basic Joins</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

fn join_examples(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    // Single join
    let file = boundary.strict_join("docs/readme.md")?;
    
    // Join with slash or backslash - both work
    let file2 = boundary.strict_join("docs\\readme.md")?;
    
    // Multi-segment path
    let deep = boundary.strict_join("a/b/c/d/file.txt")?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="chained-joins"><a class="header" href="#chained-joins">Chained Joins</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

fn chained_joins(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    // Navigate through directories
    let level1 = boundary.strict_join("level1")?;
    let level2 = level1.strict_join("level2")?;
    let file = level2.strict_join("file.txt")?;
    
    // Or go up and down
    let sibling = level2
        .strictpath_parent().unwrap()
        .strict_join("sibling/file.txt")?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="joining-discovered-names"><a class="header" href="#joining-discovered-names">Joining Discovered Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

fn discover_and_join(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;Vec&lt;StrictPath&gt;&gt; {
    let mut files = Vec::new();
    
    // Walk directory
    for entry in boundary.read_dir()? {
        let entry = entry?;
        let name = entry.file_name();
        
        // IMPORTANT: Re-validate each discovered name
        let validated = boundary.strict_join(&amp;name.to_string_lossy())?;
        files.push(validated);
    }
    
    Ok(files)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key rules:</strong></p>
<ul>
<li>Always validate untrusted segments with <code>strict_join()</code> or <code>virtual_join()</code></li>
<li>Re-validate discovered directory names before using them</li>
<li>Never use <code>std::path::Path::join()</code> on untrusted input</li>
</ul>
<hr />
<h2 id="parents-and-ancestors"><a class="header" href="#parents-and-ancestors">Parents and Ancestors</a></h2>
<p><strong>Purpose</strong>: Navigate up the directory tree safely.</p>
<h3 id="getting-parent-directory"><a class="header" href="#getting-parent-directory">Getting Parent Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn parent_examples(file: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    // Get parent directory
    if let Some(parent) = file.strictpath_parent() {
        println!("Parent: {}", parent.strictpath_display());
        
        // Create parent if needed
        parent.create_dir_all()?;
    } else {
        println!("At boundary root");
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="walking-up-to-root"><a class="header" href="#walking-up-to-root">Walking Up to Root</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn walk_to_root(file: &amp;StrictPath) {
    let mut current = Some(file.clone());
    let mut level = 0;
    
    while let Some(path) = current {
        println!("Level {}: {}", level, path.strictpath_display());
        current = path.strictpath_parent();
        level += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="finding-ancestor-with-specific-name"><a class="header" href="#finding-ancestor-with-specific-name">Finding Ancestor with Specific Name</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn find_ancestor(file: &amp;StrictPath, target_name: &amp;str) -&gt; Option&lt;StrictPath&gt; {
    let mut current = Some(file.clone());
    
    while let Some(path) = current {
        if path.strictpath_display().to_string().ends_with(target_name) {
            return Some(path);
        }
        current = path.strictpath_parent();
    }
    
    None
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key insight</strong>: <code>strictpath_parent()</code> returns <code>None</code> at the boundary root—you can't escape upward.</p>
<hr />
<h2 id="file-name-and-extension-operations"><a class="header" href="#file-name-and-extension-operations">File Name and Extension Operations</a></h2>
<p><strong>Purpose</strong>: Modify path components while staying within the boundary.</p>
<h3 id="changing-file-names"><a class="header" href="#changing-file-names">Changing File Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn filename_operations(file: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    // Change filename (keeps directory and extension)
    let renamed = file.strictpath_with_file_name("newname.txt")?;
    
    // Change just the stem (keeps extension)
    let new_stem = file.strictpath_with_file_name("report")?
        .strictpath_with_extension(
            file.strictpath_extension().unwrap_or("txt")
        )?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="changing-extensions"><a class="header" href="#changing-extensions">Changing Extensions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn extension_operations(file: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    // Change extension
    let markdown = file.strictpath_with_extension("md")?;
    let json = file.strictpath_with_extension("json")?;
    
    // Remove extension
    let no_ext = file.strictpath_with_extension("")?;
    
    // Add extension if missing
    let with_ext = if file.strictpath_extension().is_none() {
        file.strictpath_with_extension("txt")?
    } else {
        file.clone()
    };
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="combining-operations"><a class="header" href="#combining-operations">Combining Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn combined_operations(file: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    // Change both filename and extension
    let transformed = file
        .strictpath_with_file_name("report")?
        .strictpath_with_extension("pdf")?;
    
    // Add timestamp to filename
    let timestamp = "2025-10-14";
    let current_name = file.strictpath_file_stem().unwrap_or("file");
    let timestamped = file.strictpath_with_file_name(
        format!("{}_{}", current_name, timestamp)
    )?.strictpath_with_extension(
        file.strictpath_extension().unwrap_or("txt")
    )?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="rename-and-move-operations"><a class="header" href="#rename-and-move-operations">Rename and Move Operations</a></h2>
<p><strong>Purpose</strong>: Move files/directories while staying within the boundary.</p>
<h3 id="simple-rename-same-directory"><a class="header" href="#simple-rename-same-directory">Simple Rename (Same Directory)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

fn simple_rename(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let current = boundary.strict_join("logs/app.log")?;
    current.write(b"log data")?;
    
    // Rename returns the new path
    let renamed = current.strict_rename("logs/app.old")?;
    
    assert!(renamed.exists());
    assert!(!current.exists()); // Original path no longer exists
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="move-to-different-directory"><a class="header" href="#move-to-different-directory">Move to Different Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

fn move_file(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let source = boundary.strict_join("temp/file.txt")?;
    source.write(b"data")?;
    
    // Create destination directory first
    let dest_dir = boundary.strict_join("archive")?;
    dest_dir.create_dir_all()?;
    
    // Move to new directory
    let moved = source.strict_rename("archive/file.txt")?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rename-with-parent-directory-creation"><a class="header" href="#rename-with-parent-directory-creation">Rename with Parent Directory Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn rename_with_mkdir(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let file = boundary.strict_join("data.txt")?;
    file.write(b"content")?;
    
    // Rename to path in subdirectory (create if needed)
    let new_path = boundary.strict_join("backups/2025/data.txt")?;
    if let Some(parent) = new_path.strictpath_parent() {
        parent.create_dir_all()?;
    }
    
    let renamed = file.strict_rename("backups/2025/data.txt")?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="virtual-rename-clean-paths"><a class="header" href="#virtual-rename-clean-paths">Virtual Rename (Clean Paths)</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "virtual-path")]
use strict_path::VirtualRoot;

#[cfg(feature = "virtual-path")]
fn virtual_rename_example(vroot: &amp;VirtualRoot) -&gt; std::io::Result&lt;()&gt; {
    let file = vroot.virtual_join("uploads/photo.jpg")?;
    file.write(b"image data")?;
    
    // Virtual rename - user sees clean paths
    let renamed = file.virtual_rename("uploads/photo_2025.jpg")?;
    
    println!("User sees: {}", renamed.virtualpath_display());
    // Output: "/uploads/photo_2025.jpg"
    
    println!("System path: {}", renamed.as_unvirtual().strictpath_display());
    // Output: actual filesystem path
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="deletion-operations"><a class="header" href="#deletion-operations">Deletion Operations</a></h2>
<p><strong>Purpose</strong>: Remove files and directories safely.</p>
<h3 id="delete-single-file"><a class="header" href="#delete-single-file">Delete Single File</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn delete_file(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let file = boundary.strict_join("temp/cache.tmp")?;
    
    // Check existence before deleting
    if file.exists() {
        file.remove_file()?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="delete-empty-directory"><a class="header" href="#delete-empty-directory">Delete Empty Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn delete_empty_dir(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let dir = boundary.strict_join("temp/empty")?;
    
    // Only works if directory is empty
    if dir.exists() &amp;&amp; dir.metadata()?.is_dir() {
        dir.remove_dir()?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="recursive-directory-deletion"><a class="header" href="#recursive-directory-deletion">Recursive Directory Deletion</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn delete_directory_tree(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let dir = boundary.strict_join("temp/data")?;
    
    // Removes directory and ALL contents recursively
    if dir.exists() {
        dir.remove_dir_all()?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="safe-cleanup-with-validation"><a class="header" href="#safe-cleanup-with-validation">Safe Cleanup with Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn safe_cleanup(boundary: &amp;PathBoundary, path: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    // Validate path first
    match boundary.strict_join(path) {
        Ok(safe_path) =&gt; {
            if safe_path.exists() {
                if safe_path.metadata()?.is_dir() {
                    safe_path.remove_dir_all()?;
                } else {
                    safe_path.remove_file()?;
                }
                println!("Deleted: {}", safe_path.strictpath_display());
            }
            Ok(())
        },
        Err(e) =&gt; {
            eprintln!("🚨 Invalid path, refusing to delete: {e}");
            Err(std::io::Error::new(std::io::ErrorKind::InvalidInput, e))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Safety note</strong>: Always validate paths before deletion. Never delete based on untrusted input without validation.</p>
<hr />
<h2 id="metadata-inspection"><a class="header" href="#metadata-inspection">Metadata Inspection</a></h2>
<p><strong>Purpose</strong>: Query file/directory properties without reading contents.</p>
<h3 id="basic-metadata"><a class="header" href="#basic-metadata">Basic Metadata</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;
use std::time::SystemTime;

fn inspect_metadata(file: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    let meta = file.metadata()?;
    
    // File type checks
    println!("Is file: {}", meta.is_file());
    println!("Is directory: {}", meta.is_dir());
    println!("Is symlink: {}", meta.file_type().is_symlink());
    
    // Size and permissions
    println!("Size: {} bytes", meta.len());
    println!("Read-only: {}", meta.permissions().readonly());
    
    // Timestamps
    if let Ok(modified) = meta.modified() {
        let duration = SystemTime::now().duration_since(modified).unwrap();
        println!("Modified {} seconds ago", duration.as_secs());
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-operations-based-on-metadata"><a class="header" href="#conditional-operations-based-on-metadata">Conditional Operations Based on Metadata</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn cleanup_empty_files(file: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    let meta = file.metadata()?;
    
    if meta.is_file() &amp;&amp; meta.len() == 0 {
        println!("Empty file, removing: {}", file.strictpath_display());
        file.remove_file()?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="finding-files-by-criteria"><a class="header" href="#finding-files-by-criteria">Finding Files by Criteria</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

fn find_large_files(boundary: &amp;PathBoundary, min_size: u64) -&gt; std::io::Result&lt;Vec&lt;StrictPath&gt;&gt; {
    let mut large_files = Vec::new();
    
    for entry in boundary.read_dir()? {
        let entry = entry?;
        let name = entry.file_name();
        let path = boundary.strict_join(&amp;name.to_string_lossy())?;
        
        if let Ok(meta) = path.metadata() {
            if meta.is_file() &amp;&amp; meta.len() &gt; min_size {
                large_files.push(path);
            }
        }
    }
    
    Ok(large_files)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="copy-operations"><a class="header" href="#copy-operations">Copy Operations</a></h2>
<p><strong>Purpose</strong>: Duplicate files while preserving validation.</p>
<h3 id="simple-copy"><a class="header" href="#simple-copy">Simple Copy</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn simple_copy(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let source = boundary.strict_join("docs/original.txt")?;
    let dest = boundary.strict_join("docs/copy.txt")?;
    
    // Returns number of bytes copied
    let bytes_copied = source.copy(&amp;dest)?;
    println!("Copied {bytes_copied} bytes");
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="copy-with-overwrite-protection"><a class="header" href="#copy-with-overwrite-protection">Copy with Overwrite Protection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn copy_if_not_exists(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let source = boundary.strict_join("docs/original.txt")?;
    let dest = boundary.strict_join("docs/backup.txt")?;
    
    if !dest.exists() {
        source.copy(&amp;dest)?;
        println!("Copied to {}", dest.strictpath_display());
    } else {
        println!("Destination already exists, skipping");
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="copy-to-different-directory"><a class="header" href="#copy-to-different-directory">Copy to Different Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn copy_to_archive(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let source = boundary.strict_join("docs/report.pdf")?;
    
    // Create backup directory
    let backup_dir = boundary.strict_join("backups/2025")?;
    backup_dir.create_dir_all()?;
    
    // Copy to backup location
    let dest = boundary.strict_join("backups/2025/report.pdf")?;
    source.copy(&amp;dest)?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="comprehensive-example-file-management"><a class="header" href="#comprehensive-example-file-management">Comprehensive Example: File Management</a></h2>
<p>Putting it all together—a complete file management function:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};
use std::time::{SystemTime, Duration};

fn manage_user_file(
    uploads_dir: &amp;PathBoundary,
    filename: &amp;str
) -&gt; Result&lt;FileInfo, Box&lt;dyn std::error::Error&gt;&gt; {
    // 1. Validate path
    let file = uploads_dir.strict_join(filename)?;
    
    // 2. Check existence
    if !file.exists() {
        return Err("File not found".into());
    }
    
    // 3. Get metadata
    let meta = file.metadata()?;
    
    // 4. Archive old files
    if should_archive(&amp;meta)? {
        let archive_dir = uploads_dir.strict_join("archive")?;
        archive_dir.create_dir_all()?;
        
        let archived = file.strict_rename(&amp;format!("archive/{filename}"))?;
        
        // 5. Compress large files
        if meta.len() &gt; 10_000_000 {
            compress_file(&amp;archived)?;
        }
        
        return Ok(FileInfo {
            path: archived.strictpath_display().to_string(),
            status: FileStatus::Archived,
            size: meta.len(),
        });
    }
    
    Ok(FileInfo {
        path: file.strictpath_display().to_string(),
        status: FileStatus::Active,
        size: meta.len(),
    })
}

fn should_archive(meta: &amp;std::fs::Metadata) -&gt; std::io::Result&lt;bool&gt; {
    let modified = meta.modified()?;
    let age = SystemTime::now().duration_since(modified)
        .unwrap_or(Duration::ZERO);
    
    Ok(age &gt; Duration::from_secs(30 * 24 * 60 * 60)) // 30 days
}

fn compress_file(_file: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    // Compression implementation
    Ok(())
}

#[derive(Debug)]
struct FileInfo {
    path: String,
    status: FileStatus,
    size: u64,
}

#[derive(Debug)]
enum FileStatus {
    Active,
    Archived,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="key-principles"><a class="header" href="#key-principles">Key Principles</a></h2>
<p><strong>Always use dimension-specific methods:</strong></p>
<ul>
<li>Use <code>strict_join()</code> / <code>virtual_join()</code> for joins</li>
<li>Use <code>strictpath_parent()</code> / <code>virtualpath_parent()</code> for parents</li>
<li>Use <code>strictpath_with_*()</code> / <code>virtualpath_with_*()</code> for modifications</li>
<li><strong>Never</strong> use <code>std::path</code> methods on leaked paths</li>
</ul>
<p><strong>Handle errors explicitly:</strong></p>
<ul>
<li>Path operations can fail (permissions, disk full, invalid paths)</li>
<li>Use <code>?</code> operator or explicit <code>match</code> for error handling</li>
<li>Log security incidents when paths escape boundaries</li>
</ul>
<p><strong>Check before destructive operations:</strong></p>
<ul>
<li>Use <code>.exists()</code> before deletion</li>
<li>Use <code>.metadata()</code> to check file vs. directory</li>
<li>Create parent directories with <code>.create_dir_all()</code> before moves</li>
</ul>
<p><strong>Validate discovered paths:</strong></p>
<ul>
<li>Re-validate directory entries with <code>strict_join()</code> / <code>virtual_join()</code></li>
<li>Don't trust filesystem listings—validate before use</li>
</ul>
<hr />
<h2 id="learn-more-3"><a class="header" href="#learn-more-3">Learn More</a></h2>
<ul>
<li><strong><a href="best_practices/../best_practices.html">Best Practices Overview →</a></strong> - Core guidelines and decision matrices</li>
<li><strong><a href="best_practices/./real_world_patterns.html">Real-World Patterns →</a></strong> - Production-ready examples</li>
<li><strong><a href="best_practices/./policy_and_reuse.html">Policy &amp; Reuse →</a></strong> - When to use VirtualRoot/PathBoundary</li>
<li><strong><a href="best_practices/./authorization_architecture.html">Authorization Patterns →</a></strong> - Compile-time authorization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="policy--reuse-patterns"><a class="header" href="#policy--reuse-patterns">Policy &amp; Reuse Patterns</a></h1>
<blockquote>
<p><em>Why VirtualRoot and PathBoundary matter for correctness, performance, and maintainability.</em></p>
</blockquote>
<p>The sugar constructors (<code>StrictPath::with_boundary(..)</code>, <code>VirtualPath::with_root(..)</code>) are great for simple flows, but the root/boundary types still matter as your code grows. This chapter explains when and why to use them.</p>
<hr />
<h2 id="the-core-insight"><a class="header" href="#the-core-insight">The Core Insight</a></h2>
<p><strong>Roots/boundaries represent security policy</strong> (the restriction), while paths represent validated values within that policy.</p>
<p>This separation enables:</p>
<ul>
<li><strong>Policy reuse</strong> without repeated validation</li>
<li><strong>Clear function signatures</strong> that encode guarantees</li>
<li><strong>Performance optimization</strong> through canonicalization caching</li>
<li><strong>Better testing</strong> with injectable boundaries</li>
<li><strong>Explicit deserialization</strong> with serde seeds</li>
</ul>
<hr />
<h2 id="policy-reuse-and-separation-of-concerns"><a class="header" href="#policy-reuse-and-separation-of-concerns">Policy Reuse and Separation of Concerns</a></h2>
<h3 id="anti-pattern-reconstructing-policy"><a class="header" href="#anti-pattern-reconstructing-policy">Anti-Pattern: Reconstructing Policy</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

// ❌ BAD: Reconstructing boundary for every file
fn process_files(base_path: &amp;str, filenames: &amp;[String]) -&gt; std::io::Result&lt;()&gt; {
    for name in filenames {
        let boundary = PathBoundary::try_new(base_path)?; // Repeated canonicalization!
        let file = boundary.strict_join(name)?;
        file.write(b"data")?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Problems:</strong></p>
<ul>
<li>Canonicalizes the same base path repeatedly (performance waste)</li>
<li>Hides policy choice inside the helper (reviewability issue)</li>
<li>Hard to test with different boundaries (testability issue)</li>
</ul>
<h3 id="better-policy-reuse"><a class="header" href="#better-policy-reuse">Better: Policy Reuse</a></h3>
<pre><pre class="playground"><code class="language-rust">use strict_path::PathBoundary;

// ✅ GOOD: Construct policy once, reuse everywhere
fn process_files(boundary: &amp;PathBoundary, filenames: &amp;[String]) -&gt; std::io::Result&lt;()&gt; {
    for name in filenames {
        let file = boundary.strict_join(name)?; // Reuses canonicalized boundary
        file.write(b"data")?;
    }
    Ok(())
}

// Usage: Policy choice explicit at call site
fn main() -&gt; std::io::Result&lt;()&gt; {
    let uploads = PathBoundary::try_new("./uploads")?;
    let files = vec!["a.txt".to_string(), "b.txt".to_string()];
    
    process_files(&amp;uploads, &amp;files)?; // Clear what boundary is being used
    Ok(())
}</code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Canonicalizes once, reuses for all operations</li>
<li>Policy choice visible at call site</li>
<li>Easy to inject test boundaries</li>
<li>Reviewers see security decisions explicitly</li>
</ul>
<p><strong>Key insight</strong>: Don't construct boundaries inside helpers — boundary choice is policy; encoding it at call sites improves reviewability and testing.</p>
<hr />
<h2 id="clear-function-signatures-stronger-guarantees"><a class="header" href="#clear-function-signatures-stronger-guarantees">Clear Function Signatures (Stronger Guarantees)</a></h2>
<p>Two canonical patterns make intent obvious:</p>
<h3 id="pattern-1-accept-validated-path"><a class="header" href="#pattern-1-accept-validated-path">Pattern 1: Accept Validated Path</a></h3>
<p><strong>When to use</strong>: Validation already happened at the call site.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

fn write_report(report_file: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    // Guaranteed: path is already validated
    // No validation needed inside this function
    report_file.write(b"report data")
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Function signature proves validation happened</li>
<li>No redundant validation inside</li>
<li>Clear contract: "I only accept validated paths"</li>
</ul>
<h3 id="pattern-2-accept-boundary--segment"><a class="header" href="#pattern-2-accept-boundary--segment">Pattern 2: Accept Boundary + Segment</a></h3>
<p><strong>When to use</strong>: Validation happens inside the helper.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn load_config(config_dir: &amp;PathBoundary, name: &amp;str) -&gt; std::io::Result&lt;String&gt; {
    // Validation happens inside this function
    config_dir.strict_join(name)?.read_to_string()
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Helper performs validation explicitly</li>
<li>Reuses provided boundary (no policy choice inside)</li>
<li>Clear contract: "I validate against your boundary"</li>
</ul>
<h3 id="usage-example-patterns-in-context"><a class="header" href="#usage-example-patterns-in-context">Usage Example: Patterns in Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

fn example_workflow() -&gt; std::io::Result&lt;()&gt; {
    let reports_dir = PathBoundary::try_new("reports")?;
    let config_dir = PathBoundary::try_new("config")?;
    
    // Pattern 1: Validation at call site
    let report = reports_dir.strict_join("q4_2025.pdf")?;
    write_report(&amp;report)?; // Function knows it's validated
    
    // Pattern 2: Validation inside helper
    let settings = load_config(&amp;config_dir, "app.toml")?;
    
    Ok(())
}

fn write_report(report_file: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; {
    report_file.write(b"report data")
}

fn load_config(config_dir: &amp;PathBoundary, name: &amp;str) -&gt; std::io::Result&lt;String&gt; {
    config_dir.strict_join(name)?.read_to_string()
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key insight</strong>: Signatures prevent helpers from "picking a root" silently, making security rules visible in code review.</p>
<hr />
<h2 id="contextual-deserialization-serde"><a class="header" href="#contextual-deserialization-serde">Contextual Deserialization (Serde)</a></h2>
<p><code>StrictPath</code>/<code>VirtualPath</code> <strong>can't</strong> implement blanket <code>Deserialize</code> safely—they need runtime context (the boundary/root) to validate.</p>
<h3 id="the-problem-8"><a class="header" href="#the-problem-8">The Problem</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Deserialize;

#[derive(Deserialize)]
struct Config {
    name: String,
    // path: StrictPath, // ❌ Won't compile - no context for validation!
}
<span class="boring">}</span></code></pre></pre>
<h3 id="solution-1-deserialize-then-validate"><a class="header" href="#solution-1-deserialize-then-validate">Solution 1: Deserialize Then Validate</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};
use serde::Deserialize;

#[derive(Deserialize)]
struct RawConfig {
    name: String,
    path: String, // Deserialize as string first
}

fn load_safe_config(json: &amp;str) -&gt; Result&lt;StrictPath, Box&lt;dyn std::error::Error&gt;&gt; {
    let config_dir = PathBoundary::try_new("./configs")?;
    
    // 1. Deserialize raw data
    let raw: RawConfig = serde_json::from_str(json)?;
    
    // 2. Validate against boundary
    let safe_path = config_dir.strict_join(&amp;raw.path)?;
    
    Ok(safe_path)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="solution-2-serde-seeds-advanced"><a class="header" href="#solution-2-serde-seeds-advanced">Solution 2: Serde Seeds (Advanced)</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "serde")]
use strict_path::{PathBoundary, StrictPath, serde_ext};

#[cfg(feature = "serde")]
fn deserialize_with_seed(
    json: &amp;str,
    boundary: &amp;PathBoundary
) -&gt; Result&lt;StrictPath, Box&lt;dyn std::error::Error&gt;&gt; {
    // Seed provides validation context
    let seed = serde_ext::WithBoundary(boundary);
    let safe_path: StrictPath = serde_json::from_str(json)?;
    Ok(safe_path)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key insight</strong>: Deserialization is explicit and auditable—where did the policy come from? What are we validating against?</p>
<hr />
<h2 id="performance-and-canonicalization"><a class="header" href="#performance-and-canonicalization">Performance and Canonicalization</a></h2>
<p>Canonicalize the root once; strict/virtual joins reuse that canonicalized state.</p>
<h3 id="performance-anti-pattern"><a class="header" href="#performance-anti-pattern">Performance Anti-Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn slow_approach(files: &amp;[String]) -&gt; std::io::Result&lt;()&gt; {
    // ❌ SLOW: Canonicalizes base path 1000 times
    for name in files {
        let boundary = PathBoundary::try_new("./data")?; // Filesystem call every time!
        let _file = boundary.strict_join(name)?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn fast_approach(files: &amp;[String]) -&gt; std::io::Result&lt;()&gt; {
    // ✅ FAST: Canonicalizes base path once, reuses for all joins
    let boundary = PathBoundary::try_new("./data")?; // Single filesystem call
    
    for name in files {
        let _file = boundary.strict_join(name)?; // Reuses canonical state
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="benchmark-comparison"><a class="header" href="#benchmark-comparison">Benchmark Comparison</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn benchmark_comparison() -&gt; std::io::Result&lt;()&gt; {
    let files: Vec&lt;String&gt; = (0..1000).map(|i| format!("file{i}.txt")).collect();
    
    // Slow: ~1000 canonicalization calls
    for name in &amp;files {
        let boundary = PathBoundary::try_new("./data")?;
        let _ = boundary.strict_join(name)?;
    }
    
    // Fast: 1 canonicalization call + 1000 cheap joins
    let boundary = PathBoundary::try_new("./data")?;
    for name in &amp;files {
        let _ = boundary.strict_join(name)?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Performance benefit</strong>: Virtual joins use anchored canonicalization to apply virtual semantics safely and consistently without repeated filesystem calls.</p>
<hr />
<h2 id="auditability-and-testing"><a class="header" href="#auditability-and-testing">Auditability and Testing</a></h2>
<p>Centralizing policy in a root value simplifies logging, tracing, and tests.</p>
<h3 id="testable-helper"><a class="header" href="#testable-helper">Testable Helper</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

// Easy to inject test boundaries
fn save_user_data(
    uploads_dir: &amp;PathBoundary,
    filename: &amp;str,
    data: &amp;[u8]
) -&gt; std::io::Result&lt;()&gt; {
    let file = uploads_dir.strict_join(filename)?;
    file.create_parent_dir_all()?;
    file.write(data)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-with-injected-boundaries"><a class="header" href="#testing-with-injected-boundaries">Testing with Injected Boundaries</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_with_temp_boundary() -&gt; std::io::Result&lt;()&gt; {
        // Create test boundary
        let temp_dir = std::env::temp_dir().join("test_uploads");
        std::fs::create_dir_all(&amp;temp_dir)?;
        let boundary = PathBoundary::try_new(&amp;temp_dir)?;
        
        // Test with injected boundary
        save_user_data(&amp;boundary, "test.txt", b"data")?;
        
        // Verify
        let file = boundary.strict_join("test.txt")?;
        assert_eq!(file.read()?, b"data");
        
        // Cleanup
        std::fs::remove_dir_all(&amp;temp_dir)?;
        Ok(())
    }
    
    #[test]
    fn test_rejects_escapes() {
        let boundary = PathBoundary::try_new(".").unwrap();
        
        // Verify security properties
        assert!(save_user_data(&amp;boundary, "../../../etc/passwd", b"data").is_err());
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Testing benefits:</strong></p>
<ul>
<li>Pass <code>&amp;boundary</code> into helpers for easy mocking</li>
<li>Test with different boundaries (temp dirs, test fixtures)</li>
<li>Verify security properties with escape attempt tests</li>
<li>No need to mock filesystem for unit tests</li>
</ul>
<p><strong>Debug verbosity</strong>: <code>VirtualPath::Debug</code> is intentionally verbose (system path + virtual view + restriction root + marker) to aid audits and troubleshooting.</p>
<hr />
<h2 id="when-not-to-use-policy-types"><a class="header" href="#when-not-to-use-policy-types">When Not to Use Policy Types</a></h2>
<p>If your flow is small, local, and won't be reused, the sugar constructors are perfectly fine:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

// ✅ Fine for simple, one-off operations
fn quick_write() -&gt; std::io::Result&lt;()&gt; {
    let file = StrictPath::with_boundary_create("./temp")?
        .strict_join("quick.txt")?;
    file.write(b"data")
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rule of thumb</strong>: Start with sugar; upgrade to <code>PathBoundary</code>/<code>VirtualRoot</code> when you need:</p>
<ul>
<li>Policy reuse across multiple operations</li>
<li>Performance optimization (many joins against same root)</li>
<li>Serde integration with contextual deserialization</li>
<li>Testability with injectable boundaries</li>
<li>Shared helpers that accept boundaries</li>
</ul>
<hr />
<h2 id="summary-when-to-use-what"><a class="header" href="#summary-when-to-use-what">Summary: When to Use What</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Use Sugar Constructor</th><th>Use Policy Type</th></tr></thead><tbody>
<tr><td><strong>One-off file operation</strong></td><td>✅ <code>with_boundary()</code></td><td>Optional</td></tr>
<tr><td><strong>Multiple joins against root</strong></td><td>⚠️ Suboptimal</td><td>✅ <code>PathBoundary</code></td></tr>
<tr><td><strong>Reusable helper functions</strong></td><td>❌ Hidden policy choice</td><td>✅ Accept <code>&amp;PathBoundary</code></td></tr>
<tr><td><strong>Performance-critical loops</strong></td><td>❌ Repeated canonicalization</td><td>✅ Canonicalize once</td></tr>
<tr><td><strong>Serde deserialization</strong></td><td>❌ No validation context</td><td>✅ Use serde seeds</td></tr>
<tr><td><strong>Testing with mock boundaries</strong></td><td>❌ Hard to inject</td><td>✅ Pass <code>&amp;PathBoundary</code> param</td></tr>
<tr><td><strong>Simple scripts/prototypes</strong></td><td>✅ Quick and ergonomic</td><td>Optional</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="learn-more-4"><a class="header" href="#learn-more-4">Learn More</a></h2>
<ul>
<li><strong><a href="best_practices/../best_practices.html">Best Practices Overview →</a></strong> - Core guidelines and decision matrices</li>
<li><strong><a href="best_practices/./real_world_patterns.html">Real-World Patterns →</a></strong> - Production examples showing policy reuse</li>
<li><strong><a href="best_practices/./common_operations.html">Common Operations →</a></strong> - How to use paths after validation</li>
<li><strong><a href="best_practices/./authorization_architecture.html">Authorization Patterns →</a></strong> - Markers for compile-time authorization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization-architecture-with-markers"><a class="header" href="#authorization-architecture-with-markers">Authorization Architecture with Markers</a></h1>
<blockquote>
<p><em>Move authorization bugs from "runtime disasters" into "won't compile" problems.</em></p>
</blockquote>
<p>Marker types enable <strong>compile-time authorization architectures</strong> where the compiler mathematically proves that any path with an authorization-requiring marker went through proper authorization.</p>
<p>This chapter shows three levels of authorization patterns: basic authentication, permission tuples, and dynamic elevation.</p>
<hr />
<h2 id="core-concept-markers-as-proof"><a class="header" href="#core-concept-markers-as-proof">Core Concept: Markers as Proof</a></h2>
<p><strong>Key insight</strong>: A marker with a private field can <strong>only be constructed</strong> by authorized code. Functions requiring that marker have compile-time proof that authorization happened.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserHome { 
    _proof: ()  // Private field = can't construct outside this module
}

// This function signature enforces authentication
fn read_user_file(file: &amp;strict_path::StrictPath&lt;UserHome&gt;) -&gt; std::io::Result&lt;String&gt; {
    // Guaranteed: path is validated AND user was authenticated
    file.read_to_string()
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Without a <code>UserHome</code> marker, you cannot call <code>read_user_file()</code>.</strong> The compiler enforces this.</p>
<hr />
<h2 id="level-1-basic-authentication-markers"><a class="header" href="#level-1-basic-authentication-markers">Level 1: Basic Authentication Markers</a></h2>
<p>Use markers with private fields to prove authentication happened.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Marker describes user's home directory with compile-time proof
struct UserHome { 
    _proof: ()  // Private field prevents construction outside this module
}

impl UserHome {
    /// Authenticates user and returns authorization marker
    pub fn authenticate(token: &amp;AuthToken) -&gt; Result&lt;Self, AuthError&gt; {
        // Real authentication logic here (verify JWT, session, etc.)
        if verify_token(token)? {
            Ok(UserHome { _proof: () })  // Grant marker after verification
        } else {
            Err(AuthError::InvalidToken)
        }
    }
}

// Functions require pre-authorized paths
fn read_user_file(file: &amp;StrictPath&lt;UserHome&gt;) -&gt; std::io::Result&lt;String&gt; {
    // Guaranteed: path is safe AND user was authenticated
    file.read_to_string()
}

fn list_user_files(dir: &amp;PathBoundary&lt;UserHome&gt;) -&gt; std::io::Result&lt;Vec&lt;String&gt;&gt; {
    let mut names = Vec::new();
    for entry in dir.strict_join("")?.read_dir()? {
        let entry = entry?;
        names.push(entry.file_name().to_string_lossy().to_string());
    }
    Ok(names)
}

// Usage: authentication required to get marker
fn handle_request(
    token: &amp;AuthToken,
    filename: &amp;str
) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    // Authentication checkpoint
    let _auth = UserHome::authenticate(token)?;
    
    // Create boundary with authorized marker
    let username = token.username();
    let home_dir = PathBoundary::&lt;UserHome&gt;::try_new(format!("/home/{username}"))?;
    
    // Path inherits authorization from boundary
    let file = home_dir.strict_join(filename)?;
    
    // Function call proves authentication happened
    Ok(read_user_file(&amp;file)?)
}

// Stub types for example
struct AuthToken { username: String }
impl AuthToken {
    fn username(&amp;self) -&gt; &amp;str { &amp;self.username }
}
enum AuthError { InvalidToken }
fn verify_token(_token: &amp;AuthToken) -&gt; Result&lt;(), AuthError&gt; { Ok(()) }
<span class="boring">}</span></code></pre></pre>
<h3 id="key-pattern-elements"><a class="header" href="#key-pattern-elements">Key Pattern Elements</a></h3>
<ol>
<li><strong>Private <code>_proof</code> field</strong> prevents external construction</li>
<li><strong><code>authenticate()</code> constructor</strong> verifies credentials before granting marker</li>
<li><strong>Functions accept <code>&amp;StrictPath&lt;UserHome&gt;</code></strong> = compile-time proof</li>
<li><strong>Wrong marker = compile error</strong> (can't pass <code>StrictPath&lt;AdminFiles&gt;</code> to <code>read_user_file()</code>)</li>
</ol>
<p><strong>Benefits:</strong></p>
<ul>
<li>Impossible to bypass authentication (can't construct marker without verifying)</li>
<li>Refactoring changes propagate through type system</li>
<li>Authentication logic centralized in marker constructor</li>
</ul>
<hr />
<h2 id="level-2-tuple-markers-for-permissions"><a class="header" href="#level-2-tuple-markers-for-permissions">Level 2: Tuple Markers for Permissions</a></h2>
<p>Encode <strong>both domain and permission level</strong> in the type using tuple markers.</p>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Domain markers
struct SystemFiles;
struct UserDocuments;

// Permission markers (private construction)
struct ReadOnly { _proof: () }
struct ReadWrite { _proof: () }
struct AdminPermission { _proof: () }

impl ReadOnly {
    pub fn grant_read(user: &amp;User) -&gt; Result&lt;Self, PermissionError&gt; {
        if user.can_read_system_files() {
            Ok(ReadOnly { _proof: () })
        } else {
            Err(PermissionError::Denied)
        }
    }
}

impl ReadWrite {
    pub fn grant_write(user: &amp;User) -&gt; Result&lt;Self, PermissionError&gt; {
        if user.can_write_documents() {
            Ok(ReadWrite { _proof: () })
        } else {
            Err(PermissionError::Denied)
        }
    }
}

impl AdminPermission {
    pub fn grant_admin(user: &amp;User) -&gt; Result&lt;Self, PermissionError&gt; {
        if user.is_admin() {
            Ok(AdminPermission { _proof: () })
        } else {
            Err(PermissionError::Denied)
        }
    }
}

// Functions encode both domain and permission requirements
fn view_system_file(
    path: &amp;StrictPath&lt;(SystemFiles, ReadOnly)&gt;
) -&gt; std::io::Result&lt;String&gt; {
    path.read_to_string()  // Can read but not modify
}

fn modify_system_file(
    path: &amp;StrictPath&lt;(SystemFiles, AdminPermission)&gt;,
    data: &amp;[u8]
) -&gt; std::io::Result&lt;()&gt; {
    path.write(data)  // Requires admin permission
}

fn edit_user_document(
    path: &amp;StrictPath&lt;(UserDocuments, ReadWrite)&gt;,
    data: &amp;[u8]
) -&gt; std::io::Result&lt;()&gt; {
    path.write(data)  // User documents + write permission
}

// Usage: Permission matrix enforced at compile time
fn user_workflow(user: &amp;User) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Grant appropriate permissions
    let _read_perm = ReadOnly::grant_read(user)?;
    let _write_perm = ReadWrite::grant_write(user)?;
    
    // Create boundaries with permission markers
    let system_dir = PathBoundary::&lt;(SystemFiles, ReadOnly)&gt;::try_new("/etc")?;
    let docs_dir = PathBoundary::&lt;(UserDocuments, ReadWrite)&gt;::try_new("/home/user/docs")?;
    
    // Operations matched to permissions
    let config = system_dir.strict_join("app.conf")?;
    let content = view_system_file(&amp;config)?;  // ✅ ReadOnly matches
    
    let doc = docs_dir.strict_join("notes.txt")?;
    edit_user_document(&amp;doc, b"updated")?;  // ✅ ReadWrite matches
    
    // ❌ Compile error: wrong permission level
    // modify_system_file(&amp;config, b"hacked")?;
    //   Expected: (SystemFiles, AdminPermission)
    //   Found:    (SystemFiles, ReadOnly)
    
    Ok(())
}

// Stub types
struct User { role: Role }
enum Role { Regular, Admin }
impl User {
    fn can_read_system_files(&amp;self) -&gt; bool { true }
    fn can_write_documents(&amp;self) -&gt; bool { !matches!(self.role, Role::Admin) }
    fn is_admin(&amp;self) -&gt; bool { matches!(self.role, Role::Admin) }
}
enum PermissionError { Denied }
<span class="boring">}</span></code></pre></pre>
<h3 id="permission-matrix-enforced-by-compiler"><a class="header" href="#permission-matrix-enforced-by-compiler">Permission Matrix Enforced by Compiler</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Required Marker</th><th>What it Proves</th></tr></thead><tbody>
<tr><td><code>view_system_file()</code></td><td><code>(SystemFiles, ReadOnly)</code></td><td>Domain = system, Permission = read</td></tr>
<tr><td><code>modify_system_file()</code></td><td><code>(SystemFiles, AdminPermission)</code></td><td>Domain = system, Permission = admin</td></tr>
<tr><td><code>edit_user_document()</code></td><td><code>(UserDocuments, ReadWrite)</code></td><td>Domain = user docs, Permission = write</td></tr>
</tbody></table>
</div>
<p><strong>Key insight</strong>: Wrong domain OR wrong permission = compile error. The type system enforces your entire permission matrix.</p>
<hr />
<h2 id="level-3-dynamic-authorization-with-change_marker"><a class="header" href="#level-3-dynamic-authorization-with-change_marker">Level 3: Dynamic Authorization with <code>change_marker()</code></a></h2>
<p>Sometimes permission levels change after <strong>runtime checks</strong>. Use <code>change_marker()</code> to transform markers after verification.</p>
<h3 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct Documents;
struct ReadOnly { _proof: () }
struct ReadWrite { _proof: () }

impl ReadWrite {
    fn elevate(user: &amp;User) -&gt; Result&lt;Self, PermissionError&gt; {
        if user.has_write_permission() {
            Ok(ReadWrite { _proof: () })
        } else {
            Err(PermissionError::Denied)
        }
    }
}

fn escalate_permissions(
    user: &amp;User,
    file: StrictPath&lt;(Documents, ReadOnly)&gt;
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Start with read-only access
    let content = file.read_to_string()?;
    println!("Current content: {content}");
    
    // Check if user can write
    if let Ok(_write_perm) = ReadWrite::elevate(user) {
        // ✅ CORRECT: change_marker() after authorization check
        let writable: StrictPath&lt;(Documents, ReadWrite)&gt; = file.change_marker();
        writable.write(b"updated content")?;
        println!("Updated successfully");
    } else {
        println!("Read-only access - cannot modify");
    }
    
    Ok(())
}

// Stub types
struct User { can_write: bool }
impl User {
    fn has_write_permission(&amp;self) -&gt; bool { self.can_write }
}
enum PermissionError { Denied }
<span class="boring">}</span></code></pre></pre>
<h3 id="critical-rule-verify-before-transform"><a class="header" href="#critical-rule-verify-before-transform">Critical Rule: Verify Before Transform</a></h3>
<p><strong>NEVER use <code>change_marker()</code> without authorization:</strong></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct Documents;
struct ReadOnly;
struct ReadWrite;

// ❌ WRONG: Speculative marker change without verification
fn escalate_wrong(file: StrictPath&lt;(Documents, ReadOnly)&gt;) -&gt; StrictPath&lt;(Documents, ReadWrite)&gt; {
    file.change_marker()  // No authorization check!
}

// ✅ CORRECT: Verify authorization first
fn escalate_correct(
    user: &amp;User,
    file: StrictPath&lt;(Documents, ReadOnly)&gt;
) -&gt; Result&lt;StrictPath&lt;(Documents, ReadWrite)&gt;, PermissionError&gt; {
    if user.has_write_permission() {
        Ok(file.change_marker())  // Transform after verification
    } else {
        Err(PermissionError::Denied)
    }
}

struct User { can_write: bool }
impl User {
    fn has_write_permission(&amp;self) -&gt; bool { self.can_write }
}
enum PermissionError { Denied }
<span class="boring">}</span></code></pre></pre>
<p><strong>When to use <code>change_marker()</code>:</strong></p>
<ul>
<li>After authenticating/authorizing a user and granting different permissions</li>
<li>When escalating or downgrading access levels based on runtime checks</li>
<li>When reinterpreting a path's security context after validation</li>
</ul>
<p><strong>When NOT to use <code>change_marker()</code>:</strong></p>
<ul>
<li>When converting between path types (conversions preserve markers automatically)</li>
<li>Without verifying authorization first (NEVER change markers speculatively)</li>
</ul>
<hr />
<h2 id="architecture-comparison-table"><a class="header" href="#architecture-comparison-table">Architecture Comparison Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Marker Pattern</th><th>Compile-Time Guarantee</th><th>Runtime Check Location</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Basic Auth</strong></td><td><code>StrictPath&lt;UserHome&gt;</code></td><td>User was authenticated</td><td>Marker construction</td><td>Prove login happened</td></tr>
<tr><td><strong>Permissions</strong></td><td><code>StrictPath&lt;(Domain, Permission)&gt;</code></td><td>User has specific permission in domain</td><td>Permission grant</td><td>Enforce permission matrix</td></tr>
<tr><td><strong>Dynamic</strong></td><td><code>change_marker()</code> after check</td><td>Authorization verified before transform</td><td>Before <code>change_marker()</code></td><td>Runtime permission escalation</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="real-world-example-multi-level-authorization"><a class="header" href="#real-world-example-multi-level-authorization">Real-World Example: Multi-Level Authorization</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Domain markers
struct ProjectFiles;

// Permission markers
struct Viewer { _proof: () }
struct Editor { _proof: () }
struct Owner { _proof: () }

impl Viewer {
    fn authenticate(user: &amp;User, project_id: &amp;str) -&gt; Result&lt;Self, AuthError&gt; {
        if user.can_view(project_id) {
            Ok(Viewer { _proof: () })
        } else {
            Err(AuthError::Forbidden)
        }
    }
}

impl Editor {
    fn promote_from_viewer(user: &amp;User, project_id: &amp;str) -&gt; Result&lt;Self, AuthError&gt; {
        if user.can_edit(project_id) {
            Ok(Editor { _proof: () })
        } else {
            Err(AuthError::Forbidden)
        }
    }
}

impl Owner {
    fn promote_from_editor(user: &amp;User, project_id: &amp;str) -&gt; Result&lt;Self, AuthError&gt; {
        if user.is_owner(project_id) {
            Ok(Owner { _proof: () })
        } else {
            Err(AuthError::Forbidden)
        }
    }
}

// Functions with different permission requirements
fn read_project_file(file: &amp;StrictPath&lt;(ProjectFiles, Viewer)&gt;) -&gt; std::io::Result&lt;String&gt; {
    file.read_to_string()
}

fn update_project_file(
    file: &amp;StrictPath&lt;(ProjectFiles, Editor)&gt;,
    data: &amp;[u8]
) -&gt; std::io::Result&lt;()&gt; {
    file.write(data)
}

fn delete_project(dir: &amp;PathBoundary&lt;(ProjectFiles, Owner)&gt;) -&gt; std::io::Result&lt;()&gt; {
    std::fs::remove_dir_all(dir.strict_join("")?.interop_path())
}

// Workflow: Dynamic permission escalation
fn handle_project_request(
    user: &amp;User,
    project_id: &amp;str,
    action: Action
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Step 1: Basic authentication
    let _viewer = Viewer::authenticate(user, project_id)?;
    let project_dir = PathBoundary::&lt;(ProjectFiles, Viewer)&gt;::try_new(
        format!("/projects/{project_id}")
    )?;
    
    match action {
        Action::Read(filename) =&gt; {
            let file = project_dir.strict_join(&amp;filename)?;
            let content = read_project_file(&amp;file)?;
            println!("Content: {content}");
        },
        
        Action::Edit(filename, data) =&gt; {
            // Step 2: Escalate to Editor
            let _editor = Editor::promote_from_viewer(user, project_id)?;
            let project_dir_edit: PathBoundary&lt;(ProjectFiles, Editor)&gt; = 
                project_dir.change_marker();
            
            let file = project_dir_edit.strict_join(&amp;filename)?;
            update_project_file(&amp;file, data.as_bytes())?;
        },
        
        Action::Delete =&gt; {
            // Step 3: Escalate to Owner
            let _owner = Owner::promote_from_editor(user, project_id)?;
            let project_dir_owner: PathBoundary&lt;(ProjectFiles, Owner)&gt; = 
                project_dir.change_marker();
            
            delete_project(&amp;project_dir_owner)?;
        },
    }
    
    Ok(())
}

// Stub types
struct User { id: String, permissions: Vec&lt;String&gt; }
impl User {
    fn can_view(&amp;self, _project: &amp;str) -&gt; bool { true }
    fn can_edit(&amp;self, project: &amp;str) -&gt; bool { 
        self.permissions.contains(&amp;format!("edit:{project}"))
    }
    fn is_owner(&amp;self, project: &amp;str) -&gt; bool {
        self.permissions.contains(&amp;format!("own:{project}"))
    }
}
enum Action { Read(String), Edit(String, String), Delete }
enum AuthError { Forbidden }
<span class="boring">}</span></code></pre></pre>
<p><strong>Key patterns in this example:</strong></p>
<ul>
<li>Viewer → Editor → Owner escalation chain</li>
<li>Each level requires explicit runtime check</li>
<li><code>change_marker()</code> called after verification</li>
<li>Compiler prevents calling higher-privilege functions with lower-privilege markers</li>
</ul>
<hr />
<h2 id="summary-authorization-levels"><a class="header" href="#summary-authorization-levels">Summary: Authorization Levels</a></h2>
<p><strong>Choose the right level for your needs:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Need</th><th>Use Pattern</th><th>Example</th></tr></thead><tbody>
<tr><td><strong>Prove login happened</strong></td><td>Basic marker</td><td><code>StrictPath&lt;UserHome&gt;</code></td></tr>
<tr><td><strong>Enforce permission matrix</strong></td><td>Tuple markers</td><td><code>StrictPath&lt;(Domain, Permission)&gt;</code></td></tr>
<tr><td><strong>Runtime permission changes</strong></td><td><code>change_marker()</code> after check</td><td><code>file.change_marker::&lt;ReadWrite&gt;()</code></td></tr>
</tbody></table>
</div>
<p><strong>Core principle</strong>: Move authorization from "runtime checks we hope happen" to "compile-time proofs the compiler enforces."</p>
<hr />
<h2 id="learn-more-5"><a class="header" href="#learn-more-5">Learn More</a></h2>
<ul>
<li><strong><a href="best_practices/../best_practices.html">Best Practices Overview →</a></strong> - Core guidelines and decision matrices</li>
<li><strong><a href="best_practices/./policy_and_reuse.html">Policy &amp; Reuse Patterns →</a></strong> - Why and when to use policy types</li>
<li><strong><a href="best_practices/./real_world_patterns.html">Real-World Patterns →</a></strong> - Production examples with authorization</li>
<li><strong><a href="best_practices/./common_operations.html">Common Operations →</a></strong> - How to use authorized paths</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-mistakes-to-avoid"><a class="header" href="#common-mistakes-to-avoid">Common Mistakes to Avoid</a></h1>
<p>Here are the most common mistakes developers make with strict-path, and how to fix them.</p>
<h2 id="the-big-picture-dont-defeat-your-own-security"><a class="header" href="#the-big-picture-dont-defeat-your-own-security">The Big Picture: Don't Defeat Your Own Security</a></h2>
<p>Most anti-patterns come down to one thing: <strong>treating strict-path types like regular paths</strong>. When you convert back to <code>Path</code> or <code>String</code>, you're throwing away the safety you worked to create.</p>
<p>The core principle is: <strong>make functions safe by design</strong>. Instead of accepting raw strings and validating inside every function, accept safe types that guarantee the validation already happened.</p>
<h2 id="security-theater-only-validating-constants"><a class="header" href="#security-theater-only-validating-constants">Security Theater: Only Validating Constants</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_dir = PathBoundary::try_new("./config")?;
let settings = config_dir.strict_join("settings.toml")?;  // Only literals!
let cache = config_dir.strict_join("cache")?;            // No user input validated
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> You're using strict-path but never validating untrusted input. This provides no security value—it's just security theater that looks safe but protects nothing.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config_dir = PathBoundary::try_new("./config")?;
// Actually validate untrusted input from users, HTTP, databases, archives, etc.
let user_file = config_dir.strict_join(&amp;user_provided_filename)?;
let archive_entry = config_dir.strict_join(&amp;entry_name_from_zip)?;
let db_path = config_dir.strict_join(&amp;path_from_database)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="hidden-policy-decisions-in-functions"><a class="header" href="#hidden-policy-decisions-in-functions">Hidden Policy Decisions in Functions</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_user_data(filename: &amp;str) -&gt; Result&lt;String, Error&gt; {
    // Policy hidden inside the function!
    let data_dir = PathBoundary::try_new("./userdata")?;
    let file = data_dir.strict_join(filename)?;
    file.read_to_string()
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> Callers can't see or control the security policy. What if they want a different directory? What if different users need different boundaries? The function makes security decisions that should be visible.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_user_data(user_dir: &amp;PathBoundary, filename: &amp;str) -&gt; std::io::Result&lt;String&gt; {
    let file = user_dir.strict_join(filename)?;
    file.read_to_string()
}

// OR even better - accept the validated path directly:
fn load_user_data(file_path: &amp;StrictPath) -&gt; std::io::Result&lt;String&gt; {
    file_path.read_to_string()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="converting-back-to-unsafe-types"><a class="header" href="#converting-back-to-unsafe-types">Converting Back to Unsafe Types</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let safe_path = uploads_dir.strict_join("photo.jpg")?;
// WHY are you converting back to the unsafe Path type?!
if Path::new(safe_path.interop_path()).exists() {
    std::fs::copy(
        Path::new(safe_path.interop_path()), 
        "./backup/photo.jpg"
    )?;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> <code>StrictPath</code> already has <code>.exists()</code>, <code>.read()</code>, <code>.write()</code>, and other methods. You're defeating the entire point by converting back to <code>Path</code>, which ignores all security restrictions.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let safe_path = uploads_dir.strict_join("photo.jpg")?;
if safe_path.exists() {
    let backup_dir = PathBoundary::try_new("./backup")?;
    let backup_path = backup_dir.strict_join("photo.jpg")?;
    safe_path.strict_copy(backup_path.interop_path())?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-std-path-operations-on-leaked-values"><a class="header" href="#using-std-path-operations-on-leaked-values">Using std Path Operations on Leaked Values</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uploads_dir = PathBoundary::try_new("uploads")?;
let leaked = Path::new(uploads_dir.interop_path());
let dangerous = leaked.join("../../../etc/passwd");  // Can escape!
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> <code>Path::join()</code> is the #1 cause of path traversal vulnerabilities. It completely replaces the base path when you pass an absolute path, ignoring all security restrictions.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uploads_dir = PathBoundary::try_new("uploads")?;
// This will return an error instead of escaping:
let safe_result = uploads_dir.strict_join("../../../etc/passwd");
match safe_result {
    Ok(path) =&gt; println!("Safe path: {}", path.strictpath_display()),
    Err(e) =&gt; println!("Rejected dangerous path: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="wrong-display-method"><a class="header" href="#wrong-display-method">Wrong Display Method</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Processing: {}", file.interop_path().to_string_lossy());
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> <code>interop_path()</code> is for passing to external APIs that need <code>AsRef&lt;Path&gt;</code>, like <code>std::fs::File::open()</code>. For displaying to users, it's the wrong tool and can lose information.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Processing: {}", file.strictpath_display());

// For VirtualPath:
println!("Virtual path: {}", vpath.virtualpath_display());

// For VirtualRoot:
println!("Root: {}", vroot.as_unvirtual().strictpath_display());
<span class="boring">}</span></code></pre></pre>
<h2 id="terrible-variable-names"><a class="header" href="#terrible-variable-names">Terrible Variable Names</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let boundary = PathBoundary::try_new("./uploads")?;
let restriction = PathBoundary::try_new("./config")?;
let jail = VirtualRoot::try_new("./user_data")?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> These names tell you the type but nothing about what the directories are for. When you see <code>boundary.strict_join("photo.jpg")</code>, you have no idea what boundary you're joining to.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uploads_dir = PathBoundary::try_new("./uploads")?;
let config_dir = PathBoundary::try_new("./config")?;
let user_data = VirtualRoot::try_new("./user_data")?;
<span class="boring">}</span></code></pre></pre>
<p>Now <code>uploads_dir.strict_join("photo.jpg")</code> reads naturally as "uploads directory join photo.jpg".</p>
<h2 id="functions-that-accept-dangerous-inputs"><a class="header" href="#functions-that-accept-dangerous-inputs">Functions That Accept Dangerous Inputs</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_file(filename: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    // Every function has to validate - error prone!
    let uploads = PathBoundary::try_new("uploads")?;
    let safe_path = uploads.strict_join(filename)?;
    safe_path.write(data)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> Every caller has to trust that this function validates correctly. Someone could call <code>save_file("../../../etc/passwd", data)</code> and you're relying on runtime validation instead of the type system.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_file(safe_path: &amp;StrictPath, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    safe_path.write(data)  // Already guaranteed safe!
}
<span class="boring">}</span></code></pre></pre>
<p>Now it's <strong>impossible</strong> to call this function unsafely. The validation happens once when creating the <code>StrictPath</code>, and the type system prevents all misuse.</p>
<h2 id="multi-user-data-with-single-boundary"><a class="header" href="#multi-user-data-with-single-boundary">Multi-User Data with Single Boundary</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Global boundary for all users - dangerous!
static UPLOADS: PathBoundary = /* ... */;

fn save_user_file(user_id: u64, filename: &amp;str, data: &amp;[u8]) {
    // All users share the same directory - data mixing risk!
    let path = UPLOADS.strict_join(&amp;format!("{}/{}", user_id, filename))?;
    path.write(data)?;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why it's wrong:</strong> All users share the same boundary, making it easy to accidentally access another user's files or create insecure paths.</p>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_user_root(user_id: u64) -&gt; Result&lt;VirtualRoot&lt;UserData&gt;, Error&gt; {
    let user_dir = format!("./users/{}", user_id);
    VirtualRoot::try_new(user_dir)
}

fn save_user_file(user_root: &amp;VirtualRoot&lt;UserData&gt;, filename: &amp;str, data: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
    let safe_path = user_root.virtual_join(filename)?.as_unvirtual();
    safe_path.write(data)?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="redundant-method-chaining"><a class="header" href="#redundant-method-chaining">Redundant Method Chaining</a></h2>
<p><strong>❌ What not to do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Redundant .as_ref() call
external_api(path.interop_path().as_ref());

// Redundant unvirtualization 
vroot.as_unvirtual().interop_path();  // VirtualRoot already has interop_path()!
<span class="boring">}</span></code></pre></pre>
<p><strong>✅ Do this instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// interop_path() already implements AsRef&lt;Path&gt;
external_api(path.interop_path());

// VirtualRoot and VirtualPath have interop_path() directly
vroot.interop_path();
vpath.interop_path();
<span class="boring">}</span></code></pre></pre>
<h2 id="quick-reference-bad--good"><a class="header" href="#quick-reference-bad--good">Quick Reference: Bad → Good</a></h2>
<div class="table-wrapper"><table><thead><tr><th>❌ Bad Pattern</th><th>✅ Good Pattern</th></tr></thead><tbody>
<tr><td><code>Path::new(secure_path.interop_path()).exists()</code></td><td><code>secure_path.exists()</code></td></tr>
<tr><td><code>println!("{}", path.interop_path().to_string_lossy())</code></td><td><code>println!("{}", path.strictpath_display())</code></td></tr>
<tr><td><code>fn process(path: &amp;str)</code></td><td><code>fn process(path: &amp;StrictPath&lt;_&gt;)</code></td></tr>
<tr><td><code>let boundary = PathBoundary::try_new(...)?</code></td><td><code>let uploads_dir = PathBoundary::try_new(...)?</code></td></tr>
<tr><td><code>leaked_path.join("child")</code></td><td><code>secure_path.strict_join("child")?</code></td></tr>
<tr><td><code>vroot.as_unvirtual().interop_path()</code></td><td><code>vroot.interop_path()</code></td></tr>
<tr><td><code>path.interop_path().as_ref()</code></td><td><code>path.interop_path()</code></td></tr>
</tbody></table>
</div>
<h2 id="the-golden-rules"><a class="header" href="#the-golden-rules">The Golden Rules</a></h2>
<ol>
<li><strong>Never convert secure types back to <code>Path</code>/<code>PathBuf</code></strong> - use their native methods instead</li>
<li><strong>Make functions accept safe types</strong> - don't validate inside every function</li>
<li><strong>Name variables by purpose, not type</strong> - <code>config_dir</code> not <code>boundary</code></li>
<li><strong>Use the right method for the job</strong> - <code>strictpath_display()</code> for display, <code>interop_path()</code> for external APIs</li>
<li><strong>Let callers control security policy</strong> - don't hide <code>PathBoundary</code> creation inside helpers</li>
<li><strong>Actually validate untrusted input</strong> - don't just validate constants</li>
</ol>
<p>Remember: The whole point of strict-path is to make path operations safe by design. If you find yourself converting back to regular paths or validating inside every function, you're probably doing it wrong!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ergonomics-overview"><a class="header" href="#ergonomics-overview">Ergonomics Overview</a></h1>
<p>This section collects high-signal, copy-pasteable guidance for day-to-day use without re-explaining the security model. Each page is short and focused so you can jump directly to what you need.</p>
<h2 id="new-to-strict-path"><a class="header" href="#new-to-strict-path">New to strict-path?</a></h2>
<p>Start with <strong>Daily Usage Patterns</strong> for common workflows and real-world examples.</p>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<ul>
<li><strong>Builtin I/O Operations</strong>: Complete guide to file/directory operations, when to use builtin methods vs <code>std::fs</code></li>
<li><strong>Generic Functions &amp; Markers</strong>: Write reusable functions with <code>&lt;M&gt;</code>, understand when to use generic vs specific markers</li>
<li><strong>Daily Usage Patterns</strong>: Common workflows (user input validation, config loading, per-user isolation, archive extraction, etc.)</li>
<li><strong>Interop vs Display</strong>: How to pass paths to std/third-party APIs vs how to render them for users</li>
<li><strong>Function Signatures</strong>: Encode guarantees in types; when to accept strict/virtual vs roots + segments</li>
<li><strong>Escape Hatches</strong>: Borrowing and ownership conversions; when to use them (sparingly)</li>
<li><strong>Equality &amp; Ordering</strong>: How comparisons work; what to compare and what not to</li>
<li><strong>Naming Conventions</strong>: Domain-first naming that teaches intent in code review</li>
<li><strong>Canonicalized vs Lexical</strong>: Choosing the right solution for your use case</li>
</ul>
<p>For in-depth design and security rationale, see Best Practices and Anti-Patterns. This section stays focused on ergonomics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin-io-operations"><a class="header" href="#builtin-io-operations">Builtin I/O Operations</a></h1>
<p><code>strict-path</code> provides safe I/O helpers that maintain boundary security while eliminating the need for raw <code>std::fs</code> calls on leaked paths.</p>
<h2 id="why-use-builtin-methods"><a class="header" href="#why-use-builtin-methods">Why Use Builtin Methods?</a></h2>
<p><strong>Security</strong>: All operations stay within validated boundaries<br />
<strong>Ergonomics</strong>: No need to call <code>.interop_path()</code> for common operations<br />
<strong>Correctness</strong>: Type-checked paths guarantee safety at compile time</p>
<h2 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h2>
<h3 id="reading-files"><a class="header" href="#reading-files">Reading Files</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

let config_dir = PathBoundary::try_new("/etc/myapp")?;
let config_file = config_dir.strict_join("config.toml")?;

// Read entire file as string
let contents = config_file.read_to_string()?;

// Read as bytes
let bytes = config_file.read()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="writing-files"><a class="header" href="#writing-files">Writing Files</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualRoot;

let user_docs = VirtualRoot::try_new("/home/user/documents")?;
let report = user_docs.virtual_join("reports/summary.txt")?;

// Ensure parent directories exist
report.create_parent_dir_all()?;

// Write string content
report.write("Monthly Summary\n\nTotal: 42")?;

// Write bytes
report.write_bytes(b"Binary data")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="file-handles"><a class="header" href="#file-handles">File Handles</a></h3>
<p>For streaming or more control, use file handles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{Read, Write};

// Create or truncate file, get writable handle
let mut file = report.create_file()?;
file.write_all(b"Line 1\n")?;
file.write_all(b"Line 2\n")?;

// Open for reading
let mut file = report.open_file()?;
let mut contents = String::new();
file.read_to_string(&amp;mut contents)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="directory-operations"><a class="header" href="#directory-operations">Directory Operations</a></h2>
<h3 id="creating-directories"><a class="header" href="#creating-directories">Creating Directories</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create single directory (parent must exist)
let subdir = config_dir.strict_join("plugins")?;
subdir.create_dir()?;

// Create all parent directories if missing
let nested = config_dir.strict_join("data/cache/temp")?;
nested.create_dir_all()?;

// Non-recursive variant (VirtualPath)
let vdir = user_docs.virtual_join("archive")?;
vdir.create_dir_non_recursive()?; // Fails if parent missing
<span class="boring">}</span></code></pre></pre>
<h3 id="listing-directory-contents"><a class="header" href="#listing-directory-contents">Listing Directory Contents</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Discovery: enumerate entries
for entry in config_dir.read_dir()? {
    let entry = entry?;
    let name = entry.file_name();
    
    // Re-validate discovered path before use
    let validated = config_dir.strict_join(&amp;name)?;
    println!("Found: {}", validated.strictpath_display());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="removing-directories"><a class="header" href="#removing-directories">Removing Directories</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove empty directory
subdir.remove_dir()?;

// Remove directory and all contents (dangerous!)
nested.remove_dir_all()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="metadata-operations"><a class="header" href="#metadata-operations">Metadata Operations</a></h2>
<h3 id="checking-existence-and-type"><a class="header" href="#checking-existence-and-type">Checking Existence and Type</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if path exists
if config_file.exists() {
    println!("Config file found");
}

// Check type
if config_file.is_file() {
    println!("It's a file");
}

if config_dir.is_dir() {
    println!("It's a directory");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-metadata"><a class="header" href="#getting-metadata">Getting Metadata</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get full metadata
let metadata = config_file.metadata()?;

println!("Size: {} bytes", metadata.len());
println!("Read-only: {}", metadata.permissions().readonly());
println!("Modified: {:?}", metadata.modified()?);
<span class="boring">}</span></code></pre></pre>
<h3 id="symlink-metadata-dont-follow-links"><a class="header" href="#symlink-metadata-dont-follow-links">Symlink Metadata (Don't Follow Links)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get metadata without following symlinks
let link_meta = config_file.symlink_metadata()?;

if link_meta.is_symlink() {
    println!("This is a symbolic link");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="copy-rename-and-link-operations"><a class="header" href="#copy-rename-and-link-operations">Copy, Rename, and Link Operations</a></h2>
<h3 id="copying-files"><a class="header" href="#copying-files">Copying Files</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let source = config_dir.strict_join("template.conf")?;
let dest = config_dir.strict_join("active.conf")?;

// Copy file, returns bytes copied
let bytes = source.strict_copy(&amp;dest)?;
println!("Copied {} bytes", bytes);
<span class="boring">}</span></code></pre></pre>
<h3 id="renamingmoving"><a class="header" href="#renamingmoving">Renaming/Moving</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let old_name = config_dir.strict_join("draft.txt")?;
let new_name = config_dir.strict_join("final.txt")?;

// Move/rename within same boundary
old_name.strict_rename(&amp;new_name)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-links"><a class="header" href="#creating-links">Creating Links</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Symbolic link
let target = config_dir.strict_join("current")?;
let link = config_dir.strict_join("link-to-current")?;
target.strict_symlink(&amp;link)?;

// Hard link
target.strict_hard_link(&amp;link)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="builtin-vs-stdfs-comparison"><a class="header" href="#builtin-vs-stdfs-comparison">Builtin vs std::fs Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th><code>strict-path</code></th><th><code>std::fs</code></th><th>Why Prefer Builtin?</th></tr></thead><tbody>
<tr><td>Read file</td><td><code>.read_to_string()?</code></td><td><code>fs::read_to_string(path.interop_path())?</code></td><td>Shorter, stays typed</td></tr>
<tr><td>Write file</td><td><code>.write("content")?</code></td><td><code>fs::write(path.interop_path(), "content")?</code></td><td>No interop needed</td></tr>
<tr><td>Copy file</td><td><code>.strict_copy(&amp;dest)?</code></td><td><code>fs::copy(src.interop_path(), dst.interop_path())?</code></td><td>Both paths validated</td></tr>
<tr><td>Metadata</td><td><code>.metadata()?</code></td><td><code>fs::metadata(path.interop_path())?</code></td><td>Cleaner, same result</td></tr>
<tr><td>Create dir</td><td><code>.create_dir_all()?</code></td><td><code>fs::create_dir_all(path.interop_path())?</code></td><td>Type-safe path</td></tr>
</tbody></table>
</div>
<h2 id="when-to-use-interop_path"><a class="header" href="#when-to-use-interop_path">When to Use interop_path()</a></h2>
<p><strong>Only for unavoidable third-party crates</strong> that demand <code>AsRef&lt;Path&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Third-party crate requires AsRef&lt;Path&gt;
let image = config_dir.strict_join("logo.png")?;
let img = image::open(image.interop_path())?; // No choice

// ❌ BAD: Using interop when builtin exists
std::fs::read_to_string(image.interop_path())?; // Use .read_to_string() instead

// ✅ GOOD: Use builtin
let contents = image.read_to_string()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="virtualpath-io-operations"><a class="header" href="#virtualpath-io-operations">VirtualPath I/O Operations</a></h2>
<p>All methods work on <code>VirtualPath</code> too, maintaining virtual display semantics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user_root = VirtualRoot::try_new("/var/lib/app/users/alice")?;
let doc = user_root.virtual_join("documents/readme.txt")?;

// All I/O operations available
doc.create_parent_dir_all()?;
doc.write("Welcome to your virtual filesystem!")?;

// Display shows virtual path
println!("Wrote to: {}", doc.virtualpath_display()); // "/documents/readme.txt"

// But I/O happens at real system location
println!("System location: {}", doc.as_unvirtual().strictpath_display());
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<p><strong>No overhead</strong>: Builtin methods call <code>std::fs</code> internally with zero abstraction cost.<br />
<strong>Same syscalls</strong>: Operations compile to identical machine code as direct <code>std::fs</code> usage.<br />
<strong>Validation cost</strong>: Only paid once during <code>strict_join</code>/<code>virtual_join</code>, not on every I/O operation.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li><strong>Use builtin methods for all common I/O operations</strong></li>
<li><strong>Reserve <code>.interop_path()</code> for third-party crates</strong></li>
<li><strong>Both <code>StrictPath</code> and <code>VirtualPath</code> support the full I/O API</strong></li>
<li><strong>No performance penalty vs raw <code>std::fs</code></strong></li>
<li><strong>Type safety and boundary security maintained automatically</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-functions-and-marker-patterns"><a class="header" href="#generic-functions-and-marker-patterns">Generic Functions and Marker Patterns</a></h1>
<p>Learn how to write reusable functions that work with any marker type using Rust's generics.</p>
<h2 id="the-m-pattern"><a class="header" href="#the-m-pattern">The <code>&lt;M&gt;</code> Pattern</a></h2>
<p>When you write <code>&lt;M&gt;</code>, you're saying "this function works with paths of <strong>any</strong> marker type."</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

// ✅ Generic: works with any marker
fn get_size&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; std::io::Result&lt;u64&gt; {
    Ok(path.metadata()?.len())
}

// Can call with any marker type
let config: StrictPath&lt;ConfigDir&gt; = ...;
let uploads: StrictPath&lt;UserUploads&gt; = ...;

let config_size = get_size(&amp;config)?;   // M = ConfigDir
let upload_size = get_size(&amp;uploads)?;  // M = UserUploads
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-generic-functions"><a class="header" href="#when-to-use-generic-functions">When to Use Generic Functions</a></h2>
<p><strong>Use <code>&lt;M&gt;</code> when:</strong></p>
<ul>
<li>Function logic doesn't care about the specific marker</li>
<li>You're building reusable utilities</li>
<li>The operation applies to any path type</li>
</ul>
<p><strong>Use specific markers when:</strong></p>
<ul>
<li>Function requires specific authorization level</li>
<li>Business logic depends on path context</li>
<li>Type safety prevents mixing different domains</li>
</ul>
<h2 id="common-generic-patterns"><a class="header" href="#common-generic-patterns">Common Generic Patterns</a></h2>
<h3 id="pattern-1-generic-helpers"><a class="header" href="#pattern-1-generic-helpers">Pattern 1: Generic Helpers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Read and parse JSON from any path
fn read_json&lt;M, T: serde::de::DeserializeOwned&gt;(
    path: &amp;StrictPath&lt;M&gt;
) -&gt; Result&lt;T, Box&lt;dyn std::error::Error&gt;&gt; {
    let contents = path.read_to_string()?;
    Ok(serde_json::from_str(&amp;contents)?)
}

// Works with any marker
let config: Config = read_json(&amp;config_path)?;
let data: UserData = read_json(&amp;user_path)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-generic-validation"><a class="header" href="#pattern-2-generic-validation">Pattern 2: Generic Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Ensure path exists and is a file
fn validate_file&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; std::io::Result&lt;()&gt; {
    if !path.exists() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            format!("File not found: {}", path.strictpath_display())
        ));
    }
    
    if !path.is_file() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            "Path is not a file"
        ));
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-generic-logging"><a class="header" href="#pattern-3-generic-logging">Pattern 3: Generic Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::info;

/// Log path access for audit trail
fn log_access&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;, operation: &amp;str) {
    info!(
        operation = operation,
        path = %path.strictpath_display(),
        "Path accessed"
    );
}

// Use in your code
log_access(&amp;user_file, "read");
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-4-generic-directory-processing"><a class="header" href="#pattern-4-generic-directory-processing">Pattern 4: Generic Directory Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Count files in directory
fn count_files&lt;M&gt;(dir: &amp;StrictPath&lt;M&gt;) -&gt; std::io::Result&lt;usize&gt; {
    let mut count = 0;
    
    for entry in dir.read_dir()? {
        let entry = entry?;
        if entry.metadata()?.is_file() {
            count += 1;
        }
    }
    
    Ok(count)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="specific-marker-functions"><a class="header" href="#specific-marker-functions">Specific Marker Functions</a></h2>
<p>Sometimes you want <strong>exactly</strong> the right marker type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserData;
struct ConfigDir;

// ✅ Only accepts UserData paths
fn process_user_file(file: &amp;StrictPath&lt;UserData&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let contents = file.read_to_string()?;
    // Process user-specific data
    Ok(())
}

// ✅ Only accepts ConfigDir paths
fn load_config(config: &amp;StrictPath&lt;ConfigDir&gt;) -&gt; Result&lt;AppConfig, Box&lt;dyn std::error::Error&gt;&gt; {
    let contents = config.read_to_string()?;
    Ok(toml::from_str(&amp;contents)?)
}

// ❌ Won't compile: wrong marker type
let user_file: StrictPath&lt;UserData&gt; = ...;
load_config(&amp;user_file); // ERROR: expected ConfigDir, found UserData
<span class="boring">}</span></code></pre></pre>
<h2 id="generic-virtualpath-functions"><a class="header" href="#generic-virtualpath-functions">Generic VirtualPath Functions</a></h2>
<p>The same patterns work for <code>VirtualPath</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualPath;

/// Generic file writer
fn write_log&lt;M&gt;(path: &amp;VirtualPath&lt;M&gt;, message: &amp;str) -&gt; std::io::Result&lt;()&gt; {
    path.create_parent_dir_all()?;
    path.write(format!("[{}] {}\n", chrono::Utc::now(), message))
}

/// Generic directory validator
fn ensure_directory&lt;M&gt;(path: &amp;VirtualPath&lt;M&gt;) -&gt; std::io::Result&lt;()&gt; {
    if !path.exists() {
        path.create_dir_all()?;
    } else if !path.is_dir() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::AlreadyExists,
            "Path exists but is not a directory"
        ));
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="passing-paths-through-call-chains"><a class="header" href="#passing-paths-through-call-chains">Passing Paths Through Call Chains</a></h2>
<h3 id="generic-chain"><a class="header" href="#generic-chain">Generic Chain</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generic all the way down
fn read_data&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    validate_file(path)?;           // Generic
    log_access(path, "read");        // Generic
    path.read()                      // Read the file
}
<span class="boring">}</span></code></pre></pre>
<h3 id="specific-chain"><a class="header" href="#specific-chain">Specific Chain</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TenantData;

// Specific markers maintained through chain
fn load_tenant_data(path: &amp;StrictPath&lt;TenantData&gt;) -&gt; Result&lt;Data, Error&gt; {
    validate_tenant_path(path)?;     // Takes StrictPath&lt;TenantData&gt;
    parse_tenant_data(path)?;        // Takes StrictPath&lt;TenantData&gt;
    decrypt_tenant_data(path)        // Takes StrictPath&lt;TenantData&gt;
}

// Each function in chain requires TenantData marker
fn validate_tenant_path(path: &amp;StrictPath&lt;TenantData&gt;) -&gt; Result&lt;(), Error&gt; { ... }
fn parse_tenant_data(path: &amp;StrictPath&lt;TenantData&gt;) -&gt; Result&lt;(), Error&gt; { ... }
fn decrypt_tenant_data(path: &amp;StrictPath&lt;TenantData&gt;) -&gt; Result&lt;Data, Error&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<h2 id="returning-generic-paths"><a class="header" href="#returning-generic-paths">Returning Generic Paths</a></h2>
<p>You can return paths with preserved markers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

/// Find config file in directory
fn find_config&lt;M&gt;(dir: &amp;PathBoundary&lt;M&gt;) -&gt; Option&lt;StrictPath&lt;M&gt;&gt; {
    for entry in dir.read_dir().ok()? {
        let entry = entry.ok()?;
        let name = entry.file_name();
        
        if name.to_string_lossy().ends_with(".conf") {
            return dir.strict_join(&amp;name).ok();
        }
    }
    None
}

// Marker type flows through
let config_dir: PathBoundary&lt;ConfigDir&gt; = ...;
let found: Option&lt;StrictPath&lt;ConfigDir&gt;&gt; = find_config(&amp;config_dir);
<span class="boring">}</span></code></pre></pre>
<h2 id="generic-with-constraints"><a class="header" href="#generic-with-constraints">Generic with Constraints</a></h2>
<p>You can constrain markers with trait bounds:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Marker must implement Send + Sync
fn parallel_process&lt;M: Send + Sync&gt;(
    paths: Vec&lt;StrictPath&lt;M&gt;&gt;
) -&gt; Vec&lt;std::io::Result&lt;String&gt;&gt; {
    use rayon::prelude::*;
    
    paths.par_iter()
        .map(|p| p.read_to_string())
        .collect()
}

/// Marker must implement custom trait
trait Auditable {
    fn audit_log_name() -&gt; &amp;'static str;
}

fn audit_access&lt;M: Auditable&gt;(path: &amp;StrictPath&lt;M&gt;) {
    println!("Accessing {} path: {}", 
        M::audit_log_name(), 
        path.strictpath_display()
    );
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-mistakes"><a class="header" href="#common-mistakes">Common Mistakes</a></h2>
<h3 id="-unnecessary-generic-constraint"><a class="header" href="#-unnecessary-generic-constraint">❌ Unnecessary Generic Constraint</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: overly restrictive
fn read_size&lt;M: Sized&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; std::io::Result&lt;u64&gt; {
    Ok(path.metadata()?.len())
}

// Good: no constraint needed
fn read_size&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; std::io::Result&lt;u64&gt; {
    Ok(path.metadata()?.len())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-mixing-markers-unsafely"><a class="header" href="#-mixing-markers-unsafely">❌ Mixing Markers Unsafely</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: forces marker type conversion
fn bad_mix&lt;M1, M2&gt;(src: &amp;StrictPath&lt;M1&gt;, dst: &amp;StrictPath&lt;M2&gt;) {
    // Won't compile: can't copy between different marker types
    src.strict_copy(dst); // ERROR: marker type mismatch
}

// Good: require same marker
fn good_copy&lt;M&gt;(src: &amp;StrictPath&lt;M&gt;, dst: &amp;StrictPath&lt;M&gt;) {
    src.strict_copy(dst); // ✅ OK: both have marker M
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-losing-marker-type"><a class="header" href="#-losing-marker-type">❌ Losing Marker Type</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: loses type information
fn process(path: &amp;StrictPath&lt;()&gt;) { ... }

// Good: preserve marker
fn process&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) { ... }
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="-start-generic-add-constraints-as-needed"><a class="header" href="#-start-generic-add-constraints-as-needed">✅ Start Generic, Add Constraints as Needed</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Start here
fn process&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) { ... }

// Add trait bounds only if needed
fn process&lt;M: Send + Sync&gt;(path: &amp;StrictPath&lt;M&gt;) { ... }

// Use specific markers only when required for business logic
fn process_user(path: &amp;StrictPath&lt;UserData&gt;) { ... }
<span class="boring">}</span></code></pre></pre>
<h3 id="-document-marker-expectations"><a class="header" href="#-document-marker-expectations">✅ Document Marker Expectations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Process any file in any boundary.
///
/// Generic over marker type `M` because the operation
/// doesn't depend on specific authorization or context.
fn process_file&lt;M&gt;(file: &amp;StrictPath&lt;M&gt;) -&gt; std::io::Result&lt;()&gt; {
    // ...
}

/// Load user-specific configuration.
///
/// Requires `UserData` marker to enforce that only
/// user-scoped paths can be processed here.
fn load_user_config(file: &amp;StrictPath&lt;UserData&gt;) -&gt; Result&lt;Config&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-use-generic-for-utilities-specific-for-domain-logic"><a class="header" href="#-use-generic-for-utilities-specific-for-domain-logic">✅ Use Generic for Utilities, Specific for Domain Logic</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Generic utility
fn file_size&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; std::io::Result&lt;u64&gt; { ... }

// ✅ Specific domain logic
fn charge_storage_fees(path: &amp;StrictPath&lt;BillingData&gt;) -&gt; Result&lt;Amount&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<ul>
<li><strong><code>&lt;M&gt;</code> means "works with any marker"</strong></li>
<li><strong>Use generics for reusable utilities</strong></li>
<li><strong>Use specific markers for domain-specific logic</strong></li>
<li><strong>The compiler prevents marker type mismatches</strong></li>
<li><strong>Marker types flow through call chains automatically</strong></li>
<li><strong>Add trait bounds only when needed</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="daily-usage-patterns"><a class="header" href="#daily-usage-patterns">Daily Usage Patterns</a></h1>
<p>Common workflows and patterns for everyday <code>strict-path</code> usage.</p>
<h2 id="pattern-1-validate-user-input"><a class="header" href="#pattern-1-validate-user-input">Pattern 1: Validate User Input</a></h2>
<p><strong>Problem</strong>: User provides a filename, you need to ensure it stays in your directory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn handle_user_request(user_filename: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    let uploads = PathBoundary::try_new("/var/uploads")?;
    
    // Validate the user input
    let safe_path = uploads.strict_join(user_filename)?;
    
    // Now safe to use
    let contents = safe_path.read_to_string()?;
    Ok(contents)
}

// ✅ Safe: "../etc/passwd" gets rejected
// ✅ Safe: "documents/report.pdf" gets validated
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-2-configuration-loading"><a class="header" href="#pattern-2-configuration-loading">Pattern 2: Configuration Loading</a></h2>
<p><strong>Problem</strong>: Load config files from multiple standard locations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;
use std::path::PathBuf;

fn find_config() -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    let config_locations = vec![
        PathBuf::from("/etc/myapp/config.toml"),
        PathBuf::from("/usr/local/etc/myapp/config.toml"),
        dirs::config_dir().unwrap().join("myapp/config.toml"),
    ];
    
    for location in config_locations {
        if let Some(parent) = location.parent() {
            if let Ok(boundary) = PathBoundary::try_new(parent) {
                if let Some(filename) = location.file_name() {
                    if let Ok(config_path) = boundary.strict_join(filename) {
                        if config_path.exists() {
                            return config_path.read_to_string();
                        }
                    }
                }
            }
        }
    }
    
    Err("No config file found".into())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-3-per-user-virtual-filesystem"><a class="header" href="#pattern-3-per-user-virtual-filesystem">Pattern 3: Per-User Virtual Filesystem</a></h2>
<p><strong>Problem</strong>: Multiple users, each needs their own isolated filesystem view.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::VirtualRoot;

struct UserSession {
    user_id: String,
    root: VirtualRoot&lt;UserSpace&gt;,
}

struct UserSpace;

impl UserSession {
    fn new(user_id: String) -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {
        let base_dir = format!("/var/lib/app/users/{}", user_id);
        let root = VirtualRoot::try_new_create(&amp;base_dir)?;
        Ok(Self { user_id, root })
    }
    
    fn read_file(&amp;self, virtual_path: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let file = self.root.virtual_join(virtual_path)?;
        Ok(file.read_to_string()?)
    }
    
    fn write_file(&amp;self, virtual_path: &amp;str, contents: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        let file = self.root.virtual_join(virtual_path)?;
        file.create_parent_dir_all()?;
        file.write(contents)?;
        Ok(())
    }
    
    fn list_files(&amp;self, virtual_dir: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        let dir = self.root.virtual_join(virtual_dir)?;
        let mut files = Vec::new();
        
        for entry in dir.as_unvirtual().read_dir()? {
            let entry = entry?;
            // Re-validate discovered names
            let validated = self.root.virtual_join(format!("{}/{}", virtual_dir, entry.file_name().to_string_lossy()))?;
            files.push(validated.virtualpath_display().to_string());
        }
        
        Ok(files)
    }
}

// Usage
let alice = UserSession::new("alice".to_string())?;
alice.write_file("documents/report.txt", "Quarterly report")?;
let report = alice.read_file("documents/report.txt")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-4-safe-archive-extraction"><a class="header" href="#pattern-4-safe-archive-extraction">Pattern 4: Safe Archive Extraction</a></h2>
<p><strong>Problem</strong>: Extract ZIP/TAR without directory traversal attacks.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;
use zip::ZipArchive;
use std::fs::File;

fn safe_extract_zip(
    zip_path: &amp;std::path::Path,
    extract_to: &amp;str
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let extract_dir = PathBoundary::try_new_create(extract_to)?;
    let mut archive = ZipArchive::new(File::open(zip_path)?)?;
    
    for i in 0..archive.len() {
        let mut file = archive.by_index(i)?;
        let filename = file.name();
        
        // Validate each file path before extraction
        let safe_path = match extract_dir.strict_join(filename) {
            Ok(p) =&gt; p,
            Err(_) =&gt; {
                eprintln!("Skipping malicious path: {}", filename);
                continue; // Skip paths that escape
            }
        };
        
        // Create parent directories
        safe_path.create_parent_dir_all()?;
        
        // Extract to validated path
        let mut outfile = safe_path.create_file()?;
        std::io::copy(&amp;mut file, &amp;mut outfile)?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-5-temporary-file-processing"><a class="header" href="#pattern-5-temporary-file-processing">Pattern 5: Temporary File Processing</a></h2>
<p><strong>Problem</strong>: Create temp directory for processing, auto-cleanup.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn process_upload(
    data: &amp;[u8]
) -&gt; Result&lt;ProcessedData, Box&lt;dyn std::error::Error&gt;&gt; {
    // Create temp directory with RAII cleanup
    let temp_dir = PathBoundary::&lt;()&gt;::try_new_temp()?;
    
    // Write input
    let input_file = temp_dir.strict_join("input.dat")?;
    input_file.write_bytes(data)?;
    
    // Process
    let output_file = temp_dir.strict_join("output.dat")?;
    process_data(&amp;input_file, &amp;output_file)?;
    
    // Read result
    let result = output_file.read()?;
    
    // temp_dir dropped here, automatically cleaned up
    Ok(ProcessedData::from_bytes(&amp;result))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-6-chaining-operations"><a class="header" href="#pattern-6-chaining-operations">Pattern 6: Chaining Operations</a></h2>
<p><strong>Problem</strong>: Multiple sequential operations on paths.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::PathBoundary;

fn backup_and_update_config(
    new_config: &amp;str
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let config_dir = PathBoundary::try_new("/etc/myapp")?;
    
    let config = config_dir.strict_join("config.toml")?;
    let backup = config_dir.strict_join("config.toml.backup")?;
    
    // Chain operations
    config.strict_copy(&amp;backup)?;           // Backup current
    config.write(new_config)?;               // Write new
    
    // Verify
    if config.read_to_string()? == new_config {
        println!("Config updated successfully");
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-7-authorization-with-markers"><a class="header" href="#pattern-7-authorization-with-markers">Pattern 7: Authorization with Markers</a></h2>
<p><strong>Problem</strong>: Different users need different access levels.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

struct ReadOnly;
struct ReadWrite;

fn authenticate_user(
    username: &amp;str,
    password: &amp;str
) -&gt; Result&lt;PathBoundary&lt;ReadWrite&gt;, AuthError&gt; {
    // Check credentials
    if verify_credentials(username, password) {
        let user_dir = format!("/var/data/users/{}", username);
        let boundary: PathBoundary&lt;ReadOnly&gt; = PathBoundary::try_new(&amp;user_dir)
            .map_err(|_| AuthError::NoAccess)?;
        
        // Escalate to write access after auth check
        Ok(boundary.change_marker())
    } else {
        Err(AuthError::InvalidCredentials)
    }
}

fn write_user_data(
    boundary: &amp;PathBoundary&lt;ReadWrite&gt;, // Requires write marker
    filename: &amp;str,
    data: &amp;str
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let file = boundary.strict_join(filename)?;
    file.write(data)?;
    Ok(())
}

// ✅ Can only call write_user_data with ReadWrite marker
let rw_boundary = authenticate_user("alice", "secret123")?;
write_user_data(&amp;rw_boundary, "notes.txt", "My notes")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-8-error-handling"><a class="header" href="#pattern-8-error-handling">Pattern 8: Error Handling</a></h2>
<p><strong>Problem</strong>: Gracefully handle path validation failures.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPathError};

fn safe_file_access(
    base: &amp;str,
    user_path: &amp;str
) -&gt; Result&lt;String, AppError&gt; {
    let boundary = PathBoundary::try_new(base)
        .map_err(|e| AppError::InvalidBase(e))?;
    
    let file = boundary.strict_join(user_path)
        .map_err(|e| match e {
            StrictPathError::PathEscapesBoundary { attempted, boundary } =&gt; {
                AppError::PathEscape { 
                    path: attempted.display().to_string(),
                    reason: "Attempted directory traversal"
                }
            }
            _ =&gt; AppError::ValidationFailed(e)
        })?;
    
    file.read_to_string()
        .map_err(|e| AppError::IoError(e))
}

#[derive(Debug)]
enum AppError {
    InvalidBase(StrictPathError),
    PathEscape { path: String, reason: &amp;'static str },
    InvalidPath { reason: String },
    ValidationFailed(StrictPathError),
    IoError(std::io::Error),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-9-database-path-storage"><a class="header" href="#pattern-9-database-path-storage">Pattern 9: Database Path Storage</a></h2>
<p><strong>Problem</strong>: Store and retrieve validated paths from database.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct FileRecord {
    id: u64,
    // Store as string in DB
    relative_path: String,
}

struct FileService {
    boundary: PathBoundary&lt;DataDir&gt;,
}

struct DataDir;

impl FileService {
    fn save_file(&amp;self, name: &amp;str, data: &amp;[u8]) -&gt; Result&lt;FileRecord, Box&lt;dyn std::error::Error&gt;&gt; {
        // Validate before using
        let file = self.boundary.strict_join(name)?;
        file.write_bytes(data)?;
        
        // Store relative path in DB
        Ok(FileRecord {
            id: generate_id(),
            relative_path: name.to_string(),
        })
    }
    
    fn load_file(&amp;self, record: &amp;FileRecord) -&gt; Result&lt;Vec&lt;u8&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
        // Re-validate on load
        let file = self.boundary.strict_join(&amp;record.relative_path)?;
        Ok(file.read()?)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pattern-10-logging-and-auditing"><a class="header" href="#pattern-10-logging-and-auditing">Pattern 10: Logging and Auditing</a></h2>
<p><strong>Problem</strong>: Log file access for compliance.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;
use tracing::{info, warn};

fn audit_read&lt;M&gt;(
    path: &amp;StrictPath&lt;M&gt;,
    user: &amp;str
) -&gt; std::io::Result&lt;String&gt; {
    info!(
        user = user,
        path = %path.strictpath_display(),
        action = "read",
        "File access"
    );
    
    match path.read_to_string() {
        Ok(contents) =&gt; {
            info!(
                user = user,
                path = %path.strictpath_display(),
                size = contents.len(),
                "Read successful"
            );
            Ok(contents)
        }
        Err(e) =&gt; {
            warn!(
                user = user,
                path = %path.strictpath_display(),
                error = %e,
                "Read failed"
            );
            Err(e)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<h3 id="reuse-boundaries"><a class="header" href="#reuse-boundaries">Reuse Boundaries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Good: create boundary once
let boundary = PathBoundary::try_new("/var/data")?;

for filename in filenames {
    let file = boundary.strict_join(filename)?;
    process(file)?;
}

// ❌ Bad: recreating boundary every iteration
for filename in filenames {
    let boundary = PathBoundary::try_new("/var/data")?; // Wasteful!
    let file = boundary.strict_join(filename)?;
    process(file)?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-validation"><a class="header" href="#batch-validation">Batch Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Validate all paths upfront
let files: Result&lt;Vec&lt;_&gt;, _&gt; = filenames
    .iter()
    .map(|name| boundary.strict_join(name))
    .collect();

let files = files?; // Single error handling point

// Then process
for file in files {
    process(&amp;file)?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="avoid-redundant-checks"><a class="header" href="#avoid-redundant-checks">Avoid Redundant Checks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Bad: checking twice
if file.exists() {
    file.read_to_string()?;
}

// ✅ Good: let I/O operation handle it
match file.read_to_string() {
    Ok(contents) =&gt; { /* use contents */ }
    Err(e) if e.kind() == std::io::ErrorKind::NotFound =&gt; { /* handle missing */ }
    Err(e) =&gt; return Err(e.into()),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<ul>
<li><strong>Always validate user input through <code>strict_join</code>/<code>virtual_join</code></strong></li>
<li><strong>Create boundaries once, reuse for multiple paths</strong></li>
<li><strong>Use markers to encode authorization at type level</strong></li>
<li><strong>Handle errors gracefully with specific error types</strong></li>
<li><strong>Re-validate paths loaded from databases</strong></li>
<li><strong>Log file operations for audit trails</strong></li>
<li><strong>Prefer builtin I/O methods over <code>.interop_path()</code></strong></li>
<li><strong>Use temporary directories with RAII cleanup</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interop-vs-display"><a class="header" href="#interop-vs-display">Interop vs Display</a></h1>
<ul>
<li>Interop (AsRef<Path>): use <code>interop_path()</code> on <code>StrictPath</code>, <code>VirtualPath</code>, <code>PathBoundary</code>, and <code>VirtualRoot</code>. It borrows the underlying OS path without allocations.</li>
<li>Display to users:
<ul>
<li>System paths: use <code>strictpath_display()</code> (on <code>StrictPath</code>/<code>PathBoundary</code>).</li>
<li>Virtual UI paths: use <code>virtualpath_display()</code> (on <code>VirtualPath</code>).</li>
</ul>
</li>
<li>Never use <code>interop_path().to_string_lossy()</code> for display—mixes concerns and may leak internals.</li>
<li>Do not wrap secure types with <code>Path::new</code> or <code>PathBuf::from</code>.</li>
<li>Directory discovery vs validation:
<ul>
<li>Discover children via <code>read_dir(root.interop_path())</code> or root helpers.</li>
<li>Re-validate names with <code>strict_join()</code>/<code>virtual_join()</code> before any I/O.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-signatures"><a class="header" href="#function-signatures">Function Signatures</a></h1>
<p>Encode guarantees so misuse is hard:</p>
<ul>
<li>Accept validated paths directly when the caller did validation:
<ul>
<li><code>fn process(file: &amp;StrictPath&lt;MyMarker&gt;) -&gt; io::Result&lt;()&gt; { ... }</code></li>
<li><code>fn read(user_file: &amp;VirtualPath&lt;MyMarker&gt;) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; { ... }</code></li>
</ul>
</li>
<li>Validate inside helpers by accepting policy + untrusted segment:
<ul>
<li><code>fn write(cfg: &amp;PathBoundary&lt;MyMarker&gt;, name: &amp;str) -&gt; io::Result&lt;()&gt; { ... }</code></li>
<li><code>fn upload(vroot: &amp;VirtualRoot&lt;MyMarker&gt;, filename: &amp;str) -&gt; io::Result&lt;()&gt; { ... }</code></li>
</ul>
</li>
<li>Don’t construct boundaries/roots inside helpers—policy lives at the call site.</li>
<li>Prefer domain names over type names: <code>uploads_root</code>, <code>config_dir</code>, <code>user_project_root</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escape-hatches"><a class="header" href="#escape-hatches">Escape Hatches</a></h1>
<p>Use escape hatches sparingly and deliberately.</p>
<ul>
<li>Borrow strict view from virtual: <code>vpath.as_unvirtual()</code> (preferred for shared helpers).</li>
<li>Ownership conversions:
<ul>
<li><code>StrictPath::virtualize()</code> → <code>VirtualPath</code></li>
<li><code>VirtualPath::unvirtual()</code> → <code>StrictPath</code></li>
<li><code>StrictPath::unstrict()</code> → <code>PathBuf</code> (avoid unless you truly need an owned <code>PathBuf</code>)</li>
</ul>
</li>
<li>Avoid chaining escape hatches in application code. If you must own a <code>PathBuf</code>, isolate it in a clearly-marked narrow scope.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality--ordering"><a class="header" href="#equality--ordering">Equality &amp; Ordering</a></h1>
<ul>
<li><code>StrictPath</code> and <code>VirtualPath</code> equality/ordering are based on their underlying system paths (within the same restriction).</li>
<li>Do not compare display strings. Use the types’ built-in Eq/Ord/Hash.</li>
<li>When you need system-path equality in virtual flows, compare via <code>as_unvirtual()</code>.</li>
<li>Avoid lossy or normalization-prone string conversions for comparisons.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="naming"><a class="header" href="#naming">Naming</a></h1>
<p>Prefer domain-based names; avoid type-based names.</p>
<ul>
<li>Good: <code>config_dir</code>, <code>uploads_root</code>, <code>archive_src</code>, <code>user_vroot</code>, <code>system_root</code>.</li>
<li>Avoid: <code>boundary</code>, <code>jail</code>, <code>source_</code> prefixes, or one-letter variables.</li>
<li>Keep names consistent with the directory they represent and convey intent in code review.</li>
</ul>
<h3 id="marker-types"><a class="header" href="#marker-types">Marker Types</a></h3>
<ul>
<li>Name markers after the storage domain (<code>struct PublicAssets;</code>, <code>struct BrandEditorWorkspace;</code>). Reviewers should understand the filesystem contents from the type alone.</li>
<li>Skip suffixes like <code>Marker</code>, <code>Type</code>, or <code>Root</code>; they repeat what Rust already communicates. <code>struct MediaLibrary;</code> is clearer than <code>struct MediaLibraryMarker;</code>.</li>
<li>Tuples that pair storage with authorization should keep the resource first and the capability second: <code>StrictPath&lt;(BrandDirectorArchive, FullControlCapability)&gt;</code>.</li>
<li>Focus on what's stored, not who uses it. A marker like <code>BrandAssets</code> tells you the directory contains brand materials, while <code>EditorFiles</code> only tells you someone called "Editor" uses it. The marker describes the filesystem contents and access policy, not the caller's identity.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choosing-canonicalized-vs-lexical-solution"><a class="header" href="#choosing-canonicalized-vs-lexical-solution">Choosing Canonicalized vs Lexical Solution</a></h1>
<p>Scope: strict-path always uses canonicalized path security. There is no “lexical mode” in this crate. When we say “lexical,” we mean using a different crate that only does string/segment checks. This page helps you decide when to use strict-path (canonicalized) versus when a lexical-only crate might be acceptable.</p>
<p>New here? This page helps you pick the right approach without security footguns.</p>
<p>In one sentence: Prefer the “canonicalized” approach unless you 100% control the environment and have tests proving your assumptions. Lexical (in other crates) is for rare, performance‑critical hot paths with strong guarantees.</p>
<h2 id="first-what-do-these-words-mean"><a class="header" href="#first-what-do-these-words-mean">First: What do these words mean?</a></h2>
<ul>
<li>Canonicalized (what strict-path does): We ask the OS to resolve the real, absolute path before deciding if it’s safe. This resolves symlinks/junctions and normalizes platform‑specific quirks (like Windows 8.3 short names, UNC, ADS). That way, sneaky inputs can’t trick simple string checks.</li>
<li>Lexical (other crates): We treat the path like plain text and only do string/segment checks (no OS resolution). It can be fast, but it doesn’t see what’s really on disk.</li>
</ul>
<h2 id="why-you-probably-want-canonicalized-ie-strict-path"><a class="header" href="#why-you-probably-want-canonicalized-ie-strict-path">Why you probably want canonicalized (i.e., strict-path)</a></h2>
<ul>
<li>Defends against real‑world attacks: directory traversal (../../../), symlink swaps, aliasing (8.3 short names like <code>PROGRA~1</code>), UNC/verbatim forms, ADS, Unicode normalization tricks.</li>
<li>Works across platforms the same way.</li>
<li>Matches “zero‑trust” handling for inputs from HTTP, config files, databases, archives, and LLMs.</li>
</ul>
<p>Trade‑off: a bit more I/O work to ask the filesystem what’s actually there.</p>
<h2 id="when-lexical-other-crates-can-be-ok"><a class="header" href="#when-lexical-other-crates-can-be-ok">When lexical (other crates) can be OK</a></h2>
<p>Only consider lexical if ALL of these are true:</p>
<ul>
<li>No symlinks/junctions/mounts in the relevant tree</li>
<li>Inputs are already normalized (no weird separators or encodings)</li>
<li>You own the environment (e.g., an internal tool in a sealed container)</li>
<li>You have tests that enforce the above (so a future change doesn’t silently break safety)</li>
</ul>
<p>If you’re unsure, use strict-path (canonicalized).</p>
<h2 id="fast-decision-guide"><a class="header" href="#fast-decision-guide">Fast decision guide</a></h2>
<ul>
<li>Is the input from users, files, network, LLMs, or archives? → Use strict-path (canonicalized: <code>StrictPath</code>/<code>VirtualPath</code>).</li>
<li>Is this a perf‑critical inner loop on paths you generate yourself and you’ve proven there are no symlinks? → A lexical-only crate might be acceptable.</li>
<li>Mixed or uncertain? → Use strict-path (canonicalized).</li>
</ul>
<h2 id="concrete-examples"><a class="header" href="#concrete-examples">Concrete examples</a></h2>
<ul>
<li>
<p>“User uploads a file named <code>../../etc/passwd</code>”</p>
<ul>
<li>strict-path (canonicalized): Rejected or clamped safely; cannot escape the root.</li>
<li>lexical-only crate: Traversal may be blocked, but symlinks or platform quirks can still break containment.</li>
</ul>
</li>
<li>
<p>“Windows machine with <code>C:\Program Files</code> also visible as <code>C:\PROGRA~1</code>”</p>
<ul>
<li>strict-path (canonicalized): Treats both as the same real place; escape attempts fail.</li>
<li>lexical-only crate: A clever alias or hidden symlink may trick a simple prefix check—even if traversal is blocked.</li>
</ul>
</li>
</ul>
<h2 id="short-recipes"><a class="header" href="#short-recipes">Short recipes</a></h2>
<ul>
<li>
<p>strict-path (canonicalized, default):</p>
<ul>
<li>Validate via a boundary/root, then operate through <code>StrictPath</code>/<code>VirtualPath</code> methods.</li>
<li>Accept <code>&amp;StrictPath&lt;_&gt;</code>/<code>&amp;VirtualPath&lt;_&gt;</code> in helpers, or accept a <code>&amp;PathBoundary/_VirtualRoot</code> plus the untrusted segment.</li>
</ul>
</li>
<li>
<p>If you intentionally use a lexical-only crate (advanced):</p>
<ul>
<li>Keep lexical checks isolated and documented; add tests that assert “no symlinks / normalized inputs”.</li>
<li>If the situation changes later, migrate back to strict-path with minimal refactors because your signatures stayed explicit.</li>
</ul>
</li>
</ul>
<p>See also:</p>
<ul>
<li>Ergonomics → Interop vs Display</li>
<li>README → “Where This Makes Sense”</li>
</ul>
<blockquote>
<p>"Lexical checks aren't just about traversal—symlinks and platform quirks are the real troublemakers."</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-decisions---guide-for-the-frustrated-rustacean"><a class="header" href="#design-decisions---guide-for-the-frustrated-rustacean">Design Decisions - Guide for the Frustrated Rustacean</a></h1>
<p>Since this is a security crate, I took on myself more design decision liberties towards increased security, correctness and avoidance of misuse.</p>
<h2 id="the-journey-from-ergonomic-to-secure"><a class="header" href="#the-journey-from-ergonomic-to-secure">The Journey: From Ergonomic to Secure</a></h2>
<p>The initial prototype had straightforward ergonomics, with non-original, boring API. Which is normally good and required design. Easy transitions between types and common method names.</p>
<p>As I was generating code using different LLMs, a disaster unfolded. <strong>The LLM did not use the API correctly at all!</strong> It constantly worked its way around safety features and since it was generating a lot of code, it became harder to have code review and easy to miss an introduced vulnerability by the LLM.</p>
<p>That had me realize that since LLM Agents is all that is happening nowadays, I had to think carefully about how to guide it towards correct usage of my API in a way that a human will also benefit from.</p>
<h2 id="security-measures-taken"><a class="header" href="#security-measures-taken">Security Measures Taken</a></h2>
<h3 id="llm-aware-documentation"><a class="header" href="#llm-aware-documentation">LLM-Aware Documentation</a></h3>
<ul>
<li><strong>Complete API summary file dedicated to an LLM</strong> - <a href="https://github.com/DK26/strict-path-rs/blob/main/LLM_API_REFERENCE.md"><code>LLM_API_REFERENCE.md</code></a> provides usage-first guidance</li>
<li><strong>Code comments in a style that tooling agents can reason with</strong> - Explicit function documentation with SUMMARY/PARAMETERS/RETURNS/ERRORS/EXAMPLE sections</li>
</ul>
<h3 id="api-design-philosophy"><a class="header" href="#api-design-philosophy">API Design Philosophy</a></h3>
<ul>
<li><strong>Highly explicit API</strong> - Easy to review and detect errors by method names
<ul>
<li><code>strictpath_display()</code> vs <code>virtualpath_display()</code> instead of generic <code>display()</code></li>
<li><code>strict_join()</code> vs <code>virtual_join()</code> instead of generic <code>join()</code></li>
<li><code>interop_path()</code> for third-party integration instead of hidden <code>AsRef&lt;Path&gt;</code> impls</li>
</ul>
</li>
<li><strong>Best practices vs anti-patterns in docs</strong> - Clear guidance on what to do and what to avoid</li>
<li><strong>Minimal API surface</strong> - Less ways to get it wrong</li>
<li><strong>Safe built-in I/O operations</strong> - <code>read_to_string()</code>, <code>write()</code>, <code>create_file()</code> on the secure types</li>
<li><strong>Type-based security</strong> - Markers enforce boundaries at compile time</li>
</ul>
<h2 id="the-path-extension-trait-decision"><a class="header" href="#the-path-extension-trait-decision">The Path Extension Trait Decision</a></h2>
<p>I was thinking about having an extension trait for <code>Path</code>/<code>PathBuf</code>, to introduce built-in I/O methods just like we have in our <code>StrictPath</code> and <code>VirtualPath</code>. The idea was to keep the code nice and consistent, since using <code>Path</code> and <code>PathBuf</code> are legit in some contexts.</p>
<p>However, I realized <strong>it is far quicker to notice we are using the wrong Path type</strong>. The moment we see old-style code for I/O, it helps ask questions like:</p>
<blockquote>
<p>"Why do we use regular Path here? Is this legit?"</p>
</blockquote>
<p>And that's awesome for code review and overall security! 🛡️</p>
<h2 id="why-this-matters-for-you"><a class="header" href="#why-this-matters-for-you">Why This Matters for You</a></h2>
<h3 id="human-benefits"><a class="header" href="#human-benefits">Human Benefits</a></h3>
<ul>
<li><strong>Code review clarity</strong> - Suspicious patterns are immediately visible</li>
<li><strong>Intention signaling</strong> - Method names communicate security guarantees</li>
<li><strong>Compile-time safety</strong> - Type system prevents mixing secure and insecure paths</li>
</ul>
<h3 id="llm-agent-benefits"><a class="header" href="#llm-agent-benefits">LLM Agent Benefits</a></h3>
<ul>
<li><strong>Explicit guidance</strong> - Clear documentation prevents misuse</li>
<li><strong>Fewer escape hatches</strong> - Limited ways to bypass security</li>
<li><strong>Pattern recognition</strong> - Consistent naming helps AI understand correct usage</li>
</ul>
<h2 id="examples-of-security-first-design"><a class="header" href="#examples-of-security-first-design">Examples of Security-First Design</a></h2>
<h3 id="-what-we-could-have-done-ergonomic-but-dangerous"><a class="header" href="#-what-we-could-have-done-ergonomic-but-dangerous">❌ What We Could Have Done (Ergonomic but Dangerous)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hypothetical "ergonomic" design - DON'T DO THIS
let path: StrictPath&lt;_&gt; = boundary.join(user_input)?;  // Generic method
let content = std::fs::read_to_string(path)?;          // Easy to bypass
<span class="boring">}</span></code></pre></pre>
<h3 id="-what-we-actually-do-explicit-and-secure"><a class="header" href="#-what-we-actually-do-explicit-and-secure">✅ What We Actually Do (Explicit and Secure)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Actual secure design - explicit and reviewable
let path: StrictPath&lt;_&gt; = boundary.strict_join(user_input)?;  // Clearly strict
let content = path.read_to_string()?;                        // Built-in secure I/O
<span class="boring">}</span></code></pre></pre>
<p>The second example makes it immediately clear:</p>
<ol>
<li>We're operating in strict mode (<code>strict_join</code>)</li>
<li>We're using built-in secure I/O (no raw <code>std::fs</code>)</li>
<li>The path type carries security guarantees</li>
</ol>
<h2 id="the-result"><a class="header" href="#the-result">The Result</a></h2>
<p>This design philosophy has proven effective in practice:</p>
<ul>
<li><strong>Reduced vulnerabilities</strong> - Harder to accidentally introduce path traversal</li>
<li><strong>Better code reviews</strong> - Security issues are immediately visible</li>
<li><strong>LLM-compatible</strong> - AI agents use the API correctly when following the documentation</li>
<li><strong>Human-friendly</strong> - Developers understand the security implications at a glance</li>
</ul>
<p>Remember: <strong>Security-critical crates should prioritize correctness over ergonomics</strong>. A slightly more verbose API that prevents vulnerabilities is infinitely better than an elegant API that's easy to misuse.</p>
<hr />
<h2 id="comparison-with-alternatives"><a class="header" href="#comparison-with-alternatives">Comparison with Alternatives</a></h2>
<p>Understanding how <code>strict-path</code> compares to other path-handling solutions helps you choose the right tool for your needs.</p>
<h3 id="strict-path-vs-soft-canonicalize"><a class="header" href="#strict-path-vs-soft-canonicalize">strict-path vs soft-canonicalize</a></h3>
<p><code>soft-canonicalize</code> is the foundation that <code>strict-path</code> builds upon. Think of it as the difference between a low-level graphics library and a game engine.</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th><code>strict-path</code></th><th><code>soft-canonicalize</code></th></tr></thead><tbody>
<tr><td><strong>Level</strong></td><td>High-level security API</td><td>Low-level path resolution</td></tr>
<tr><td><strong>Purpose</strong></td><td>Enforce boundaries + authorization</td><td>Normalize &amp; canonicalize paths</td></tr>
<tr><td><strong>Returns</strong></td><td><code>StrictPath&lt;Marker&gt;</code> / <code>VirtualPath&lt;Marker&gt;</code> with compile-time guarantees</td><td><code>PathBuf</code></td></tr>
<tr><td><strong>I/O operations</strong></td><td>Complete filesystem API (read, write, rename, copy, etc.)</td><td>Not included (just path resolution)</td></tr>
<tr><td><strong>Boundary enforcement</strong></td><td>Built-in: <code>strict_join()</code> / <code>virtual_join()</code> validate against boundaries</td><td>Manual: you implement checks yourself</td></tr>
<tr><td><strong>Authorization</strong></td><td>Compile-time marker proofs (type system verifies auth)</td><td>Not applicable</td></tr>
<tr><td><strong>Use case</strong></td><td>Application-level security (validate external paths, enforce policies)</td><td>Building custom path security logic</td></tr>
<tr><td><strong>Complexity</strong></td><td>High-level, opinionated (fewer decisions to make)</td><td>Low-level, flexible (more control, more responsibility)</td></tr>
</tbody></table>
</div>
<p><strong>When to use <code>strict-path</code>:</strong></p>
<ul>
<li>✅ You need comprehensive path security out of the box</li>
<li>✅ You want compile-time guarantees about path boundaries</li>
<li>✅ You're validating paths from external sources (HTTP, CLI, LLM, config)</li>
<li>✅ You want authorization encoded in types</li>
<li>✅ You prefer opinionated security over custom logic</li>
</ul>
<p><strong>When to use <code>soft-canonicalize</code>:</strong></p>
<ul>
<li>✅ You're building custom path security abstractions</li>
<li>✅ You need just canonicalization without boundary enforcement</li>
<li>✅ You want maximum flexibility to design your own security model</li>
<li>✅ You're implementing path comparison/deduplication logic</li>
<li>✅ You need canonicalization for non-existing paths</li>
</ul>
<p><strong>Example: The Relationship</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// soft-canonicalize: low-level resolution
use soft_canonicalize::soft_canonicalize;
let resolved = soft_canonicalize("config/../data/file.txt")?;
// You get: PathBuf - now manually check if it's within bounds

// strict-path: high-level security (uses soft-canonicalize internally)
use strict_path::StrictPath;
let safe_path = StrictPath::with_boundary("data")?
    .strict_join("../file.txt")?;  // Returns Err if outside "data"
safe_path.read_to_string()?;       // Built-in secure I/O
<span class="boring">}</span></code></pre></pre>
<hr />
<h3 id="strict-path-vs-path_absolutize"><a class="header" href="#strict-path-vs-path_absolutize">strict-path vs path_absolutize</a></h3>
<p><code>path_absolutize</code> offers different security philosophies. Understanding these differences is critical for choosing the right approach.</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th><code>strict-path</code></th><th><code>path_absolutize::absolutize_virtually</code></th></tr></thead><tbody>
<tr><td><strong>Escape handling</strong></td><td><strong>StrictPath:</strong> Returns <code>Err(PathEscapesBoundary)</code><br><strong>VirtualPath:</strong> Silently clamps to boundary</td><td>Returns <code>Err</code> on escape attempts (rejection model only)</td></tr>
<tr><td><strong>Symlink resolution</strong></td><td><strong>Full filesystem-based</strong> - Follows symlinks, resolves targets</td><td><strong>Lexical only</strong> - Does NOT follow symlinks (faster but less accurate)</td></tr>
<tr><td><strong>Security model</strong></td><td><strong>Two modes:</strong><br>1. Detect escapes (StrictPath)<br>2. Contain escapes (VirtualPath)</td><td><strong>One mode:</strong> Reject invalid paths</td></tr>
<tr><td><strong>Canonicalization</strong></td><td>Full canonicalization (resolves <code>.</code>, <code>..</code>, symlinks, Windows short names)</td><td>Lexical normalization (string manipulation, no filesystem I/O)</td></tr>
<tr><td><strong>Authorization</strong></td><td>Compile-time marker proofs</td><td>Not applicable</td></tr>
<tr><td><strong>I/O operations</strong></td><td>Complete built-in API</td><td>Not included</td></tr>
<tr><td><strong>Use when</strong></td><td>Security boundaries where symlinks exist or accuracy is critical</td><td>Performance-critical paths where symlinks are guaranteed not to exist</td></tr>
</tbody></table>
</div>
<p><strong>Critical Distinction: Symlink Behavior</strong></p>
<p>The symlink handling difference is <strong>security-critical</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Setup: Create symlink that escapes boundary
// /safe/link -&gt; /etc/passwd

// path_absolutize (lexical only - DANGEROUS if symlinks exist):
use path_absolutize::Absolutize;
let abs = Path::new("/safe/link").absolutize_virtually("/safe")?;
// Result: /safe/link (string looks safe, but symlink escapes!)
// Reading this symlink gives you /etc/passwd content!

// strict-path StrictPath (filesystem-based - SAFE):
use strict_path::PathBoundary;
let boundary = PathBoundary::try_new("/safe")?;
let validated = boundary.strict_join("link")?;  // Follows symlink, sees target is /etc/passwd
// Result: Err(PathEscapesBoundary) - attack detected!

// strict-path VirtualPath (filesystem-based with clamping):
use strict_path::VirtualRoot;
let vroot = VirtualRoot::try_new("/safe")?;
let contained = vroot.virtual_join("link")?;  // Follows symlink, clamps target to /safe/etc/passwd
// Result: Ok - target rewritten to stay within boundary, user sees "/etc/passwd" in virtual space
<span class="boring">}</span></code></pre></pre>
<p><strong>When lexical (path_absolutize) is safe:</strong></p>
<ul>
<li>✅ You can <strong>guarantee</strong> no symlinks exist in your paths</li>
<li>✅ Performance is critical and you've validated the environment</li>
<li>✅ You control all path creation (e.g., build artifacts, codegen)</li>
</ul>
<p><strong>When filesystem-based (strict-path) is required:</strong></p>
<ul>
<li>✅ Any possibility of symlinks existing</li>
<li>✅ Handling user-provided paths (HTTP, CLI, config, archives)</li>
<li>✅ Security is more important than performance</li>
<li>✅ You need to detect attacks (escapes are malicious)</li>
<li>✅ You need to contain escapes (multi-tenant isolation)</li>
</ul>
<p><strong>Performance vs Security Trade-off:</strong></p>
<ul>
<li><strong>Lexical resolution (path_absolutize):</strong> ~10-100x faster (no filesystem I/O), but vulnerable to symlink attacks</li>
<li><strong>Filesystem-based (strict-path):</strong> Slower (requires stat calls), but mathematically secure against symlink escapes</li>
</ul>
<p><strong>Which One Should You Use?</strong></p>
<p>Ask yourself: <strong>"Can I guarantee no symlinks will ever exist in these paths?"</strong></p>
<ul>
<li><strong>No / Not sure</strong> → Use <code>strict-path</code> (security over performance)</li>
<li><strong>Yes, absolutely certain</strong> → Consider <code>path_absolutize</code> (performance)</li>
<li><strong>Need to detect attacks</strong> → Use <code>strict-path</code> with <code>StrictPath</code></li>
<li><strong>Need to contain escapes</strong> → Use <code>strict-path</code> with <code>VirtualPath</code> (unique to this crate)</li>
</ul>
<hr />
<h3 id="decision-matrix-choosing-the-right-tool"><a class="header" href="#decision-matrix-choosing-the-right-tool">Decision Matrix: Choosing the Right Tool</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Choose</th><th>Rationale</th></tr></thead><tbody>
<tr><td>Web server serving user-requested files</td><td><code>strict-path</code> (StrictPath)</td><td>Symlinks may exist, escapes are attacks</td></tr>
<tr><td>LLM agent file operations</td><td><code>strict-path</code> (StrictPath)</td><td>AI-generated paths are untrusted, need boundary enforcement</td></tr>
<tr><td>Archive extraction (Zip, TAR)</td><td><code>strict-path</code> (StrictPath)</td><td>Archives may contain malicious symlinks (Zip Slip attacks)</td></tr>
<tr><td>Multi-tenant cloud storage</td><td><code>strict-path</code> (VirtualPath)</td><td>Each user needs isolated virtual filesystem</td></tr>
<tr><td>Build system artifacts</td><td><code>path_absolutize</code> OR <code>soft-canonicalize</code></td><td>You control creation, no symlinks, performance matters</td></tr>
<tr><td>Custom security abstractions</td><td><code>soft-canonicalize</code></td><td>Build your own policy on stable foundation</td></tr>
<tr><td>Path comparison/deduplication</td><td><code>soft-canonicalize</code></td><td>Just need canonicalization, no boundary enforcement</td></tr>
</tbody></table>
</div>
<p><strong>Bottom Line:</strong></p>
<ul>
<li><strong>Need high-level security?</strong> → <code>strict-path</code></li>
<li><strong>Need low-level building blocks?</strong> → <code>soft-canonicalize</code></li>
<li><strong>Need fast lexical paths in controlled environments?</strong> → <code>path_absolutize</code> (but be careful!)</li>
<li><strong>Not sure?</strong> → Start with <code>strict-path</code> and optimize later if needed</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design--internals"><a class="header" href="#design--internals">Design &amp; Internals</a></h1>
<blockquote>
<p><strong>⚠️ CONTRIBUTOR DOCUMENTATION</strong><br />
This section is for contributors, library developers, and curious developers who want to understand how strict-path works internally.</p>
</blockquote>
<p>If you're just using strict-path in your project, you probably want:</p>
<ul>
<li><a href="./chapter_1.html">Getting Started</a> - Learn the basic API</li>
<li><a href="./examples.html">Real-World Examples</a> - See practical usage patterns</li>
</ul>
<h2 id="whats-in-this-section"><a class="header" href="#whats-in-this-section">What's in This Section</a></h2>
<p>This section covers the internal design decisions and patterns that make strict-path secure and maintainable:</p>
<h3 id="type-history-design-pattern"><a class="header" href="#type-history-design-pattern">Type-History Design Pattern</a></h3>
<p>The core security mechanism that uses Rust's type system to enforce that paths go through required validation steps in the correct order. This prevents accidentally using unvalidated paths and makes security guarantees compile-time checked rather than runtime hopes.</p>
<p><a href="./type_history_design.html">Read about Type-History →</a></p>
<h2 id="for-contributors"><a class="header" href="#for-contributors">For Contributors</a></h2>
<p>If you're contributing to strict-path, understanding these internals will help you:</p>
<ul>
<li>Maintain the security guarantees</li>
<li>Add new features safely</li>
<li>Understand why certain design decisions were made</li>
<li>Write tests that verify the type-level constraints</li>
</ul>
<p>The design patterns used here can also be applied to other security-critical Rust libraries where you need compile-time guarantees about data processing pipelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-history-design-pattern-1"><a class="header" href="#type-history-design-pattern-1">Type-History Design Pattern</a></h1>
<h2 id="the-problem-were-solving"><a class="header" href="#the-problem-were-solving">The Problem We're Solving</a></h2>
<p>Imagine you're writing code that needs to safely process data through multiple steps. You need to:</p>
<ol>
<li>Take raw input from an untrusted source</li>
<li>Clean/sanitize it</li>
<li>Validate it meets requirements</li>
<li>Transform it to final form</li>
<li>Only then use it for critical operations</li>
</ol>
<p>The problem? It's really easy to forget a step, or do them in the wrong order. And if you mess up, you might have bugs, security vulnerabilities, or data corruption.</p>
<p><strong>What if the compiler could remember which steps you've completed and enforce the correct order?</strong></p>
<p>That's exactly what the Type-History pattern does.</p>
<h2 id="type-history-in-simple-terms"><a class="header" href="#type-history-in-simple-terms">Type-History in Simple Terms</a></h2>
<p>The Type-History pattern is like having a checklist that follows your data around. Each time you complete a step, you get a new "stamp" on your checklist. Functions can then require that certain stamps are present before they'll work with your data.</p>
<p>Here's a simple example with strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These are our "stamps"
struct Raw;          // Just created, no processing yet
struct Trimmed;      // Whitespace has been removed
struct Validated;    // Content has been checked

// This is our wrapper that carries both data and stamps
struct ProcessedString&lt;History&gt; {
    content: String,
    _stamps: std::marker::PhantomData&lt;History&gt;, // Invisible stamps
}

// Start with a raw string
impl ProcessedString&lt;Raw&gt; {
    fn new(s: String) -&gt; Self {
        ProcessedString { 
            content: s, 
            _stamps: std::marker::PhantomData 
        }
    }
}

// Any string can be trimmed, adding a "Trimmed" stamp
impl&lt;H&gt; ProcessedString&lt;H&gt; {
    fn trim(self) -&gt; ProcessedString&lt;(H, Trimmed)&gt; {
        ProcessedString {
            content: self.content.trim().to_string(),
            _stamps: std::marker::PhantomData,
        }
    }
}

// Only trimmed strings can be validated
impl&lt;H&gt; ProcessedString&lt;(H, Trimmed)&gt; {
    fn validate(self) -&gt; Result&lt;ProcessedString&lt;((H, Trimmed), Validated)&gt;, &amp;'static str&gt; {
        if self.content.is_empty() {
            Err("String cannot be empty")
        } else {
            Ok(ProcessedString {
                content: self.content,
                _stamps: std::marker::PhantomData,
            })
        }
    }
}

// This function only accepts fully processed strings
fn save_to_database(s: &amp;ProcessedString&lt;((Raw, Trimmed), Validated)&gt;) {
    // We know this string has been trimmed AND validated
    println!("Safely saving: {}", s.content);
}
<span class="boring">}</span></code></pre></pre>
<p>Now look what happens when you use it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This works - we follow the correct steps
let s = ProcessedString::new("  hello world  ".to_string())
    .trim()           // Now has (Raw, Trimmed) stamps
    .validate()?;     // Now has ((Raw, Trimmed), Validated) stamps

save_to_database(&amp;s); // ✅ Compiles fine

// This won't compile - we skipped trimming!
let bad = ProcessedString::new("hello".to_string())
    .validate()?;     // This line itself won't compile!

// This won't compile either - missing validation
let also_bad = ProcessedString::new("hello".to_string())
    .trim();
save_to_database(&amp;also_bad); // ❌ Compilation error
<span class="boring">}</span></code></pre></pre>
<h2 id="other-applications-of-type-history"><a class="header" href="#other-applications-of-type-history">Other Applications of Type-History</a></h2>
<p>The Type-History pattern is useful anywhere you have multi-step data processing that must be done correctly:</p>
<h3 id="network-request-processing"><a class="header" href="#network-request-processing">Network Request Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Raw;
struct Authenticated;
struct RateLimited;
struct Validated;

struct Request&lt;H&gt; {
    data: RequestData,
    _history: PhantomData&lt;H&gt;,
}

// Must authenticate, then rate-limit, then validate
fn handle_request(req: &amp;Request&lt;(((Raw, Authenticated), RateLimited), Validated)&gt;) {
    // We know this request is safe to process
}
<span class="boring">}</span></code></pre></pre>
<h3 id="financial-transaction-processing"><a class="header" href="#financial-transaction-processing">Financial Transaction Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Raw;
struct AmountValidated;
struct FundsChecked;
struct Authorized;

struct Transaction&lt;H&gt; {
    amount: Decimal,
    from: AccountId,
    to: AccountId,
    _history: PhantomData&lt;H&gt;,
}

// Critical: must validate amount, check funds, get authorization
fn execute_transfer(tx: &amp;Transaction&lt;(((Raw, AmountValidated), FundsChecked), Authorized)&gt;) {
    // Guaranteed to be safe for execution
}
<span class="boring">}</span></code></pre></pre>
<h3 id="database-query-building"><a class="header" href="#database-query-building">Database Query Building</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Raw;
struct Sanitized;
struct Parameterized;
struct Validated;

struct Query&lt;H&gt; {
    sql: String,
    params: Vec&lt;Value&gt;,
    _history: PhantomData&lt;H&gt;,
}

// Must sanitize inputs, parameterize query, validate syntax
fn execute_query(q: &amp;Query&lt;(((Raw, Sanitized), Parameterized), Validated)&gt;) {
    // Safe from SQL injection
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-this-applies-to-strict-path"><a class="header" href="#how-this-applies-to-strict-path">How This Applies to strict-path</a></h2>
<p>For file paths, security is critical. We need to ensure that every path goes through the right checks in the right order:</p>
<ol>
<li><strong>Canonicalize</strong>: Resolve <code>.</code>, <code>..</code>, symlinks, etc.</li>
<li><strong>Boundary Check</strong>: Make sure the path is within our jail</li>
<li><strong>Existence Check</strong>: Verify the path actually exists (if needed)</li>
</ol>
<p>Using Type-History, we can make it impossible to use a path that hasn't been properly validated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These are the stamps for paths
struct Raw;               // Fresh from user input
struct Canonicalized;     // Cleaned up and resolved
struct BoundaryChecked;   // Verified to be within jail bounds
struct Exists;           // Confirmed to exist on filesystem

// Our internal path wrapper (you rarely see this directly)
struct PathHistory&lt;History&gt; {
    path: PathBuf,
    _stamps: std::marker::PhantomData&lt;History&gt;,
}

// Only canonicalized AND boundary-checked paths can be used for I/O
fn safe_file_operation(path: &amp;PathHistory&lt;((Raw, Canonicalized), BoundaryChecked)&gt;) {
    // We KNOW this path is safe to use
    std::fs::read_to_string(&amp;path.path).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="reading-the-type-signatures"><a class="header" href="#reading-the-type-signatures">Reading the Type Signatures</a></h2>
<p>The stamp history is written as nested tuples. Read them left-to-right to see the sequence:</p>
<ul>
<li><code>PathHistory&lt;Raw&gt;</code> = Just created, no processing</li>
<li><code>PathHistory&lt;(Raw, Canonicalized)&gt;</code> = Created, then canonicalized</li>
<li><code>PathHistory&lt;((Raw, Canonicalized), BoundaryChecked)&gt;</code> = Created, then canonicalized, then boundary-checked</li>
</ul>
<p>It's like reading a receipt that shows every step that was completed.</p>
<h2 id="why-not-just-use-booleans"><a class="header" href="#why-not-just-use-booleans">Why Not Just Use Booleans?</a></h2>
<p>You might wonder: "Why not just have a struct with boolean fields like <code>is_canonicalized</code> and <code>is_boundary_checked</code>?"</p>
<p>The problem with booleans is that they can lie:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ With booleans, you can fake it
struct UnsafePath {
    path: PathBuf,
    is_canonicalized: bool,    // I can set this to `true`
    is_boundary_checked: bool, // even if I never actually did the checks!
}

let fake_safe = UnsafePath {
    path: PathBuf::from("../../../etc/passwd"),
    is_canonicalized: true,    // Lies!
    is_boundary_checked: true, // More lies!
};
<span class="boring">}</span></code></pre></pre>
<p>With Type-History, you literally cannot create a value with the wrong stamps unless you actually performed the operations. The type system enforces honesty.</p>
<h2 id="the-public-api-hides-the-complexity"><a class="header" href="#the-public-api-hides-the-complexity">The Public API Hides the Complexity</a></h2>
<p>Users of strict-path never see <code>PathHistory</code> directly. Instead, they work with simple types like <code>StrictPath</code> and <code>VirtualPath</code>. But internally, these types contain properly stamped paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// What users see
pub struct StrictPath&lt;Marker&gt; {
    // What's hidden inside: a path that's been through the full validation pipeline
    inner: PathHistory&lt;((Raw, Canonicalized), BoundaryChecked)&gt;,
    // ... other fields
}

// Users just call simple methods
let safe_dir = PathBoundary::try_new_create("safe_dir")?;
let safe_user_file = safe_dir.strict_join("user_file.txt")?; // Returns StrictPath

// But the type system guarantees this path is safe to use
<span class="boring">}</span></code></pre></pre>
<h2 id="benefits-of-this-approach"><a class="header" href="#benefits-of-this-approach">Benefits of This Approach</a></h2>
<ol>
<li><strong>Impossible to Forget Steps</strong>: The compiler prevents you from skipping required processing</li>
<li><strong>Self-Documenting Code</strong>: Function signatures clearly show what processing is required</li>
<li><strong>Refactor-Safe</strong>: If you change the processing pipeline, the compiler finds all places that need updates</li>
<li><strong>Zero Runtime Cost</strong>: All the type checking happens at compile time - no performance overhead</li>
<li><strong>Audit-Friendly</strong>: Security reviewers can see exactly what guarantees each function requires</li>
</ol>
<h2 id="when-to-use-type-history"><a class="header" href="#when-to-use-type-history">When to Use Type-History</a></h2>
<p>This pattern is overkill for simple cases, but it's valuable when:</p>
<ul>
<li>Security is critical (like file path validation)</li>
<li>You have a multi-step process that must be done in order</li>
<li>Skipping steps could cause bugs or vulnerabilities</li>
<li>You want to encode important guarantees in the type system</li>
<li>Multiple functions need different combinations of processing steps</li>
</ul>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping Up</a></h2>
<p>The Type-History pattern might seem complex at first, but it's really just a way to make the compiler remember what you've done and enforce what you need to do. It turns potential runtime errors into compile-time guarantees.</p>
<p>In strict-path, this means that once you have a <code>StrictPath</code> or <code>VirtualPath</code>, you can be 100% confident it's safe to use - the type system guarantees it went through all the necessary security checks.</p>
<p>For most users of strict-path, you don't need to understand these internals. Just know that the library uses advanced type system features to make it impossible to accidentally create security vulnerabilities. The compiler has your back!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-journey-to-strict-path"><a class="header" href="#the-journey-to-strict-path">The Journey to strict-path</a></h1>
<h2 id="why-do-i-need-this-library"><a class="header" href="#why-do-i-need-this-library">Why Do I Need This Library?</a></h2>
<p>The development of <code>strict-path</code> is a story of discovering security gaps in path handling and iteratively building a comprehensive solution. Here's the complete development journey that led to the creation of this crate.</p>
<h3 id="why-use-this-crate-tldr"><a class="header" href="#why-use-this-crate-tldr">Why Use This Crate (TL;DR)</a></h3>
<p>Path security is not about comparing strings. It requires:</p>
<ul>
<li>Full normalization/canonicalization that works even when targets don’t exist</li>
<li>Safe symlink/junction handling (with cycle detection and boundary enforcement)</li>
<li>Windows-specific defenses (8.3 short names, UNC/verbatim prefixes, ADS)</li>
<li>Unicode/encoding awareness (mixed separators, normalization differences)</li>
</ul>
<p><code>strict-path</code> solves this class of problems comprehensively, then encodes the guarantees in the type system. If a <code>StrictPath&lt;Marker&gt;</code> exists, it’s proven to be inside its boundary by construction.</p>
<h2 id="the-development-process-story"><a class="header" href="#the-development-process-story">The Development Process Story</a></h2>
<h3 id="the-simple-beginning"><a class="header" href="#the-simple-beginning">The Simple Beginning</a></h3>
<p>It started as an apparently simple idea for a crate that validates paths by making sure they are within an expected boundary, using canonicalization. The concept was straightforward: create a type that validates the correct path (<code>PathValidator</code>) and a generated byproduct that serves as proof of validation (<code>JailedPath</code>).</p>
<p>That wasn't too hard to do... except...</p>
<h3 id="the-first-major-obstacle"><a class="header" href="#the-first-major-obstacle">The First Major Obstacle</a></h3>
<p><strong>The std::canonicalize Problem</strong>: Rust's standard library <code>canonicalize()</code> could only accept and work with paths that already exist. This was a fundamental limitation that broke the entire concept.</p>
<p><strong>Existing Crates Were Insufficient</strong>: Other Rust crates were only offering lexical path resolution, ignoring symlinks and unable to deliver the promise of canonicalized/realpath values without demanding that the target path must exist.</p>
<p>This was a big problem! How could I validate that a location for a future file is within a legal boundary if the file doesn't exist yet?</p>
<h3 id="the-python-inspiration"><a class="header" href="#the-python-inspiration">The Python Inspiration</a></h3>
<p>A quick search revealed that Python had already faced this exact problem and solved it in Python 3.6 by adding the following feature: <code>pathlib.Path.resolve(strict=False)</code>.</p>
<p>That's when I realized I'd need to create another crate! One that mimics that same logic—both to solve my problem and as an opportunity to give back to the Rust community.</p>
<p><strong>Enter soft-canonicalize</strong>: This became the foundation crate that would enable proper path validation without requiring file existence.</p>
<h3 id="building-soft-canonicalize"><a class="header" href="#building-soft-canonicalize">Building soft-canonicalize</a></h3>
<p>I asked an LLM agent to fetch Python's implementation unit tests, translate them to Rust, and run them over our <code>soft-canonicalize</code> implementation. This revealed gaps in my own implementation and led me to ask for the same algorithm that Python uses (later modified for optimizations and CVE resolutions).</p>
<p>Voilà! I had a working <code>soft-canonicalize</code> crate, so I could publish it and continue work on my jailed-path crate.</p>
<p>From here, the path guarantee became practical: validate first (without requiring existence), then operate safely.</p>
<h3 id="the-marker-type-innovation"><a class="header" href="#the-marker-type-innovation">The Marker Type Innovation</a></h3>
<p>Continuing work on <code>JailedPath</code>, I realized that sometimes we might wish to have more than one validated path, but how could we identify them correctly? That's when I came up with the <strong>Marker type</strong> idea: simply create your very own Marker type, providing additional context for the compiler and allowing us to prevent mixing up paths!</p>
<h3 id="security-research-and-cve-analysis"><a class="header" href="#security-research-and-cve-analysis">Security Research and CVE Analysis</a></h3>
<p>OK, now we have a really cool <code>JailedPath</code> crate! Let's further validate that we are safe by researching CVEs.</p>
<p>Oops! It looked like we had some gaps in our <code>soft-canonicalize</code> crate. That's where I took additional time investing in improving correctness, resilience, and performance. I created comprehensive Python benchmarks where I could validate <code>soft-canonicalize</code> performance vs Python's C language implementation. That took a while to perfect, but it was worth it because it could improve scalability in heavy usage cases.</p>
<h3 id="the-virtual-path-discovery"><a class="header" href="#the-virtual-path-discovery">The Virtual Path Discovery</a></h3>
<p>Researching existing alternatives, I discovered a use case for <strong>virtual paths</strong>—paths that are clamped to a virtual root. This made me reconsider my own use case for creating this crate, revealing a lot of potential.</p>
<p>I started wondering if this should be our default behavior. Eventually, I came to this conclusion: All I needed was a secure, validated Path type. So I applied the KISS method (Keep It Simple, Stupid) and decided that the core <code>JailedPath</code> should represent simply a path that has been validated.</p>
<p>However, there were clear uses for <code>VirtualPath</code>. After long consideration about whether this should be in a different crate, I decided to keep it inside <code>JailedPath</code> because:</p>
<ul>
<li>They share the same foundation</li>
<li>I didn't want to scatter logic across two crates</li>
<li>It's easier to maintain, use, and perform transitions between the two</li>
</ul>
<h3 id="the-great-renaming-journey"><a class="header" href="#the-great-renaming-journey">The Great Renaming Journey</a></h3>
<h4 id="from-pathvalidator-to-jail"><a class="header" href="#from-pathvalidator-to-jail">From PathValidator to Jail</a></h4>
<p>My first gut feeling was that while our <code>PathValidator</code> type was quite self-explanatory, it felt like an extra tool we needed to carry around. I was aiming to simplify the developer experience. <code>PathValidator</code> seemed easy to understand but not fun, with no clear relation to <code>JailedPath</code>.</p>
<p>So I decided to rename <code>PathValidator</code> to <code>Jail</code>. It made sense: we set up a jail and then validate paths against it.</p>
<h4 id="from-jail-to-pathboundary"><a class="header" href="#from-jail-to-pathboundary">From Jail to PathBoundary</a></h4>
<p>Eventually, <code>Jail</code> didn't feel completely right either, only because we were also supporting <code>VirtualPath</code> (created from a <code>VirtualRoot</code>). I realized that a newcomer (or someone returning to code after a long while) might get confused about what behavior to expect from a <code>Jail</code> and <code>JailedPath</code> type.</p>
<h4 id="the-api-surface-problem"><a class="header" href="#the-api-surface-problem">The API Surface Problem</a></h4>
<p>As a result of LLM agents generating faulty code, I could see how the API was being misused. This motivated me to reduce the API surface to the minimum required and ensure all methods are explicit about the difference between <code>JailedPath</code> and <code>VirtualPath</code>. No vague method names (such as <code>as_ref()</code>). No <code>Path</code> type escapes—the LLM would simply defeat the purpose of my crate by calling its inner path and calling <code>.join()</code> on it.</p>
<p><strong>The Problem with .join()</strong>: Calling <code>Path::join()</code> is no longer validated. The path could escape easily. And joining to a full path would completely override the path it's being joined to.</p>
<h4 id="the-three-join-problem"><a class="header" href="#the-three-join-problem">The "Three join() Problem"</a></h4>
<p>This led me to the "Three join() problem"—each time I saw a generated <code>.join()</code> in test code, I had to take a moment following the chain of methods to figure out if a <code>join()</code> belongs to <code>Path</code>, <code>JailedPath</code>, or <code>VirtualPath</code>.</p>
<p>This is where I decided that methods must be explicit. Seeing them in generated code helps immediately notice and understand their behavior:</p>
<ul>
<li><code>jailedpath_join()</code> vs <code>virtualpath_join()</code> vs <code>join()</code></li>
</ul>
<p>Seeing <code>join()</code> in our code would mean unsafe behavior that we could notice immediately.</p>
<p>This explicitness is critical for LLM- and review-friendly code: <code>.strict_join(..)</code>/<code>.virtual_join(..)</code> are visibly safe; raw <code>Path::join</code> stands out as a red flag.</p>
<h4 id="finding-the-right-balance"><a class="header" href="#finding-the-right-balance">Finding the Right Balance</a></h4>
<p>Fixing my demo projects, these methods seemed verbose. Since they were very common, I decided on shorter, easier names:</p>
<ul>
<li><code>jailed_join()</code>, <code>virtual_join()</code></li>
</ul>
<p>But we're back to behavior differences. Seeing <code>jailed_join()</code>, what does it mean? We'd need to refer to docs. While docs are important, wouldn't it be nicer if we could understand from the method name what's happening?</p>
<h4 id="the-final-names"><a class="header" href="#the-final-names">The Final Names</a></h4>
<p>Eventually (and finally), I did another rename:</p>
<ul>
<li><code>JailedPath</code> → <code>StrictPath</code> (clear that the path is restricted!)</li>
<li><code>Jail</code> → <code>PathBoundary</code> (goes hand-in-hand with <code>VirtualRoot</code>)</li>
<li><code>strict_join()</code> vs <code>virtual_join()</code> (perfect clarity!)</li>
</ul>
<h3 id="path-ergonomics-and-safety"><a class="header" href="#path-ergonomics-and-safety">Path Ergonomics and Safety</a></h3>
<p>Path ergonomics were crucial! I wanted to be as ergonomic as possible without breaking our established safety rules—especially not leaking out a <code>Path</code> type that could do a <code>.join()</code>.</p>
<p>Eventually, I came up with <code>.interop_path()</code>. It contains the suffix <code>_path</code> to hint that this is what API users need to interop <code>VirtualPath</code> and <code>StrictPath</code> directly in places where <code>AsRef&lt;Path&gt;</code> is expected. But we do not expose a <code>Path</code> type! Instead, we expose a borrow of an <code>OsStr</code>.</p>
<p>This is perfect! <code>OsStr</code>:</p>
<ul>
<li>Implements <code>AsRef&lt;Path&gt;</code> for integration with everything expecting <code>AsRef&lt;Path&gt;</code></li>
<li>Is cross-platform and fits the underlying operating system</li>
<li>Doesn't lose any data</li>
<li>Is what <code>Path</code> wraps anyway—we're just stripping off all the dangerous methods</li>
<li>Is what <code>Path</code> wraps anyway—we're just stripping off all the dangerous methods</li>
</ul>
<p>Escape hatches exist, but are explicit:</p>
<ul>
<li>Borrow strict from virtual: <code>vpath.as_unvirtual()</code></li>
<li>Ownership conversions: <code>virtualize()</code> / <code>unvirtual()</code> / <code>unstrict()</code> (use sparingly)</li>
</ul>
<h3 id="feature-integration"><a class="header" href="#feature-integration">Feature Integration</a></h3>
<p>I wanted to explore additional features by integrating with popular crates:</p>
<ul>
<li><strong>app-path</strong>: My own crate for easily referring to files near our executable, ensuring operations cannot escape our application directory</li>
<li><strong>dirs</strong>: Cross-platform access to system directories</li>
<li><strong>tempfile</strong>: Generate temporary directories with <code>PathBoundary::try_new_temp()</code></li>
</ul>
<h3 id="api-simplification"><a class="header" href="#api-simplification">API Simplification</a></h3>
<p>I kept improving demo examples and API clarity. Eventually, I realized: <code>StrictPath</code> contains the boundary path within it, just as <code>VirtualRoot</code> contains its root path (which is a <code>StrictPath</code>).</p>
<p>I explored whether we could work with just 2 types: <code>VirtualPath</code> and <code>StrictPath</code>. While possible, it wouldn't be ideal—sometimes we want to be explicit about roots and boundaries as promises.</p>
<p>I decided to keep <code>VirtualRoot</code> and <code>PathBoundary</code> but make common usage more concise with <code>StrictPath::with_boundary()</code> and <code>VirtualPath::with_root()</code>. This made code much more concise while remaining highly readable.</p>
<h3 id="zerotrust-vs-lexical-approaches"><a class="header" href="#zerotrust-vs-lexical-approaches">Zero‑Trust vs Lexical Approaches</a></h3>
<ul>
<li>If you want a zero‑trust approach that covers (almost) everything that can go wrong, prefer canonicalized validation and joins. They resolve symlinks and normalize platform-specific forms before enforcement.</li>
<li>If you need maximum performance and you are absolutely certain symlinks cannot occur and paths are already canonical/normalized, a lexical solution from another crate may fit — but you accept the risk and narrower threat model.</li>
</ul>
<h3 id="the-road-to-publication"><a class="header" href="#the-road-to-publication">The Road to Publication</a></h3>
<p>This was a long journey, but it isn't over yet. It's time to make this crate public, ensuring all generated docs are correct and we don't have leftovers.</p>
<p>The version is now good enough to be the first stable foundation for a security crate! I hope this catches on (I didn't really expect it when I started), and at some point, I began thinking of it as a potential new standard for securing paths.</p>
<p>If this succeeds, I'd like to port it to other programming languages—JavaScript, Java, and Python first! In a way, I hope this will be what prepared statements are for SQL: a fundamental security practice that becomes standard across the ecosystem.</p>
<h2 id="lessons-learned"><a class="header" href="#lessons-learned">Lessons Learned</a></h2>
<p>The journey taught me several important lessons:</p>
<ol>
<li><strong>Security requires iteration</strong>: Each security review revealed new edge cases</li>
<li><strong>API design is crucial</strong>: Small naming decisions have huge impacts on usability</li>
<li><strong>Ergonomics vs Safety</strong>: You can have both, but it requires careful design</li>
<li><strong>Community feedback matters</strong>: LLM-generated code revealed real usage patterns</li>
<li><strong>Standards evolve</strong>: What seems like a simple idea often grows into something much more comprehensive</li>
</ol>
<p>The result is <code>strict-path</code>—a crate that not only solves the original path validation problem but provides a comprehensive, ergonomic, and secure foundation for all path operations in Rust applications.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
