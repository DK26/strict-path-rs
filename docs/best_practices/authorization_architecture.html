<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Authorization Architecture - The Complete StrictPath Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive guide to strict-path: Type-safe path boundaries preventing directory traversal attacks">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Complete StrictPath Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DK26/strict-path-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/DK26/strict-path-rs/edit/docs/docs_src/src/best_practices/authorization_architecture.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="authorization-architecture-with-markers"><a class="header" href="#authorization-architecture-with-markers">Authorization Architecture with Markers</a></h1>
<blockquote>
<p><em>Move authorization bugs from "runtime disasters" into "won't compile" problems.</em></p>
</blockquote>
<p>Marker types enable <strong>compile-time authorization architectures</strong> where the compiler mathematically proves that any path with an authorization-requiring marker went through proper authorization.</p>
<p>This chapter shows three levels of authorization patterns: basic authentication, permission tuples, and dynamic elevation.</p>
<hr />
<h2 id="core-concept-markers-as-proof"><a class="header" href="#core-concept-markers-as-proof">Core Concept: Markers as Proof</a></h2>
<p><strong>Key insight</strong>: A marker with a private field can <strong>only be constructed</strong> by authorized code. Functions requiring that marker have compile-time proof that authorization happened.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserHome { 
    _proof: ()  // Private field = can't construct outside this module
}

// This function signature enforces authentication
fn read_user_file(file: &amp;strict_path::StrictPath&lt;UserHome&gt;) -&gt; std::io::Result&lt;String&gt; {
    // Guaranteed: path is validated AND user was authenticated
    file.read_to_string()
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Without a <code>UserHome</code> marker, you cannot call <code>read_user_file()</code>.</strong> The compiler enforces this.</p>
<hr />
<h2 id="level-1-basic-authentication-markers"><a class="header" href="#level-1-basic-authentication-markers">Level 1: Basic Authentication Markers</a></h2>
<p>Use markers with private fields to prove authentication happened.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Marker describes user's home directory with compile-time proof
struct UserHome { 
    _proof: ()  // Private field prevents construction outside this module
}

impl UserHome {
    /// Authenticates user and returns authorization marker
    pub fn authenticate(token: &amp;AuthToken) -&gt; Result&lt;Self, AuthError&gt; {
        // Real authentication logic here (verify JWT, session, etc.)
        if verify_token(token)? {
            Ok(UserHome { _proof: () })  // Grant marker after verification
        } else {
            Err(AuthError::InvalidToken)
        }
    }
}

// Functions require pre-authorized paths
fn read_user_file(file: &amp;StrictPath&lt;UserHome&gt;) -&gt; std::io::Result&lt;String&gt; {
    // Guaranteed: path is safe AND user was authenticated
    file.read_to_string()
}

fn list_user_files(dir: &amp;PathBoundary&lt;UserHome&gt;) -&gt; std::io::Result&lt;Vec&lt;String&gt;&gt; {
    let mut names = Vec::new();
    for entry in dir.strict_join("")?.read_dir()? {
        let entry = entry?;
        names.push(entry.file_name().to_string_lossy().to_string());
    }
    Ok(names)
}

// Usage: authentication required to get marker
fn handle_request(
    token: &amp;AuthToken,
    filename: &amp;str
) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    // Authentication checkpoint
    let _auth = UserHome::authenticate(token)?;
    
    // Create boundary with authorized marker
    let username = token.username();
    let home_dir = PathBoundary::&lt;UserHome&gt;::try_new(format!("/home/{username}"))?;
    
    // Path inherits authorization from boundary
    let file = home_dir.strict_join(filename)?;
    
    // Function call proves authentication happened
    Ok(read_user_file(&amp;file)?)
}

// Stub types for example
struct AuthToken { username: String }
impl AuthToken {
    fn username(&amp;self) -&gt; &amp;str { &amp;self.username }
}
enum AuthError { InvalidToken }
fn verify_token(_token: &amp;AuthToken) -&gt; Result&lt;(), AuthError&gt; { Ok(()) }
<span class="boring">}</span></code></pre></pre>
<h3 id="key-pattern-elements"><a class="header" href="#key-pattern-elements">Key Pattern Elements</a></h3>
<ol>
<li><strong>Private <code>_proof</code> field</strong> prevents external construction</li>
<li><strong><code>authenticate()</code> constructor</strong> verifies credentials before granting marker</li>
<li><strong>Functions accept <code>&amp;StrictPath&lt;UserHome&gt;</code></strong> = compile-time proof</li>
<li><strong>Wrong marker = compile error</strong> (can't pass <code>StrictPath&lt;AdminFiles&gt;</code> to <code>read_user_file()</code>)</li>
</ol>
<p><strong>Benefits:</strong></p>
<ul>
<li>Impossible to bypass authentication (can't construct marker without verifying)</li>
<li>Refactoring changes propagate through type system</li>
<li>Authentication logic centralized in marker constructor</li>
</ul>
<hr />
<h2 id="level-2-tuple-markers-for-permissions"><a class="header" href="#level-2-tuple-markers-for-permissions">Level 2: Tuple Markers for Permissions</a></h2>
<p>Encode <strong>both domain and permission level</strong> in the type using tuple markers.</p>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Domain markers
struct SystemFiles;
struct UserDocuments;

// Permission markers (private construction)
struct ReadOnly { _proof: () }
struct ReadWrite { _proof: () }
struct AdminPermission { _proof: () }

impl ReadOnly {
    pub fn grant_read(user: &amp;User) -&gt; Result&lt;Self, PermissionError&gt; {
        if user.can_read_system_files() {
            Ok(ReadOnly { _proof: () })
        } else {
            Err(PermissionError::Denied)
        }
    }
}

impl ReadWrite {
    pub fn grant_write(user: &amp;User) -&gt; Result&lt;Self, PermissionError&gt; {
        if user.can_write_documents() {
            Ok(ReadWrite { _proof: () })
        } else {
            Err(PermissionError::Denied)
        }
    }
}

impl AdminPermission {
    pub fn grant_admin(user: &amp;User) -&gt; Result&lt;Self, PermissionError&gt; {
        if user.is_admin() {
            Ok(AdminPermission { _proof: () })
        } else {
            Err(PermissionError::Denied)
        }
    }
}

// Functions encode both domain and permission requirements
fn view_system_file(
    path: &amp;StrictPath&lt;(SystemFiles, ReadOnly)&gt;
) -&gt; std::io::Result&lt;String&gt; {
    path.read_to_string()  // Can read but not modify
}

fn modify_system_file(
    path: &amp;StrictPath&lt;(SystemFiles, AdminPermission)&gt;,
    data: &amp;[u8]
) -&gt; std::io::Result&lt;()&gt; {
    path.write(data)  // Requires admin permission
}

fn edit_user_document(
    path: &amp;StrictPath&lt;(UserDocuments, ReadWrite)&gt;,
    data: &amp;[u8]
) -&gt; std::io::Result&lt;()&gt; {
    path.write(data)  // User documents + write permission
}

// Usage: Permission matrix enforced at compile time
fn user_workflow(user: &amp;User) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Grant appropriate permissions
    let _read_perm = ReadOnly::grant_read(user)?;
    let _write_perm = ReadWrite::grant_write(user)?;
    
    // Create boundaries with permission markers
    let system_dir = PathBoundary::&lt;(SystemFiles, ReadOnly)&gt;::try_new("/etc")?;
    let docs_dir = PathBoundary::&lt;(UserDocuments, ReadWrite)&gt;::try_new("/home/user/docs")?;
    
    // Operations matched to permissions
    let config = system_dir.strict_join("app.conf")?;
    let content = view_system_file(&amp;config)?;  // ✅ ReadOnly matches
    
    let doc = docs_dir.strict_join("notes.txt")?;
    edit_user_document(&amp;doc, b"updated")?;  // ✅ ReadWrite matches
    
    // ❌ Compile error: wrong permission level
    // modify_system_file(&amp;config, b"hacked")?;
    //   Expected: (SystemFiles, AdminPermission)
    //   Found:    (SystemFiles, ReadOnly)
    
    Ok(())
}

// Stub types
struct User { role: Role }
enum Role { Regular, Admin }
impl User {
    fn can_read_system_files(&amp;self) -&gt; bool { true }
    fn can_write_documents(&amp;self) -&gt; bool { !matches!(self.role, Role::Admin) }
    fn is_admin(&amp;self) -&gt; bool { matches!(self.role, Role::Admin) }
}
enum PermissionError { Denied }
<span class="boring">}</span></code></pre></pre>
<h3 id="permission-matrix-enforced-by-compiler"><a class="header" href="#permission-matrix-enforced-by-compiler">Permission Matrix Enforced by Compiler</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Required Marker</th><th>What it Proves</th></tr></thead><tbody>
<tr><td><code>view_system_file()</code></td><td><code>(SystemFiles, ReadOnly)</code></td><td>Domain = system, Permission = read</td></tr>
<tr><td><code>modify_system_file()</code></td><td><code>(SystemFiles, AdminPermission)</code></td><td>Domain = system, Permission = admin</td></tr>
<tr><td><code>edit_user_document()</code></td><td><code>(UserDocuments, ReadWrite)</code></td><td>Domain = user docs, Permission = write</td></tr>
</tbody></table>
</div>
<p><strong>Key insight</strong>: Wrong domain OR wrong permission = compile error. The type system enforces your entire permission matrix.</p>
<hr />
<h2 id="level-3-dynamic-authorization-with-change_marker"><a class="header" href="#level-3-dynamic-authorization-with-change_marker">Level 3: Dynamic Authorization with <code>change_marker()</code></a></h2>
<p>Sometimes permission levels change after <strong>runtime checks</strong>. Use <code>change_marker()</code> to transform markers after verification.</p>
<h3 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct Documents;
struct ReadOnly { _proof: () }
struct ReadWrite { _proof: () }

impl ReadWrite {
    fn elevate(user: &amp;User) -&gt; Result&lt;Self, PermissionError&gt; {
        if user.has_write_permission() {
            Ok(ReadWrite { _proof: () })
        } else {
            Err(PermissionError::Denied)
        }
    }
}

fn escalate_permissions(
    user: &amp;User,
    file: StrictPath&lt;(Documents, ReadOnly)&gt;
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Start with read-only access
    let content = file.read_to_string()?;
    println!("Current content: {content}");
    
    // Check if user can write
    if let Ok(_write_perm) = ReadWrite::elevate(user) {
        // ✅ CORRECT: change_marker() after authorization check
        let writable: StrictPath&lt;(Documents, ReadWrite)&gt; = file.change_marker();
        writable.write(b"updated content")?;
        println!("Updated successfully");
    } else {
        println!("Read-only access - cannot modify");
    }
    
    Ok(())
}

// Stub types
struct User { can_write: bool }
impl User {
    fn has_write_permission(&amp;self) -&gt; bool { self.can_write }
}
enum PermissionError { Denied }
<span class="boring">}</span></code></pre></pre>
<h3 id="critical-rule-verify-before-transform"><a class="header" href="#critical-rule-verify-before-transform">Critical Rule: Verify Before Transform</a></h3>
<p><strong>NEVER use <code>change_marker()</code> without authorization:</strong></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct Documents;
struct ReadOnly;
struct ReadWrite;

// ❌ WRONG: Speculative marker change without verification
fn escalate_wrong(file: StrictPath&lt;(Documents, ReadOnly)&gt;) -&gt; StrictPath&lt;(Documents, ReadWrite)&gt; {
    file.change_marker()  // No authorization check!
}

// ✅ CORRECT: Verify authorization first
fn escalate_correct(
    user: &amp;User,
    file: StrictPath&lt;(Documents, ReadOnly)&gt;
) -&gt; Result&lt;StrictPath&lt;(Documents, ReadWrite)&gt;, PermissionError&gt; {
    if user.has_write_permission() {
        Ok(file.change_marker())  // Transform after verification
    } else {
        Err(PermissionError::Denied)
    }
}

struct User { can_write: bool }
impl User {
    fn has_write_permission(&amp;self) -&gt; bool { self.can_write }
}
enum PermissionError { Denied }
<span class="boring">}</span></code></pre></pre>
<p><strong>When to use <code>change_marker()</code>:</strong></p>
<ul>
<li>After authenticating/authorizing a user and granting different permissions</li>
<li>When escalating or downgrading access levels based on runtime checks</li>
<li>When reinterpreting a path's security context after validation</li>
</ul>
<p><strong>When NOT to use <code>change_marker()</code>:</strong></p>
<ul>
<li>When converting between path types (conversions preserve markers automatically)</li>
<li>Without verifying authorization first (NEVER change markers speculatively)</li>
</ul>
<hr />
<h2 id="architecture-comparison-table"><a class="header" href="#architecture-comparison-table">Architecture Comparison Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Marker Pattern</th><th>Compile-Time Guarantee</th><th>Runtime Check Location</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>Basic Auth</strong></td><td><code>StrictPath&lt;UserHome&gt;</code></td><td>User was authenticated</td><td>Marker construction</td><td>Prove login happened</td></tr>
<tr><td><strong>Permissions</strong></td><td><code>StrictPath&lt;(Domain, Permission)&gt;</code></td><td>User has specific permission in domain</td><td>Permission grant</td><td>Enforce permission matrix</td></tr>
<tr><td><strong>Dynamic</strong></td><td><code>change_marker()</code> after check</td><td>Authorization verified before transform</td><td>Before <code>change_marker()</code></td><td>Runtime permission escalation</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="real-world-example-multi-level-authorization"><a class="header" href="#real-world-example-multi-level-authorization">Real-World Example: Multi-Level Authorization</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Domain markers
struct ProjectFiles;

// Permission markers
struct Viewer { _proof: () }
struct Editor { _proof: () }
struct Owner { _proof: () }

impl Viewer {
    fn authenticate(user: &amp;User, project_id: &amp;str) -&gt; Result&lt;Self, AuthError&gt; {
        if user.can_view(project_id) {
            Ok(Viewer { _proof: () })
        } else {
            Err(AuthError::Forbidden)
        }
    }
}

impl Editor {
    fn promote_from_viewer(user: &amp;User, project_id: &amp;str) -&gt; Result&lt;Self, AuthError&gt; {
        if user.can_edit(project_id) {
            Ok(Editor { _proof: () })
        } else {
            Err(AuthError::Forbidden)
        }
    }
}

impl Owner {
    fn promote_from_editor(user: &amp;User, project_id: &amp;str) -&gt; Result&lt;Self, AuthError&gt; {
        if user.is_owner(project_id) {
            Ok(Owner { _proof: () })
        } else {
            Err(AuthError::Forbidden)
        }
    }
}

// Functions with different permission requirements
fn read_project_file(file: &amp;StrictPath&lt;(ProjectFiles, Viewer)&gt;) -&gt; std::io::Result&lt;String&gt; {
    file.read_to_string()
}

fn update_project_file(
    file: &amp;StrictPath&lt;(ProjectFiles, Editor)&gt;,
    data: &amp;[u8]
) -&gt; std::io::Result&lt;()&gt; {
    file.write(data)
}

fn delete_project(dir: &amp;PathBoundary&lt;(ProjectFiles, Owner)&gt;) -&gt; std::io::Result&lt;()&gt; {
    std::fs::remove_dir_all(dir.strict_join("")?.interop_path())
}

// Workflow: Dynamic permission escalation
fn handle_project_request(
    user: &amp;User,
    project_id: &amp;str,
    action: Action
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Step 1: Basic authentication
    let _viewer = Viewer::authenticate(user, project_id)?;
    let project_dir = PathBoundary::&lt;(ProjectFiles, Viewer)&gt;::try_new(
        format!("/projects/{project_id}")
    )?;
    
    match action {
        Action::Read(filename) =&gt; {
            let file = project_dir.strict_join(&amp;filename)?;
            let content = read_project_file(&amp;file)?;
            println!("Content: {content}");
        },
        
        Action::Edit(filename, data) =&gt; {
            // Step 2: Escalate to Editor
            let _editor = Editor::promote_from_viewer(user, project_id)?;
            let project_dir_edit: PathBoundary&lt;(ProjectFiles, Editor)&gt; = 
                project_dir.change_marker();
            
            let file = project_dir_edit.strict_join(&amp;filename)?;
            update_project_file(&amp;file, data.as_bytes())?;
        },
        
        Action::Delete =&gt; {
            // Step 3: Escalate to Owner
            let _owner = Owner::promote_from_editor(user, project_id)?;
            let project_dir_owner: PathBoundary&lt;(ProjectFiles, Owner)&gt; = 
                project_dir.change_marker();
            
            delete_project(&amp;project_dir_owner)?;
        },
    }
    
    Ok(())
}

// Stub types
struct User { id: String, permissions: Vec&lt;String&gt; }
impl User {
    fn can_view(&amp;self, _project: &amp;str) -&gt; bool { true }
    fn can_edit(&amp;self, project: &amp;str) -&gt; bool { 
        self.permissions.contains(&amp;format!("edit:{project}"))
    }
    fn is_owner(&amp;self, project: &amp;str) -&gt; bool {
        self.permissions.contains(&amp;format!("own:{project}"))
    }
}
enum Action { Read(String), Edit(String, String), Delete }
enum AuthError { Forbidden }
<span class="boring">}</span></code></pre></pre>
<p><strong>Key patterns in this example:</strong></p>
<ul>
<li>Viewer → Editor → Owner escalation chain</li>
<li>Each level requires explicit runtime check</li>
<li><code>change_marker()</code> called after verification</li>
<li>Compiler prevents calling higher-privilege functions with lower-privilege markers</li>
</ul>
<hr />
<h2 id="summary-authorization-levels"><a class="header" href="#summary-authorization-levels">Summary: Authorization Levels</a></h2>
<p><strong>Choose the right level for your needs:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Need</th><th>Use Pattern</th><th>Example</th></tr></thead><tbody>
<tr><td><strong>Prove login happened</strong></td><td>Basic marker</td><td><code>StrictPath&lt;UserHome&gt;</code></td></tr>
<tr><td><strong>Enforce permission matrix</strong></td><td>Tuple markers</td><td><code>StrictPath&lt;(Domain, Permission)&gt;</code></td></tr>
<tr><td><strong>Runtime permission changes</strong></td><td><code>change_marker()</code> after check</td><td><code>file.change_marker::&lt;ReadWrite&gt;()</code></td></tr>
</tbody></table>
</div>
<p><strong>Core principle</strong>: Move authorization from "runtime checks we hope happen" to "compile-time proofs the compiler enforces."</p>
<hr />
<h2 id="learn-more"><a class="header" href="#learn-more">Learn More</a></h2>
<ul>
<li><strong><a href="../best_practices.html">Best Practices Overview →</a></strong> - Core guidelines and decision matrices</li>
<li><strong><a href="./policy_and_reuse.html">Policy &amp; Reuse Patterns →</a></strong> - Why and when to use policy types</li>
<li><strong><a href="./real_world_patterns.html">Real-World Patterns →</a></strong> - Production examples with authorization</li>
<li><strong><a href="./common_operations.html">Common Operations →</a></strong> - How to use authorized paths</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../best_practices/policy_and_reuse.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../anti_patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../best_practices/policy_and_reuse.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../anti_patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
