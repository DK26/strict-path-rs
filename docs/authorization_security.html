<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Path Permissions &amp; Authorization Security - The Complete StrictPath Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Complete StrictPath Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="advanced-marker-types-authorization-security"><a class="header" href="#advanced-marker-types-authorization-security">Advanced Marker Types: Authorization Security</a></h1>
<blockquote>
<p><strong>Building on Marker Fundamentals</strong>: This section shows advanced marker patterns for authorization security. If you're new to markers, read the <a href="../README.html#-type-system-guarantees-in-signatures">Type-System Guarantees section</a> first to understand basic marker concepts.</p>
</blockquote>
<h2 id="from-basic-markers-to-authorization-aware-markers"><a class="header" href="#from-basic-markers-to-authorization-aware-markers">From Basic Markers to Authorization-Aware Markers</a></h2>
<p>You've already learned that markers describe <strong>what</strong> paths contain and prevent cross-domain mix-ups:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PublicAssets;  // CSS, JS, images
struct UserUploads;   // User documents

let css_file: StrictPath&lt;PublicAssets&gt; = public_boundary.strict_join("style.css")?;
let doc_file: StrictPath&lt;UserUploads&gt; = uploads_boundary.strict_join("report.pdf")?;
<span class="boring">}</span></code></pre></pre>
<p>But what if creating these markers required <strong>authorization</strong>? What if you could only construct <code>UserUploads</code> after proving you're allowed to access user uploads?</p>
<h2 id="the-vision-authorization-aware-markers"><a class="header" href="#the-vision-authorization-aware-markers">The Vision: Authorization-Aware Markers</a></h2>
<p>The key insight: <strong>markers still describe content, but their construction requires proof of authorization</strong>.</p>
<ul>
<li><strong>Marker name</strong>: Describes what the path contains (<code>UserProfile</code>, <code>AdminConfig</code>)</li>
<li><strong>Private constructor</strong>: Requires authentication to create the marker</li>
<li><strong>Function signatures</strong>: Work with meaningful domain types, ensuring both path safety AND authorization</li>
</ul>
<h2 id="basic-authorization-aware-markers"><a class="header" href="#basic-authorization-aware-markers">Basic Authorization-Aware Markers</a></h2>
<p>The core concept is elegantly simple: <strong>the marker describes what the path contains</strong>, but the marker can only be constructed through proper authorization.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath};

// Marker describes the domain/content - what the path contains
struct UserProfile {
    // Private field prevents external construction
    _proof: (),
}

impl UserProfile {
    // Only way to create this marker - requires actual authentication
    pub fn authenticate_for_profile_access(credentials: &amp;Credentials) -&gt; Result&lt;Self, AuthError&gt; {
        if verify_user_credentials(credentials)? {
            Ok(UserProfile { _proof: () })
        } else {
            Err(AuthError::InvalidCredentials)
        }
    }
}

// Functions work with meaningful path types
fn read_profile_data(path: &amp;StrictPath&lt;UserProfile&gt;) -&gt; io::Result&lt;String&gt; {
    // If this function is called, user is guaranteed to be authorized for profile access
    path.read_to_string()
}

fn update_profile_data(path: &amp;StrictPath&lt;UserProfile&gt;, content: &amp;str) -&gt; io::Result&lt;()&gt; {
    // Same guarantee here
    path.write(content)
}

// Usage - authentication is required to get the marker
let profile_access = UserProfile::authenticate_for_profile_access(&amp;user_credentials)?;
let profile_boundary: PathBoundary&lt;UserProfile&gt; = PathBoundary::try_new("profiles")?;
let profile_file: StrictPath&lt;UserProfile&gt; = profile_boundary.strict_join("user_123.json")?;

// These work because we proved authorization to access UserProfile content
read_profile_data(&amp;profile_file)?;
update_profile_data(&amp;profile_file, "updated profile data")?;

// Without authentication, you can't even create the StrictPath&lt;UserProfile&gt;
// The marker is meaningful (describes profiles) AND requires authorization to construct!
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-different-permission-levels"><a class="header" href="#advanced-different-permission-levels">Advanced: Different Permission Levels</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Markers describe content domains, but require different levels of auth to construct
struct UserDocuments { _proof: () }
struct AdminConfig { _proof: () }
struct SystemLogs { _proof: () }

impl UserDocuments {
    pub fn authenticate_for_documents(token: &amp;Token) -&gt; Result&lt;Self, AuthError&gt; {
        verify_user_token(token)?; // Basic user auth
        Ok(UserDocuments { _proof: () })
    }
}

impl AdminConfig {
    pub fn authenticate_for_config(token: &amp;Token) -&gt; Result&lt;Self, AuthError&gt; {
        verify_admin_token(token)?; // Admin-level auth required
        Ok(AdminConfig { _proof: () })
    }
}

impl SystemLogs {
    pub fn authenticate_for_logs(token: &amp;Token) -&gt; Result&lt;Self, AuthError&gt; {
        verify_system_token(token)?; // System-level auth required
        Ok(SystemLogs { _proof: () })
    }
}

// Functions work with meaningful domain types
fn read_document(path: &amp;StrictPath&lt;UserDocuments&gt;) -&gt; io::Result&lt;String&gt; {
    path.read_to_string()
}

fn read_config(path: &amp;StrictPath&lt;AdminConfig&gt;) -&gt; io::Result&lt;String&gt; {
    path.read_to_string()
}

fn read_logs(path: &amp;StrictPath&lt;SystemLogs&gt;) -&gt; io::Result&lt;String&gt; {
    path.read_to_string()
}

fn update_config(path: &amp;StrictPath&lt;AdminConfig&gt;, content: &amp;str) -&gt; io::Result&lt;()&gt; {
    path.write(content)
}

// Usage
let doc_access = UserDocuments::authenticate_for_documents(&amp;user_token)?;
let admin_access = AdminConfig::authenticate_for_config(&amp;admin_token)?;
let system_access = SystemLogs::authenticate_for_logs(&amp;system_token)?;

let doc_boundary: PathBoundary&lt;UserDocuments&gt; = PathBoundary::try_new("documents")?;
let config_boundary: PathBoundary&lt;AdminConfig&gt; = PathBoundary::try_new("config")?;
let logs_boundary: PathBoundary&lt;SystemLogs&gt; = PathBoundary::try_new("logs")?;

let user_doc: StrictPath&lt;UserDocuments&gt; = doc_boundary.strict_join("report.pdf")?;
let app_config: StrictPath&lt;AdminConfig&gt; = config_boundary.strict_join("settings.json")?;
let system_log: StrictPath&lt;SystemLogs&gt; = logs_boundary.strict_join("app.log")?;

// Clear, meaningful operations
read_document(&amp;user_doc)?; // ✅ OK - reading user documents
read_config(&amp;app_config)?; // ✅ OK - reading admin config  
read_logs(&amp;system_log)?;   // ✅ OK - reading system logs
update_config(&amp;app_config, "new settings")?; // ✅ OK - admin can update config

// Impossible operations become compile errors:
// update_config(&amp;user_doc, "hack")?; // ❌ Can't pass UserDocuments to AdminConfig function
// read_logs(&amp;user_doc)?; // ❌ Can't pass UserDocuments to SystemLogs function
<span class="boring">}</span></code></pre></pre>
<h2 id="capability-based-authorization"><a class="header" href="#capability-based-authorization">Capability-Based Authorization</a></h2>
<p>For more sophisticated authorization, we can encode specific capabilities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

// Capability types
struct CanRead;
struct CanWrite; 
struct CanDelete;
struct CanAdmin;

// Marker combines domain + user + capabilities
struct UserDocument&lt;User, Caps&gt;(PhantomData&lt;(User, Caps)&gt;);

// Type-level capability checking
trait HasCapability&lt;Cap&gt; {}

// Grant read capability to various permission combinations
impl&lt;U&gt; HasCapability&lt;CanRead&gt; for UserDocument&lt;U, (CanRead,)&gt; {}
impl&lt;U&gt; HasCapability&lt;CanRead&gt; for UserDocument&lt;U, (CanRead, CanWrite)&gt; {}
impl&lt;U&gt; HasCapability&lt;CanRead&gt; for UserDocument&lt;U, (CanRead, CanWrite, CanDelete)&gt; {}

// Grant write capability only when explicitly present
impl&lt;U&gt; HasCapability&lt;CanWrite&gt; for UserDocument&lt;U, (CanRead, CanWrite)&gt; {}
impl&lt;U&gt; HasCapability&lt;CanWrite&gt; for UserDocument&lt;U, (CanRead, CanWrite, CanDelete)&gt; {}

// Grant delete capability only when explicitly present  
impl&lt;U&gt; HasCapability&lt;CanDelete&gt; for UserDocument&lt;U, (CanRead, CanWrite, CanDelete)&gt; {}

// Functions enforce capabilities at compile time
fn read_file&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; io::Result&lt;String&gt;
where 
    M: HasCapability&lt;CanRead&gt;
{
    path.read_to_string()
}

fn write_file&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;, content: &amp;str) -&gt; io::Result&lt;()&gt;
where 
    M: HasCapability&lt;CanWrite&gt;
{
    path.write(content)
}

fn delete_file&lt;M&gt;(path: &amp;StrictPath&lt;M&gt;) -&gt; io::Result&lt;()&gt;
where 
    M: HasCapability&lt;CanDelete&gt;
{
    path.remove_file()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="authorization-token-integration"><a class="header" href="#authorization-token-integration">Authorization Token Integration</a></h2>
<p>The key challenge is connecting runtime authentication with compile-time types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Proof of authorization required to create capability-aware paths
struct AuthToken&lt;User, Caps&gt; {
    user_id: User,
    capabilities: Caps,
    expires_at: SystemTime,
    signature: [u8; 32], // HMAC or similar
}

impl&lt;User, Caps&gt; AuthToken&lt;User, Caps&gt; {
    fn verify(&amp;self) -&gt; Result&lt;(), AuthError&gt; {
        // Verify signature, expiration, etc.
        if SystemTime::now() &gt; self.expires_at {
            return Err(AuthError::TokenExpired);
        }
        // Verify HMAC signature...
        Ok(())
    }
}

// Create authorized paths only with valid tokens
fn create_authorized_boundary&lt;U, C&gt;(
    workspace_path: impl AsRef&lt;Path&gt;,
    auth_token: AuthToken&lt;U, C&gt;
) -&gt; Result&lt;PathBoundary&lt;UserDocument&lt;U, C&gt;&gt;, AuthError&gt; {
    auth_token.verify()?;
    PathBoundary::try_new_create(workspace_path)
        .map_err(AuthError::PathBoundary)
}

// Usage with JWT-style tokens
let alice_readonly_token: AuthToken&lt;UserId(123), (CanRead,)&gt; = 
    parse_jwt_token(request.headers.authorization)?;

let alice_boundary = create_authorized_boundary(
    "workspace/alice", 
    alice_readonly_token
)?;

let document: StrictPath&lt;UserDocument&lt;UserId(123), (CanRead,)&gt;&gt; = 
    alice_boundary.strict_join("document.txt")?;

// Alice can read (capability proven at compile time)
let content = read_file(&amp;document)?; // ✅ Compiles

// Alice cannot write (would be compile error)  
// write_file(&amp;document, "new content")?; // ❌ Missing CanWrite capability
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-role-based-access-control-rbac"><a class="header" href="#advanced-role-based-access-control-rbac">Advanced: Role-Based Access Control (RBAC)</a></h2>
<p>For enterprise applications, we can model complex role hierarchies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define roles
struct Guest;
struct User; 
struct Moderator;
struct Admin;

// Role hierarchy via trait implementations
trait RoleHierarchy&lt;Role&gt; {}

impl RoleHierarchy&lt;Guest&gt; for User {} // User includes Guest permissions
impl RoleHierarchy&lt;Guest&gt; for Moderator {}
impl RoleHierarchy&lt;User&gt; for Moderator {} // Moderator includes User permissions  
impl RoleHierarchy&lt;Guest&gt; for Admin {}
impl RoleHierarchy&lt;User&gt; for Admin {}
impl RoleHierarchy&lt;Moderator&gt; for Admin {} // Admin includes all permissions

// Resource access patterns
struct PublicContent&lt;Role&gt;(PhantomData&lt;Role&gt;);
struct UserContent&lt;Role&gt;(PhantomData&lt;Role&gt;); 
struct AdminContent&lt;Role&gt;(PhantomData&lt;Role&gt;);

// Access control rules
trait CanAccess&lt;Resource&gt; {}

impl&lt;R&gt; CanAccess&lt;PublicContent&lt;Guest&gt;&gt; for R where R: RoleHierarchy&lt;Guest&gt; {}
impl&lt;R&gt; CanAccess&lt;UserContent&lt;User&gt;&gt; for R where R: RoleHierarchy&lt;User&gt; {}
impl&lt;R&gt; CanAccess&lt;AdminContent&lt;Admin&gt;&gt; for R where R: RoleHierarchy&lt;Admin&gt; {}

// Type-safe resource access
fn access_resource&lt;Role, Resource&gt;(
    path: &amp;StrictPath&lt;Resource&gt;
) -&gt; io::Result&lt;String&gt;
where 
    Role: CanAccess&lt;Resource&gt;
{
    path.read_to_string()
}

// Usage
let admin_files: StrictPath&lt;AdminContent&lt;Admin&gt;&gt; = create_admin_path(admin_token)?;
let user_files: StrictPath&lt;UserContent&lt;User&gt;&gt; = create_user_path(user_token)?;

// Admin can access everything (role hierarchy)
access_resource::&lt;Admin, _&gt;(&amp;admin_files)?; // ✅ Admin accessing admin content
access_resource::&lt;Admin, _&gt;(&amp;user_files)?;  // ✅ Admin accessing user content

// Regular user cannot access admin content
access_resource::&lt;User, _&gt;(&amp;user_files)?;   // ✅ User accessing user content
// access_resource::&lt;User, _&gt;(&amp;admin_files)?; // ❌ Compile error!
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="web-server-integration"><a class="header" href="#web-server-integration">Web Server Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Axum extractor that creates type-safe paths
#[async_trait]
impl&lt;T&gt; FromRequestParts&lt;T&gt; for AuthorizedPath&lt;UserDocument&lt;UserId, Caps&gt;&gt;
where
    T: Send + Sync,
{
    type Rejection = AuthError;

    async fn from_request_parts(
        parts: &amp;mut Parts, 
        state: &amp;T
    ) -&gt; Result&lt;Self, Self::Rejection&gt; {
        // Extract JWT from headers
        let token = extract_jwt(&amp;parts.headers)?;
        
        // Parse capabilities from token
        let auth_token: AuthToken&lt;UserId, Caps&gt; = parse_token(token)?;
        
        // Create authorized boundary
        let boundary = create_authorized_boundary(
            format!("uploads/{}", auth_token.user_id), 
            auth_token
        )?;
        
        Ok(AuthorizedPath { boundary })
    }
}

// Handler function with compile-time authorization
async fn upload_file(
    AuthorizedPath(boundary): AuthorizedPath&lt;UserDocument&lt;UserId, (CanWrite,)&gt;&gt;,
    filename: String,
    body: Bytes
) -&gt; Result&lt;StatusCode, AppError&gt; {
    let file_path = boundary.strict_join(&amp;filename)?;
    write_file(&amp;file_path, &amp;body).await?; // ✅ Compile-time proven authorized
    Ok(StatusCode::CREATED)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="database-integration"><a class="header" href="#database-integration">Database Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connect authorization with database queries
async fn load_user_document&lt;const USER_ID: u64&gt;(
    db: &amp;Database,
    document_id: DocumentId,
    _proof: &amp;StrictPath&lt;UserDocument&lt;ConstUserId&lt;USER_ID&gt;, (CanRead,)&gt;&gt;
) -&gt; Result&lt;Document, DatabaseError&gt; {
    // The StrictPath proves the caller is authorized for USER_ID
    sqlx::query_as!(
        Document,
        "SELECT * FROM documents WHERE id = $1 AND user_id = $2",
        document_id.as_uuid(),
        USER_ID as i64
    )
    .fetch_one(db)
    .await
}
<span class="boring">}</span></code></pre></pre>
<h2 id="benefits--trade-offs"><a class="header" href="#benefits--trade-offs">Benefits &amp; Trade-offs</a></h2>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<ol>
<li><strong>Compile-Time Authorization</strong>: Many permission violations become type errors</li>
<li><strong>Zero Runtime Cost</strong>: All authorization types erased at compile time</li>
<li><strong>Impossible to Bypass</strong>: Function signatures enforce authorization requirements</li>
<li><strong>Self-Documenting</strong>: Code clearly shows what permissions are required</li>
<li><strong>Refactoring Safety</strong>: Permission changes cause compile errors in all affected code</li>
</ol>
<h3 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h3>
<ol>
<li><strong>Complexity</strong>: Type signatures become more sophisticated</li>
<li><strong>Learning Curve</strong>: Developers need to understand the authorization type system</li>
<li><strong>Rigidity</strong>: Some dynamic authorization patterns may be harder to express</li>
<li><strong>Token Management</strong>: Still need robust runtime token validation and lifecycle</li>
</ol>
<h3 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h3>
<p><strong>Good fit for:</strong></p>
<ul>
<li>Applications with well-defined, static permission models</li>
<li>Systems where authorization errors are costly to debug</li>
<li>Teams comfortable with advanced Rust type system features</li>
<li>Long-lived applications where compile-time safety pays off</li>
</ul>
<p><strong>Consider alternatives for:</strong></p>
<ul>
<li>Rapid prototyping where authorization requirements are still changing</li>
<li>Systems with highly dynamic permission models</li>
<li>Teams new to Rust or advanced type system concepts</li>
<li>Simple applications where runtime checks are sufficient</li>
</ul>
<h2 id="implementation-strategy"><a class="header" href="#implementation-strategy">Implementation Strategy</a></h2>
<p><strong>The beauty of this approach: it requires NO new API!</strong></p>
<p>This sophisticated authorization system works entirely with strict-path's existing marker system:</p>
<ul>
<li>Same <code>PathBoundary&lt;Marker&gt;</code> and <code>StrictPath&lt;Marker&gt;</code> types</li>
<li>Same <code>strict_join()</code>, <code>interop_path()</code>, and file operations</li>
<li>Zero changes to the core strict-path library</li>
</ul>
<p>You simply define more sophisticated marker types in your application code and let Rust's type system do the work. The authorization logic lives in:</p>
<ol>
<li><strong>Your marker type definitions</strong> (the capability traits and implementations)</li>
<li><strong>Your constructor functions</strong> (where you verify auth tokens before creating boundaries)</li>
<li><strong>Your function signatures</strong> (where you specify required capabilities)</li>
</ol>
<p>The key insight is leveraging Rust's zero-cost abstractions and existing strict-path APIs to move authorization logic from runtime to compile-time, without any library changes.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>By extending strict-path's marker system with sophisticated authorization types, we can create <strong>compile-time authorization guarantees</strong> that complement the existing path boundary security. This approach represents a new frontier in secure systems design, where the type system becomes an active participant in authorization enforcement.</p>
<p>While this adds complexity, the benefits of catching authorization bugs at compile time - rather than in production - make it compelling for security-critical applications.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="best_practices.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ergonomics/overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="best_practices.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ergonomics/overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
