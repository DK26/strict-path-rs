<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Best Practices &amp; Guidelines - The Complete StrictPath Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive guide to strict-path: Type-safe path boundaries preventing directory traversal attacks">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Complete StrictPath Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DK26/strict-path-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/DK26/strict-path-rs/edit/docs/docs_src/src/best_practices.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="best-practices--guidelines"><a class="header" href="#best-practices--guidelines">Best Practices &amp; Guidelines</a></h1>
<p>This page distills how to use strict-path correctly and ergonomically. Pair it with the Anti‚ÄëPatterns page for tell‚Äëoffs to avoid.</p>
<h2 id="why-every-simple-solution-fails"><a class="header" href="#why-every-simple-solution-fails">Why Every "Simple" Solution Fails</a></h2>
<p>The path security rabbit hole is deeper than you think. Here's why every naive approach creates new vulnerabilities:</p>
<h3 id="approach-1-just-check-for-"><a class="header" href="#approach-1-just-check-for-">Approach 1: "Just check for <code>../</code>"</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if path.contains("../") { return Err("Invalid path"); }
// ‚úÖ Blocks: "../../../etc/passwd"
// ‚ùå Bypassed by: "..%2F..%2F..%2Fetc%2Fpasswd" (URL encoding)
// ‚ùå Bypassed by: "....//....//etc//passwd" (double encoding)
// ‚ùå Bypassed by: "..\\..\\..\etc\passwd" (Windows separators)
<span class="boring">}</span></code></pre></pre>
<h3 id="approach-2-use-canonicalize-then-check"><a class="header" href="#approach-2-use-canonicalize-then-check">Approach 2: "Use canonicalize() then check"</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let canonical = fs::canonicalize(path)?;
if !canonical.starts_with("/safe/") { return Err("Escape attempt"); }
// ‚úÖ Blocks: Most directory traversal
// ‚ùå CVE-2022-21658: Race condition - symlink created between canonicalize and check
// ‚ùå CVE-2019-9855: Windows 8.3 names ("PROGRA~1" ‚Üí "Program Files")
// ‚ùå Fails on non-existent files (can't canonicalize what doesn't exist)
<span class="boring">}</span></code></pre></pre>
<h3 id="approach-3-normalize-the-path-first"><a class="header" href="#approach-3-normalize-the-path-first">Approach 3: "Normalize the path first"</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let normalized = path.replace("\\", "/").replace("../", "");
// ‚úÖ Blocks: Basic traversal
// ‚ùå Bypassed by: "....//" ‚Üí "../" after one replacement
// ‚ùå CVE-2020-12279: Unicode normalization attacks
// ‚ùå CVE-2017-17793: NTFS Alternate Data Streams ("file.txt:hidden")
// ‚ùå Misses absolute path replacement: "/etc/passwd" completely replaces base
<span class="boring">}</span></code></pre></pre>
<h3 id="approach-4-use-a-allowlist-of-safe-characters"><a class="header" href="#approach-4-use-a-allowlist-of-safe-characters">Approach 4: "Use a allowlist of safe characters"</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !path.chars().all(|c| c.is_alphanumeric() || c == '/') { return Err("Invalid"); }
// ‚úÖ Blocks: Most special characters
// ‚ùå Still vulnerable to: "/etc/passwd" (absolute path replacement)
// ‚ùå Too restrictive: blocks legitimate files like "report-2025.pdf"
// ‚ùå CVE-2025-8088: Misses platform-specific issues (Windows UNC, device names)
<span class="boring">}</span></code></pre></pre>
<h3 id="approach-5-combine-multiple-checks"><a class="header" href="#approach-5-combine-multiple-checks">Approach 5: "Combine multiple checks"</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check for ../, canonicalize, validate prefix, sanitize chars...
// ‚úÖ Blocks: Many attack vectors
// ‚ùå Complex = Buggy: 20+ edge cases, hard to maintain
// ‚ùå Platform-specific gaps: Windows vs Unix behavior differences  
// ‚ùå Performance cost: Multiple filesystem calls per validation
// ‚ùå Future CVEs: New attack vectors require updating every check
<span class="boring">}</span></code></pre></pre>
<h3 id="the-fundamental-problem"><a class="header" href="#the-fundamental-problem">The Fundamental Problem</a></h3>
<p><strong>Each "fix" creates new attack surface.</strong> Path security isn't a single problem‚Äîit's a class of problems that interact in complex ways. You need:</p>
<ol>
<li><strong>Encoding normalization</strong> (but not breaking legitimate files)</li>
<li><strong>Symlink resolution</strong> (but preventing race conditions)</li>
<li><strong>Platform consistency</strong> (Windows ‚â† Unix ‚â† Web)</li>
<li><strong>Boundary enforcement</strong> (mathematical, not string-based)</li>
<li><strong>Future-proof design</strong> (resistant to new attack vectors)</li>
</ol>
<p><strong>This is why strict-path exists.</strong> We solved this problem class once, correctly, so you don't have to.</p>
<h2 id="pick-the-right-type"><a class="header" href="#pick-the-right-type">Pick The Right Type</a></h2>
<h3 id="quick-decision-guide"><a class="header" href="#quick-decision-guide">Quick Decision Guide</a></h3>
<ul>
<li><strong>External/untrusted segments</strong> (HTTP/DB/manifest/LLM/archive entry):
<ul>
<li>UI/virtual flows: start with <code>VirtualPath::with_root(..).virtual_join(..)</code> for clamped joins and user‚Äëfacing display. For reuse across many joins, keep either the virtual root path value (<code>let root = VirtualPath::with_root(..)?;</code>) or a <code>VirtualRoot</code> and call <code>virtual_join(..)</code> ‚Äî both take <code>&amp;self</code> and return a new <code>VirtualPath</code> (no ownership taken).</li>
<li>System flows: start with <code>StrictPath::with_boundary(..).strict_join(..)</code> to reject unsafe joins and for system display. For reuse across many joins, keep a <code>PathBoundary</code> and call <code>strict_join(..)</code>.</li>
</ul>
</li>
<li><strong>Internal/trusted paths</strong> (hardcoded/CLI/env): use <code>Path</code>/<code>PathBuf</code>; only validate when combining with untrusted segments.</li>
</ul>
<h3 id="detailed-decision-matrix"><a class="header" href="#detailed-decision-matrix">Detailed Decision Matrix</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Source</th><th>Typical Input</th><th>Use VirtualPath For</th><th>Use StrictPath For</th><th>Notes</th></tr></thead><tbody>
<tr><td>üåê <strong>HTTP requests</strong></td><td>URL path segments, file names</td><td>Display/logging, safe virtual joins</td><td>System-facing interop/I/O</td><td>Always clamp user paths via <code>VirtualPath::virtual_join</code></td></tr>
<tr><td>üåç <strong>Web forms</strong></td><td>Form file fields, route params</td><td>User-facing display, UI navigation</td><td>System-facing interop/I/O</td><td>Treat all form inputs as untrusted</td></tr>
<tr><td>‚öôÔ∏è <strong>Configuration files</strong></td><td>Paths in config</td><td>UI display and I/O within boundary</td><td>System-facing interop/I/O</td><td>Validate each path before I/O</td></tr>
<tr><td>üíæ <strong>Database content</strong></td><td>Stored file paths</td><td>Rendering paths in UI dashboards</td><td>System-facing interop/I/O</td><td>Storage does not imply safety; validate on use</td></tr>
<tr><td>üìÇ <strong>CLI arguments</strong></td><td>Command-line path args</td><td>Pretty printing, I/O within boundary</td><td>System-facing interop/I/O</td><td>Validate args before touching filesystem</td></tr>
<tr><td>üîå <strong>External APIs</strong></td><td>Webhooks, 3rd-party payloads</td><td>Present sanitized paths to logs</td><td>System-facing interop/I/O</td><td>Never trust external systems</td></tr>
<tr><td>ü§ñ <strong>LLM/AI output</strong></td><td>Generated file names/paths</td><td>Display suggestions, I/O within boundary</td><td>System-facing interop/I/O</td><td>LLM output is untrusted by default</td></tr>
<tr><td>üì® <strong>Inter-service msgs</strong></td><td>Queue/event payloads</td><td>Observability output, I/O within boundary</td><td>System-facing interop/I/O</td><td>Validate on the consumer side</td></tr>
<tr><td>üì± <strong>Apps (desktop/mobile)</strong></td><td>Drag-and-drop, file pickers</td><td>Show picked paths in UI</td><td>System-facing interop/I/O</td><td>Validate selected paths before I/O</td></tr>
<tr><td>üì¶ <strong>Archive contents</strong></td><td>Entry names from ZIP/TAR</td><td>Progress UI, virtual joins</td><td>System-facing interop/I/O</td><td>Validate each entry to block zip-slip</td></tr>
<tr><td>üîß <strong>File format internals</strong></td><td>Embedded path strings</td><td>Diagnostics, I/O within boundary</td><td>System-facing interop/I/O</td><td>Never dereference without validation</td></tr>
</tbody></table>
</div>
<h3 id="security-philosophy"><a class="header" href="#security-philosophy">Security Philosophy</a></h3>
<p><strong>Think of it this way:</strong></p>
<ul>
<li><code>StrictPath</code> = <strong>Security Filter</strong> ‚Äî validates and rejects unsafe paths</li>
<li><code>VirtualPath</code> = <strong>Complete Sandbox</strong> ‚Äî clamps any input to stay safe</li>
</ul>
<p><strong>The Golden Rule</strong>: If you didn't create the path yourself, secure it first.</p>
<h2 id="why-keep-virtualroot-and-pathboundary-even-with-sugar"><a class="header" href="#why-keep-virtualroot-and-pathboundary-even-with-sugar">Why Keep <code>VirtualRoot</code> and <code>PathBoundary</code> (Even With Sugar)</a></h2>
<p>The sugar constructors (<code>StrictPath::with_boundary(..)</code>, <code>VirtualPath::with_root(..)</code>) are great for simple flows, but the root/boundary types still matter for correctness, reuse, and ergonomics as your code grows.</p>
<ul>
<li>
<p>Policy reuse and separation of concerns</p>
<ul>
<li>Roots/boundaries represent the security policy (the restriction) while paths represent validated values within that policy.</li>
<li>Construct once, reuse everywhere: join many untrusted segments against the same <code>&amp;PathBoundary</code>/<code>&amp;VirtualRoot</code> without re‚Äëchoosing policy.</li>
<li>Don‚Äôt construct boundaries inside helpers ‚Äî boundary choice is policy; encoding it at call sites improves reviewability and testing.</li>
</ul>
</li>
<li>
<p>Clear function signatures (stronger guarantees)</p>
<ul>
<li>Two canonical patterns that make intent obvious:
<ul>
<li>Take <code>&amp;StrictPath&lt;_&gt;</code> / <code>&amp;VirtualPath&lt;_&gt;</code> when the call site has already validated the input.</li>
<li>Take <code>&amp;PathBoundary&lt;_&gt;</code> / <code>&amp;VirtualRoot&lt;_&gt;</code> plus the untrusted segment when the helper performs validation.</li>
</ul>
</li>
<li>These signatures prevent helpers from ‚Äúpicking a root‚Äù silently and make security rules visible in code review.</li>
</ul>
</li>
<li>
<p>Contextual deserialization (serde)</p>
<ul>
<li><code>StrictPath</code>/<code>VirtualPath</code> can‚Äôt implement a blanket <code>Deserialize</code> safely ‚Äî they need runtime context (the boundary/root) to validate.</li>
<li>The serde seeds live on the context types: <code>serde_ext::WithBoundary(&amp;boundary)</code> and <code>serde_ext::WithVirtualRoot(&amp;vroot)</code>.</li>
<li>This makes deserialization explicit and auditable: where did the policy come from? what are we validating against?</li>
</ul>
</li>
<li>
<p>Interop and trait boundaries</p>
<ul>
<li>We intentionally do not implement <code>AsRef&lt;Path&gt;</code> on path types; this prevents leaking raw paths into APIs without review.</li>
<li>Roots/boundaries do implement <code>AsRef&lt;Path&gt;</code> so you can discover/walk directories at the root while keeping joins validated.</li>
<li>Display stays explicit: system display via <code>strictpath_display()</code>, virtual display via <code>virtualpath_display()</code>.</li>
</ul>
</li>
<li>
<p>OS directories and RAII helpers</p>
<ul>
<li>Discovery helpers (<code>try_new_os_*</code>, feature <code>dirs</code>) and temporary roots (<code>try_new_temp*</code>, feature <code>tempfile</code>) are on the root types.</li>
<li>Sugar constructors build on these ‚Äî you can still start simple and ‚Äúupgrade‚Äù to explicit roots when needed.</li>
</ul>
</li>
<li>
<p>Performance and canonicalization</p>
<ul>
<li>Canonicalize the root once; strict/virtual joins reuse that canonicalized state.</li>
<li>Virtual joins use anchored canonicalization to apply virtual semantics safely and consistently.</li>
</ul>
</li>
<li>
<p>Auditability and testing</p>
<ul>
<li>Centralizing the policy in a root value simplifies logging, tracing, and tests (e.g., pass <code>&amp;vroot</code> into helpers).</li>
<li>Debug for <code>VirtualPath</code> is intentionally verbose (system path + virtual view + restriction root) to aid audits.</li>
</ul>
</li>
</ul>
<p>When not to use them: if your flow is small and local, the sugar constructors are perfectly fine. Start with sugar; keep <code>PathBoundary</code>/<code>VirtualRoot</code> handy for policy reuse, serde, and shared helpers.</p>
<h2 id="encode-guarantees-in-signatures"><a class="header" href="#encode-guarantees-in-signatures">Encode Guarantees In Signatures</a></h2>
<ul>
<li>Helpers that touch the filesystem must encode safety:
<ul>
<li>Accept <code>&amp;StrictPath&lt;_&gt;</code> or <code>&amp;VirtualPath&lt;_&gt;</code> directly, or</li>
<li>Accept <code>&amp;PathBoundary&lt;_&gt;</code> / <code>&amp;VirtualRoot&lt;_&gt;</code> + the untrusted segment.</li>
</ul>
</li>
<li>Don‚Äôt construct boundaries/roots inside helpers ‚Äî boundary choice is policy.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, VirtualRoot, VirtualPath};

fn save_to_storage(p: &amp;StrictPath) -&gt; std::io::Result&lt;()&gt; { p.write("ok") }
fn load_from_storage(p: &amp;VirtualPath) -&gt; std::io::Result&lt;String&gt; { p.read_to_string() }

fn create_config(boundary: &amp;PathBoundary, name: &amp;str) -&gt; std::io::Result&lt;()&gt; {
  boundary.strict_join(name)?.write("cfg")
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multiuser-isolation-virtualpath-root"><a class="header" href="#multiuser-isolation-virtualpath-root">Multi‚ÄëUser Isolation (VirtualPath root)</a></h2>
<ul>
<li>Per‚Äëuser/tenant: for small flows, construct a root via <code>VirtualPath::with_root(..)</code> and join untrusted names with <code>virtual_join(..)</code>. For larger flows and reuse, create a <code>VirtualRoot</code> per user and call <code>virtual_join(..)</code>.</li>
<li>Share strict helpers by borrowing the strict view: <code>vpath.as_unvirtual()</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn upload(user_root: &amp;VirtualRoot, filename: &amp;str, bytes: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
  let vpath = user_root.virtual_join(filename)?;
  vpath.create_parent_dir_all()?;
  vpath.write(bytes)
}

// Sugar-first call site (one-off):
// let vroot = VirtualPath::with_root(format!("./cloud/user_{user_id}"))?;
// let vpath = vroot.virtual_join(filename)?; // same guarantees; keep VirtualRoot for reuse
<span class="boring">}</span></code></pre></pre>
<h2 id="interop--display"><a class="header" href="#interop--display">Interop &amp; Display</a></h2>
<ul>
<li>Interop (pass into <code>AsRef&lt;Path&gt;</code> APIs): <code>path.interop_path()</code> (no allocations).</li>
<li>Display:
<ul>
<li>System‚Äëfacing: <code>strictpath_display()</code> on <code>PathBoundary</code>/<code>StrictPath</code></li>
<li>User‚Äëfacing: <code>virtualpath_display()</code> on <code>VirtualPath</code></li>
</ul>
</li>
<li>Never use <code>interop_path().to_string_lossy()</code> for display.</li>
</ul>
<h2 id="directory-discovery-vs-validation"><a class="header" href="#directory-discovery-vs-validation">Directory Discovery vs Validation</a></h2>
<ul>
<li>Discovery (walking): call <code>boundary.read_dir()</code> (or <code>vroot.read_dir()</code>), collect names via <code>entry.file_name()</code>, then re‚Äëjoin with <code>strict_join</code>/<code>virtual_join</code> to validate before I/O.</li>
<li>Validation: join those relatives via <code>boundary.strict_join(..)</code> or <code>vroot.virtual_join(..)</code> before I/O. For small flows without a reusable root, you can construct via <code>StrictPath::with_boundary(..)</code> or <code>VirtualPath::with_root(..)</code> and then join.</li>
<li>Don‚Äôt validate constants like <code>"."</code>; only validate untrusted segments.</li>
</ul>
<h2 id="operations-use-explicit-methods"><a class="header" href="#operations-use-explicit-methods">Operations (Use Explicit Methods)</a></h2>
<ul>
<li>Joins: <code>strict_join(..)</code> / <code>virtual_join(..)</code></li>
<li>Parents: <code>strictpath_parent()</code> / <code>virtualpath_parent()</code></li>
<li>With file name/ext: <code>strictpath_with_file_name()</code> / <code>virtualpath_with_file_name()</code>, etc.</li>
<li>Rename/move: <code>strict_rename(..)</code> / <code>virtual_rename(..)</code></li>
<li>Deletion: <code>remove_file()</code> / <code>remove_dir()</code> / <code>remove_dir_all()</code></li>
<li>Metadata: <code>metadata()</code> (inspect filesystem info without leaking boundaries)</li>
<li>Avoid std <code>Path::join</code>/<code>parent</code> on leaked paths ‚Äî they ignore strict/virtual semantics.</li>
</ul>
<p>Example (rename):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::{PathBoundary, StrictPath, VirtualPath};

fn rotate_log(boundary: &amp;PathBoundary) -&gt; std::io::Result&lt;()&gt; {
    let current = boundary.strict_join("logs/app.log")?;
    current.create_parent_dir_all()?;
  current.write("ok")?;

    // Strict rename within same directory
    let rotated = current.strict_rename("logs/app.old")?;
    assert!(rotated.exists());

    // Virtual rename (user-facing path)
    let vp = rotated.clone().virtualize();
    let vp2 = vp.virtual_rename("app.archived")?;
    assert!(vp2.exists());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="naming-from-agentsmd"><a class="header" href="#naming-from-agentsmd">Naming (from AGENTS.md)</a></h2>
<ul>
<li>Variables reflect domain, not type:
<ul>
<li>Good: <code>config_dir</code>, <code>uploads_root</code>, <code>archive_src</code>, <code>mirror_src</code>, <code>user_vroot</code></li>
<li>Bad: <code>boundary</code>, <code>jail</code>, <code>source_</code> prefix</li>
</ul>
</li>
<li>Keep names consistent with the directory they represent (e.g., <code>archive_src</code> for <code>./archive_src</code>).</li>
</ul>
<h2 id="do--dont"><a class="header" href="#do--dont">Do / Don‚Äôt</a></h2>
<ul>
<li>Do: validate once at the boundary, pass types through helpers.</li>
<li>Do: use <code>VirtualRoot</code> for per‚Äëuser isolation; borrow strict view for shared helpers.</li>
<li>Do: prefer <code>impl AsRef&lt;Path&gt;</code> in helper params where you forward to validation.</li>
<li>Don‚Äôt: wrap secure types in <code>Path::new</code>/<code>PathBuf::from</code>.</li>
<li>Don‚Äôt: use <code>interop_path().as_ref()</code> or <code>as_unvirtual().interop_path()</code> (use <code>interop_path()</code> directly).</li>
<li>Don‚Äôt: use lossy strings for display or comparisons.</li>
</ul>
<h2 id="testing--doctests"><a class="header" href="#testing--doctests">Testing &amp; Doctests</a></h2>
<ul>
<li>Make doctests encode guarantees (signatures) and use the explicit ops.</li>
<li>Create temporary roots via <code>PathBoundary::try_new_create(..)</code> / <code>VirtualRoot::try_new_create(..)</code> in setup; clean up afterwards. Or use the sugar constructors for tests: <code>StrictPath::with_boundary_create(..)</code> / <code>VirtualPath::with_root_create(..)</code>.</li>
<li>For archive/HTTP examples, prefer offline simulations with deterministic inputs.</li>
</ul>
<h2 id="quick-patterns"><a class="header" href="#quick-patterns">Quick Patterns</a></h2>
<ul>
<li>Validate + write:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn write(boundary: &amp;PathBoundary, name: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    let sp = boundary.strict_join(name)?;
    sp.create_parent_dir_all()?;
    sp.write(data)
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Validate archive entry:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extract(vroot: &amp;VirtualRoot, entry: &amp;str, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    let vp = vroot.virtual_join(entry)?;
    vp.create_parent_dir_all()?;
    vp.write(data)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ergonomics-cheatsheet"><a class="header" href="#ergonomics-cheatsheet">Ergonomics Cheatsheet</a></h2>
<ul>
<li>
<p>Built-in I/O: prefer <code>StrictPath</code>/<code>VirtualPath</code> methods over exposing raw <code>Path</code></p>
</li>
<li>
<p>Interop: use <code>interop_path()</code> when passing into <code>AsRef&lt;Path&gt;</code> APIs (no allocations)</p>
</li>
<li>
<p>Avoid anti-patterns: never wrap secure types in <code>Path::new()</code> / <code>PathBuf::from()</code></p>
</li>
<li>
<p>Function signatures: encode policy via marker types in <code>StrictPath&lt;MyMarker&gt;</code> / <code>VirtualPath&lt;MyMarker&gt;</code></p>
</li>
<li>
<p>Equality/ordering: rely on the types‚Äô derived semantics; don‚Äôt convert to strings for comparison</p>
</li>
<li>
<p>Escape hatch (borrow): <code>as_unvirtual()</code>; ownership conversions: <code>virtualize()</code> / <code>unvirtual()</code> / <code>unstrict()</code> (use sparingly)</p>
</li>
<li>
<p>Share logic across strict/virtual:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consume_strict(p: &amp;StrictPath) -&gt; std::io::Result&lt;String&gt; { p.read_to_string() }
fn consume_virtual(p: &amp;VirtualPath) -&gt; std::io::Result&lt;String&gt; { consume_strict(p.as_unvirtual()) }
<span class="boring">}</span></code></pre></pre>
<p>See the dedicated Ergonomics section for deeper guidance:</p>
<ul>
<li>Overview: ./ergonomics/overview.md</li>
<li>Interop vs Display: ./ergonomics/interop_display.md</li>
<li>Function Signatures: ./ergonomics/signatures.md</li>
<li>Escape Hatches: ./ergonomics/escape_hatches.md</li>
<li>Equality &amp; Ordering: ./ergonomics/equality_ordering.md</li>
<li>Naming: ./ergonomics/naming.md</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="archive_extractors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="authorization_security.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="archive_extractors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="authorization_security.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
