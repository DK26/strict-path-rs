<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stage 4: Authorization with change_marker() - The Complete StrictPath Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive guide to strict-path: Type-safe path boundaries preventing directory traversal attacks">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Complete StrictPath Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/DK26/strict-path-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/DK26/strict-path-rs/edit/docs/docs_src/src/tutorial/stage4_authorization.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="stage-4-authorization-with-change_marker--compile-time-authorization-proofs"><a class="header" href="#stage-4-authorization-with-change_marker--compile-time-authorization-proofs">Stage 4: Authorization with <code>change_marker()</code> — Compile-Time Authorization Proofs</a></h1>
<blockquote>
<p><em>"The compiler can mathematically prove that authorization happened first."</em></p>
</blockquote>
<p>In Stage 3, you learned how markers prevent domain mix-ups. Now you'll learn how to <strong>encode authorization</strong> in markers using <code>change_marker()</code>, so the compiler can mathematically prove that authorization checks weren't forgotten.</p>
<h2 id="the-authorization-problem"><a class="header" href="#the-authorization-problem">The Authorization Problem</a></h2>
<p>Markers prevent domain confusion. But what about <strong>permissions</strong>? How do we encode "this user is authorized to write to this directory"?</p>
<h3 id="traditional-approach-runtime-checks-everywhere"><a class="header" href="#traditional-approach-runtime-checks-everywhere">Traditional Approach: Runtime Checks Everywhere</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct UserFiles;

// ❌ Problem: Authorization check inside every operation
fn write_user_file(path: &amp;StrictPath&lt;UserFiles&gt;, user_id: &amp;str, data: &amp;[u8]) 
    -&gt; std::io::Result&lt;()&gt; 
{
    if !is_authorized(user_id) {  // Runtime check (can forget!)
        return Err(std::io::Error::new(
            std::io::ErrorKind::PermissionDenied, 
            "Unauthorized"
        ));
    }
    path.write(data)
}

fn delete_user_file(path: &amp;StrictPath&lt;UserFiles&gt;, user_id: &amp;str) 
    -&gt; std::io::Result&lt;()&gt; 
{
    if !is_authorized(user_id) {  // Repeated check (can forget!)
        return Err(std::io::Error::new(
            std::io::ErrorKind::PermissionDenied, 
            "Unauthorized"
        ));
    }
    path.remove_file()
}

fn read_user_file(path: &amp;StrictPath&lt;UserFiles&gt;, user_id: &amp;str) 
    -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; 
{
    // Oops! Forgot the authorization check here! 🚨
    path.read()
}

fn is_authorized(user_id: &amp;str) -&gt; bool {
    user_id == "alice"
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Problems:</strong></p>
<ul>
<li>❌ Authorization checks scattered everywhere</li>
<li>❌ Easy to forget a check (see <code>read_user_file</code>)</li>
<li>❌ No compile-time guarantee that authorization happened</li>
<li>❌ Code review has to catch missing checks (humans are fallible)</li>
</ul>
<h3 id="better-approach-encode-authorization-in-the-type"><a class="header" href="#better-approach-encode-authorization-in-the-type">Better Approach: Encode Authorization in the Type</a></h3>
<p>Instead of <strong>checking</strong> authorization repeatedly, we <strong>encode</strong> it in the type once:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

// Resource marker: describes WHAT directory
struct UserFiles;

// Permission markers: describe LEVEL of access
struct ReadOnly;
struct ReadWrite;

// Authorization gate: validates token → returns authorized marker
fn authenticate_user_access(
    token: &amp;str,
    path: StrictPath&lt;(UserFiles, ReadOnly)&gt;
) -&gt; Option&lt;StrictPath&lt;(UserFiles, ReadWrite)&gt;&gt; {
    // ✅ Authorization: Token validated (checked once here!)
    if validate_token(token) {
        // Transform marker to encode proven authorization
        Some(path.change_marker::&lt;(UserFiles, ReadWrite)&gt;())
    } else {
        None
    }
}

fn validate_token(token: &amp;str) -&gt; bool {
    token == "valid-token-12345"  // Real apps: JWT validation, database lookup, etc.
}

// Functions accept paths that already prove authorization
fn write_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;, data: &amp;[u8]) 
    -&gt; std::io::Result&lt;()&gt; 
{
    // No authorization check needed! Type proves it already happened.
    path.write(data)
}

fn delete_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;) 
    -&gt; std::io::Result&lt;()&gt; 
{
    // No authorization check needed! Type proves it already happened.
    path.remove_file()
}

fn read_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadOnly)&gt;) 
    -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; 
{
    // ReadOnly access is sufficient for reading
    path.read()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="understanding-change_marker"><a class="header" href="#understanding-change_marker">Understanding <code>change_marker()</code></a></h2>
<h3 id="what-change_marker-is-not"><a class="header" href="#what-change_marker-is-not">What <code>change_marker()</code> Is NOT</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ WRONG way to think about it:
// "change_marker() grants permissions"
// "change_marker() does authorization"
<span class="boring">}</span></code></pre></pre>
<h3 id="what-change_marker-actually-does"><a class="header" href="#what-change_marker-actually-does">What <code>change_marker()</code> Actually Does</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ RIGHT way to think about it:
// "change_marker() ENCODES proven authorization in the type"
// "change_marker() transforms the marker AFTER authorization passed"
<span class="boring">}</span></code></pre></pre>
<p><strong>The pattern:</strong></p>
<ol>
<li>✅ <strong>Check authorization</strong> (token validation, capability check, etc.)</li>
<li>✅ <strong>If authorized:</strong> call <code>change_marker()</code> to encode that fact in the type</li>
<li>✅ <strong>Pass the new type</strong> to functions that require authorization</li>
<li>✅ <strong>The compiler proves</strong> authorization happened (can't get the marker any other way!)</li>
</ol>
<h2 id="using-it-complete-example"><a class="header" href="#using-it-complete-example">Using It: Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use strict_path::StrictPath;

struct UserFiles;
struct ReadOnly;
struct ReadWrite;

fn handle_request(token: &amp;str, filename: &amp;str, data: Option&lt;&amp;[u8]&gt;) 
    -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; 
{
    // Start with read-only access (no authorization yet)
    let user_files_dir: StrictPath&lt;(UserFiles, ReadOnly)&gt; = 
        StrictPath::with_boundary_create("user_files")?;
    
    let file_path = user_files_dir.strict_join(filename)?;

    // Anyone can read with ReadOnly marker
    let _content = read_user_file(&amp;file_path)?;
    println!("✅ Read succeeded (no authorization needed)");

    // Try to upgrade to ReadWrite by authenticating
    if let Some(writable_path) = authenticate_user_access(token, file_path) {
        // ✅ Token validated! Now we have ReadWrite access
        println!("✅ Authorization succeeded");
        
        if let Some(data) = data {
            write_user_file(&amp;writable_path, data)?;
            println!("✅ Write succeeded (authorization proven by type)");
        }
        
        delete_user_file(&amp;writable_path)?;
        println!("✅ Delete succeeded (authorization proven by type)");
    } else {
        println!("❌ Authorization failed — cannot write or delete");
    }

    Ok(())
}

fn authenticate_user_access(
    token: &amp;str,
    path: StrictPath&lt;(UserFiles, ReadOnly)&gt;
) -&gt; Option&lt;StrictPath&lt;(UserFiles, ReadWrite)&gt;&gt; {
    if validate_token(token) {
        Some(path.change_marker())
    } else {
        None
    }
}

fn validate_token(token: &amp;str) -&gt; bool {
    token == "valid-token-12345"
}

fn read_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadOnly)&gt;) -&gt; std::io::Result&lt;Vec&lt;u8&gt;&gt; {
    path.read()
}

fn write_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;, data: &amp;[u8]) -&gt; std::io::Result&lt;()&gt; {
    path.write(data)
}

fn delete_user_file(path: &amp;StrictPath&lt;(UserFiles, ReadWrite)&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.remove_file()
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Valid token — authorization succeeds
    handle_request("valid-token-12345", "notes.txt", Some(b"New content"))?;
    
    // Invalid token — authorization fails
    handle_request("invalid-token", "notes.txt", Some(b"Hack attempt"))?;
    
    Ok(())
}</code></pre></pre>
<h2 id="tuple-markers-composing-resources-and-permissions"><a class="header" href="#tuple-markers-composing-resources-and-permissions">Tuple Markers: Composing Resources and Permissions</a></h2>
<p>Notice we're using <strong>tuple markers</strong>: <code>(UserFiles, ReadOnly)</code> and <code>(UserFiles, ReadWrite)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserFiles;      // First element: WHAT resource
struct ReadOnly;       // Second element: WHAT permission level
struct ReadWrite;

// Composed together:
// StrictPath&lt;(UserFiles, ReadOnly)&gt;   = User files with read-only access
// StrictPath&lt;(UserFiles, ReadWrite)&gt;  = User files with read-write access
<span class="boring">}</span></code></pre></pre>
<p><strong>Why tuples?</strong></p>
<ul>
<li>✅ <strong>Flexible composition:</strong> Mix and match resources with permissions</li>
<li>✅ <strong>Easy to transform:</strong> <code>change_marker()</code> can swap out permission levels</li>
<li>✅ <strong>Standard Rust idiom:</strong> No need to learn special syntax</li>
</ul>
<h2 id="try-it-yourself-capability-based-authorization"><a class="header" href="#try-it-yourself-capability-based-authorization">Try It Yourself: Capability-Based Authorization</a></h2>
<p>Here's a more sophisticated example with multiple capability levels:</p>
<pre><pre class="playground"><code class="language-rust">use strict_path::StrictPath;

struct ProjectFiles;
struct CanRead;
struct CanWrite;
struct CanDelete;

// Check user role and return appropriate marker
fn grant_project_access(
    user_role: &amp;str,
    path: StrictPath&lt;ProjectFiles&gt;
) -&gt; Option&lt;StrictPath&lt;(ProjectFiles, CanRead, CanWrite, CanDelete)&gt;&gt; {
    // ✅ Authorization: Role checked
    if user_role == "admin" {
        // Admin gets full access (read + write + delete)
        Some(path.change_marker::&lt;(ProjectFiles, CanRead, CanWrite, CanDelete)&gt;())
    } else {
        None
    }
}

fn grant_editor_access(
    user_role: &amp;str,
    path: StrictPath&lt;ProjectFiles&gt;
) -&gt; Option&lt;StrictPath&lt;(ProjectFiles, CanRead, CanWrite)&gt;&gt; {
    // ✅ Authorization: Role checked
    if user_role == "editor" || user_role == "admin" {
        // Editors can read and write (but not delete)
        Some(path.change_marker::&lt;(ProjectFiles, CanRead, CanWrite)&gt;())
    } else {
        None
    }
}

fn grant_readonly_access(
    user_role: &amp;str,
    path: StrictPath&lt;ProjectFiles&gt;
) -&gt; Option&lt;StrictPath&lt;(ProjectFiles, CanRead)&gt;&gt; {
    // ✅ Authorization: Role checked
    if user_role == "viewer" || user_role == "editor" || user_role == "admin" {
        Some(path.change_marker::&lt;(ProjectFiles, CanRead)&gt;())
    } else {
        None
    }
}

// Functions require specific capabilities in their signature
fn read_project(path: &amp;StrictPath&lt;(ProjectFiles, CanRead)&gt;) -&gt; std::io::Result&lt;String&gt; {
    path.read_to_string()
}

fn update_project(path: &amp;StrictPath&lt;(ProjectFiles, CanRead, CanWrite)&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.write(b"Updated project data")
}

fn delete_project(path: &amp;StrictPath&lt;(ProjectFiles, CanRead, CanWrite, CanDelete)&gt;) -&gt; std::io::Result&lt;()&gt; {
    path.remove_file()
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let projects_dir: StrictPath&lt;ProjectFiles&gt; = 
        StrictPath::with_boundary_create("projects")?;
    
    let project = projects_dir.strict_join("proposal.md")?;

    // Viewer can only read
    if let Some(readonly_path) = grant_readonly_access("viewer", project.clone()) {
        read_project(&amp;readonly_path)?;
        println!("✅ Viewer: read succeeded");
        // update_project(&amp;readonly_path)?;  // ❌ Won't compile: missing CanWrite
    }

    // Editor can read and write
    if let Some(editor_path) = grant_editor_access("editor", project.clone()) {
        read_project(&amp;editor_path)?;      // ✅ Has CanRead
        update_project(&amp;editor_path)?;    // ✅ Has CanRead + CanWrite
        println!("✅ Editor: read and write succeeded");
        // delete_project(&amp;editor_path)?; // ❌ Won't compile: missing CanDelete
    }

    // Admin can do everything
    if let Some(admin_path) = grant_project_access("admin", project) {
        read_project(&amp;admin_path)?;      // ✅ Has CanRead
        update_project(&amp;admin_path)?;    // ✅ Has CanRead + CanWrite
        delete_project(&amp;admin_path)?;    // ✅ Has CanRead + CanWrite + CanDelete
        println!("✅ Admin: full access succeeded");
    }

    Ok(())
}</code></pre></pre>
<h2 id="head-first-moment-passport-stamps"><a class="header" href="#head-first-moment-passport-stamps">Head First Moment: Passport Stamps</a></h2>
<p>Think of <code>change_marker()</code> like <strong>stamping a passport</strong>:</p>
<ol>
<li><strong>You apply for a visa</strong> (submit token for validation)</li>
<li><strong>Visa office checks credentials</strong> (authorization function validates token)</li>
<li><strong>If approved, they stamp your passport</strong> (call <code>change_marker()</code>)</li>
<li><strong>Guards at checkpoints check your stamp</strong> (functions check marker type)</li>
</ol>
<p>The stamp doesn't grant permission — <strong>the visa office did that</strong>. The stamp just <strong>proves</strong> permission was granted.</p>
<p><strong>Functions check your stamp (marker), not your visa application (token).</strong></p>
<p>This means:</p>
<ul>
<li>✅ Authorization happens <strong>once</strong> (at the visa office)</li>
<li>✅ Every checkpoint trusts the stamp (no re-checking)</li>
<li>✅ Can't forge a stamp (only way to get marker is through auth function)</li>
<li>✅ Compiler ensures you have the right stamp for each checkpoint</li>
</ul>
<h2 id="the-authorization-pattern-summary"><a class="header" href="#the-authorization-pattern-summary">The Authorization Pattern Summary</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1️⃣ Define resource and permission markers
struct Resource;
struct ReadOnly;
struct ReadWrite;

// 2️⃣ Create authorization gate
fn authorize(token: &amp;str, path: StrictPath&lt;(Resource, ReadOnly)&gt;) 
    -&gt; Option&lt;StrictPath&lt;(Resource, ReadWrite)&gt;&gt; 
{
    if validate(token) {                        // ✅ Check authorization
        Some(path.change_marker())              // ✅ Encode in type
    } else {
        None                                    // ❌ Authorization failed
    }
}

// 3️⃣ Functions require authorized marker
fn protected_operation(path: &amp;StrictPath&lt;(Resource, ReadWrite)&gt;) {
    // No authorization check needed!
    // Type proves authorization already happened.
}
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-web-api"><a class="header" href="#real-world-example-web-api">Real-World Example: Web API</a></h2>
<p>Here's how you'd use this in a web server:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use strict_path::StrictPath;

struct ApiUploads;
struct AuthToken(String);
struct ReadAccess;
struct WriteAccess;

// Authorization: Validate JWT token
fn authorize_write_access(
    token: &amp;AuthToken,
    path: StrictPath&lt;(ApiUploads, ReadAccess)&gt;
) -&gt; Result&lt;StrictPath&lt;(ApiUploads, ReadAccess, WriteAccess)&gt;, AuthError&gt; {
    // ✅ Authorization: Validate JWT token
    if verify_jwt(&amp;token.0)? {
        Ok(path.change_marker())
    } else {
        Err(AuthError::InvalidToken)
    }
}

fn verify_jwt(token: &amp;str) -&gt; Result&lt;bool, AuthError&gt; {
    // Real implementation would:
    // - Verify signature
    // - Check expiration
    // - Validate claims
    Ok(token.starts_with("Bearer "))
}

// API handlers
fn handle_read(uploads: &amp;StrictPath&lt;(ApiUploads, ReadAccess)&gt;, filename: &amp;str) 
    -&gt; Result&lt;Vec&lt;u8&gt;, ApiError&gt; 
{
    let file = uploads.strict_join(filename)?;
    Ok(file.read()?)
}

fn handle_write(
    uploads: &amp;StrictPath&lt;(ApiUploads, ReadAccess, WriteAccess)&gt;, 
    filename: &amp;str,
    data: &amp;[u8]
) -&gt; Result&lt;(), ApiError&gt; 
{
    let file = uploads.strict_join(filename)?;
    Ok(file.write(data)?)
}

#[derive(Debug)]
enum AuthError {
    InvalidToken,
}

#[derive(Debug)]
enum ApiError {
    PathError(strict_path::StrictPathError),
    IoError(std::io::Error),
}

impl From&lt;strict_path::StrictPathError&gt; for ApiError {
    fn from(e: strict_path::StrictPathError) -&gt; Self {
        ApiError::PathError(e)
    }
}

impl From&lt;std::io::Error&gt; for ApiError {
    fn from(e: std::io::Error) -&gt; Self {
        ApiError::IoError(e)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p>✅ <strong><code>change_marker()</code> encodes proven authorization</strong> (doesn't grant it)<br />
✅ <strong>Tuple markers compose resources and permissions</strong><br />
✅ <strong>Authorization happens once</strong> — type system enforces it everywhere<br />
✅ <strong>Impossible to bypass</strong> — only way to get the marker is through auth gate<br />
✅ <strong>Compiler catches missing authorization</strong> — won't compile without proper marker</p>
<h2 id="the-complete-guarantee-so-far"><a class="header" href="#the-complete-guarantee-so-far">The Complete Guarantee So Far</a></h2>
<blockquote>
<p><strong>If a function accepts <code>StrictPath&lt;(Resource, Permission)&gt;</code>, the compiler mathematically proves that:</strong></p>
<ol>
<li>✅ The path cannot escape its boundary (Stage 1)</li>
<li>✅ The path is in the correct domain (Stage 3)</li>
<li>✅ Authorization was granted for that permission level (Stage 4)</li>
</ol>
</blockquote>
<p><strong>This is compile-time authorization.</strong> Forget a check? Won't compile. Use the wrong permission level? Won't compile. Bypass authorization? Impossible.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>You've mastered authorization with markers. But what about <strong>user-facing applications</strong> where you want to show clean paths like <code>/documents/file.txt</code> instead of ugly system paths?</p>
<p>That's where <code>VirtualPath</code> comes in...</p>
<p><strong><a href="./stage5_virtual_paths.html">Continue to Stage 5: Virtual Paths →</a></strong></p>
<hr />
<p><strong>Quick Reference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define markers
struct Resource;
struct ReadOnly;
struct ReadWrite;

// Authorization gate
fn authorize(token: &amp;str, path: StrictPath&lt;(Resource, ReadOnly)&gt;) 
    -&gt; Option&lt;StrictPath&lt;(Resource, ReadWrite)&gt;&gt; 
{
    if validate(token) {
        Some(path.change_marker())  // Encode authorization
    } else {
        None
    }
}

// Protected function
fn protected(path: &amp;StrictPath&lt;(Resource, ReadWrite)&gt;) {
    // No auth check needed — type proves it!
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tutorial/stage3_markers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tutorial/stage5_virtual_paths.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tutorial/stage3_markers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tutorial/stage5_virtual_paths.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
